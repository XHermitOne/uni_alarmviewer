────────────────────────────────────────────────────────────────────────
       B.Pascal 7 & Objects/TV#1     - 1 -

      ВВЕДЕНИЕ.......................................................13
      Что нового появилось в Turbo Vision?...........................13
      Характеристика Turbo Vision....................................14
      Как возникло программное средство Turbo Vision?................15
      Что следует знать для работы с Turbo Vision....................15
      Как пользоваться данной книгой?................................16
      Что содержится в данной книге?.................................16
      ЧАСТЬ 1. ЗНАКОМСТВО С TURBO VISION.............................17
      ГЛАВА 1. Погружение в Turbo Vision.............................17
      Элементы прикладной программы Turbo Vision.....................17
      Наименование частей............................................17
      Отображаемый элемент...........................................18
      События........................................................18
      "Безгласные" объекты...........................................19
      Шаг 1: Создание программы......................................20
      Построение простейшей программы................................20
      Расширение объекта программы...................................21
      Создание командной части (программной единицы).................23
      Шаг 2: Настройка меню и строк состояния........................24
      Инициализация программы........................................24
      Настройка строки состояния.....................................24
      Установка границ...............................................25
      Определение диапазонов контекстов подсказки....................25
      Определение клавиш состояния...................................27
      Настройка полосы меню..........................................29
      Установка границ...............................................29
      Определение пунктов меню.......................................30
      Определение подменю............................................31
      Использование функций для возврата из меню.....................33
      Подведем итоги.................................................35
      Отделение событий от реакции на них............................35
      Гибкое программирование........................................35
      ГЛАВА 2. Реакция на команды....................................37
      Что такое команды?.............................................37
      Понятие о командах.............................................37
      Что такое события?.............................................37
      Реакция на события.............................................38
      Обработка командных событий....................................39
      Шаг 3: Реакция на команды......................................39
      Изменение видеорежима..........................................40
      Вызов наследуемых методов......................................41
      Вывод информационного окна About...............................41
      Использование окон сообщений...................................42
      Комбинирование флагов окна сообщения...........................43
      Чтение значений, возвращаемых окном сообщения..................43
      Разрешение и запрещение команд.................................43
      Какие команды можно запретить?.................................44
      Запрещение команд..............................................44
      Разрешение команд..............................................45
      ГЛАВА 3. Добавление окон.......................................46
      Шаг 4: Добавление окна.........................................46
      Добавление простого окна.......................................47
      Назначение границ окна.........................................47

       B.Pascal 7 & Objects/TV#1     - 2 -

      Построение оконного объекта....................................47
      Включение окна.................................................48
      Более надежное включение.......................................48
      Вывод окон с перекрытием и без перекрытия......................49
      Добавление окна редактора......................................49
      Определения буфера редактирования файла........................49
      Задание диалоговых окон редактора..............................50
      Построение окна редактора......................................50
      Использование стандартных диалоговых окон......................52
      Построение файлового диалогового окна..........................53
      Выполнение диалогового окна....................................53
      Построение окна редактирования файла...........................54
      Шаг 5: Добавление окна буфера вырезанного изображения..........54
      Построение окна редактора......................................55
      Присваивание редактора буфера вырезанного изображения..........55
      Вывод окна буфера вырезанного изображения на экран.............56
      ГЛАВА 4. Использование потоков и ресурсов......................58
      Шаг 6: Сохранение и восстановление оперативной области.........58
      Регистрация в потоках..........................................58
      Отслеживание ошибок потоков....................................59
      Сохранение оперативной области.................................60
      Запись объекта в поток.........................................60
      Сохранение буфера вырезанного изображения......................62
      Восстановление оперативной области.............................62
      Загрузка объекта оперативной области...........................63
      Проверка допустимости объекта..................................64
      Замена оперативной области.....................................64
      Шаг 7: Использование ресурсов..................................66
      Создание файла ресурса.........................................67
      Что такое файл ресурса?........................................67
      Запись ресурсов в файл.........................................67
      Загрузка ресурса полосы меню...................................68
      Открытие файла ресурса.........................................68
      Загрузка ресурса полосы меню...................................69
      Закрытие файла ресурса.........................................70
      Загрузка ресурса строки состояния..............................70
      Загрузка объекта строки состояния..............................70
      Настройка позиции строки состояния.............................71
      Загрузка ресурса информационного окна About....................71
      Определение ресурса диалогового окна...........................72
      Загрузка ресурса диалогового окна..............................73
      Выполнение диалогового окна....................................73
      ГЛАВА 5. Создание окон ввода данных............................75
      Шаг 8: Создание окна ввода данных..............................75
      Создание нового оконного типа..................................76
      Ограничение открытия окна......................................78
      Передача сообщений.............................................78
      Реакция на сообщения...........................................79
      Добавление в окно управляющих элементов........................80
      Добавление полей объекта.......................................80
      Установка границ и включение...................................80
      Шаг 9: Установка значений управляющих элементов................83
      Задание записи данных..........................................83

       B.Pascal 7 & Objects/TV#1     - 3 -

      Определение необходимых данных.................................84
      Создание структуры записи......................................85
      Установка значений управляющих элементов.......................85
      Считывание значений управляющих элементов......................86
      Шаг 10: Проверка допустимости вводимых данных..................88
      Назначение объектов проверки допустимости......................88
      Построение объекта проверки допустимости.......................88
      Назначение строке ввода объекта проверки допустимости..........89
      Вызов методов проверки допустимости............................90
      Проверка допустимости при закрытии.............................90
      Проверка допустимости по табуляции.............................91
      Проверка допустимости по запросу...............................91
      ГЛАВА 6. Наборы данных.........................................93
      Шаг 11: Добавление набора данных...............................93
      Создание объекта данных........................................93
      Загрузка набора................................................95
      Вывод записи на экран..........................................95
      Сохранение записи..............................................97
      Перемещение от записи к записи.................................98
      Отмена изменений редактирования...............................100
      Шаг 12: Создание специализированного отображаемого элемента...102
      Создание механизма подсчета...................................102
      Построение отображаемого элемента.............................103
      Вывод отображаемого элемента на экран.........................104
      Использование счетчика........................................105
      Добавление счетчика к окну....................................105
      Работа со счетчиком...........................................105
      Что дальше?...................................................107
      Дополнительные диалоговые окна................................107
      Проверка допустимости методом просмотра.......................107
      ЧАСТЬ 2. Использование Turbo Vision...........................108
      ГЛАВА 7. Обзор Turbo Vision...................................108
      Работа с объектами иерархии...................................113
      Основные операции с объектами.................................113
      Создание производных объектов.................................113
      Создание экземпляра объекта...................................114
      Абстрактные объекты...........................................115
      Наследование полей............................................116
      Наследование полей отображаемых элементов.....................118
      Виды методов..................................................118
      Статические методы............................................119
      Виртуальные методы............................................119
      Абстрактные методы............................................119
      Псевдо-абстрактные методы.....................................119
      Типология объектов............................................120
      Примитивные типы объектов.....................................120
      Объект TPoint.................................................120
      Объект TRect..................................................121
      Объект TObject................................................121
      Отображаемые элементы.........................................121
      Рамки.........................................................122
      Командные кнопки..............................................122
      Кластеры......................................................122

       B.Pascal 7 & Objects/TV#1     - 4 -

      Меню..........................................................123
      Протоколы.....................................................123
      Строки ввода..................................................123
      Области просмотра списков.....................................124
      Прокручиваемые отображаемые элементы..........................124
      Полосы прокрутки..............................................124
      Текстовые устройства..........................................124
      Статический текст.............................................125
      Строки состояния..............................................125
      Групповые отображаемые элементы...............................126
      Абстрактная группа............................................126
      Приложения....................................................126
      Оперативные области...........................................127
      Окна..........................................................127
      Окна диалога..................................................127
      Механизмы и средства..........................................127
      Потоки........................................................128
      Ресурсы.......................................................128
      Наборы........................................................128
      Строковые списки..............................................128
      Средства проверки допустимости................................129
      Координаты Turbo Vision.......................................129
      Задание границ................................................130
      Локальные и глобальные координаты.............................131
      Использование битовых полей...................................132
      Значения флага................................................133
      Битовые маски.................................................133
      Поразрядные операции..........................................133
      Установка бит.................................................134
      Очистка бит...................................................134
      Переключение бит..............................................135
      Проверка бит..................................................135
      Использование масок...........................................135
      Итоги.........................................................135
      ГЛАВА 8. Отображаемые элементы................................136
      Что такое отображаемый элемент?...............................136
      Определение отображаемого элемента............................136
      Определение прямоугольной области.............................137
      Отображение по запросу........................................137
      Обработка событий.............................................138
      Что такое группа?.............................................138
      Передача функций подэлементам.................................138
      Использование объектов отображаемых элементов.................139
      Построение объектов отображаемых элементов....................139
      Вызов наследуемого конструктора...............................139
      Управление границами отображаемого элемента...................140
      Получение координат отображаемого элемента....................140
      Перемещение отображаемого элемента............................142
      Изменение размера отображаемого элемента......................142
      Одновременное перемещение и изменение размера.................142
      Размещение отображаемых элементов в своих владельцах..........142
      Вывод отображаемого элемента на экран.........................143
      Отображение по запросу........................................143

       B.Pascal 7 & Objects/TV#1     - 5 -

      Изменение флагов параметров отображаемого элемента............144
      Настройка выбора..............................................144
      Изображение рамки отображаемого элемента......................145
      Специальная обработка событий.................................145
      Центрирование отображаемого элемента..........................146
      Установка состояния отображаемого элемента....................147
      Установка и очистка флагов состояния..........................148
      Реакция на изменение состояния................................149
      Буксировка отображаемого элемента.............................150
      Установка предельных значений буксировки......................150
      Вызов метода DragView.........................................150
      Управление курсором...........................................151
      Вывод и сокрытие курсора......................................152
      Изменение стиля курсора.......................................152
      Перемещение курсора...........................................152
      Проверка допустимости отображаемого элемента..................153
      Проверка правильности построения..............................153
      Проверка возможности закрытия.................................153
      Проверка допустимости данных..................................154
      Написание методов Draw........................................154
      Выбор цветов..................................................155
      Непосредственная запись.......................................155
      Запись через буферы...........................................156
      Установка цвета текста........................................156
      Перемещение текста в буферы...................................156
      Запись буфера на экран........................................157
      Использование групповых объектов..............................158
      Группы, подгруппы и владельцы.................................160
      Включение отображаемых подэлементов...........................160
      Разделение групповой области..................................161
      Обеспечение фона..............................................161
      Принципы отображаемых подэлементов............................162
      Что такое дерево отображаемых элементов?......................163
      Что такое Z-последовательность?...............................166
      Выбор отображаемых подэлементов и перемещение на них фокуса...169
      Поиск выделенного отображаемого элемента......................170
      Как происходит выделение отображаемого элемента?..............170
      Изменение режима увеличения...................................172
      Изображение групп.............................................172
      Отображение в Z-последовательности............................173
      Использование кеш-буферов.....................................174
      Блокировка и разблокировка отображений........................174
      Отсечение отображаемых подэлементов...........................175
      Выполнение режимных групп.....................................175
      Что такое режимность?.........................................176
      Переход группы в режимное состояние...........................176
      Поиск режимного отображаемого элемента........................177
      Завершение режимного состояния................................177
      Управление отображаемыми подэлементами........................178
      Удаление отображаемых подэлементов............................178
      Итерация отображаемых подэлементов............................179
      Поиск конкретного отображаемого подэлемента...................179
      ГЛАВА 9. Программирование, управляемое событиями..............180

       B.Pascal 7 & Objects/TV#1     - 6 -

      Turbo Vision и решение основных проблем.......................180
      Чтение входных данных пользователя............................180
      Природа событий...............................................181
      Виды сообщений................................................183
      События, связанные с "мышью"..................................184
      События, связанные с клавиатурой..............................184
      События, связанные с сообщениями..............................184
      Событие типа "никаких действий"...............................184
      События и команды.............................................184
      Маршрутизация событий.........................................185
      Откуда появляются события?....................................185
      Описание маршрута событий.....................................186
      События позиционирования......................................186
      События перемещения фокуса....................................186
      События оповещения............................................187
      События, определяемые пользователем...........................188
      Маскирование событий..........................................190
      Фаза..........................................................190
      Поле Phase....................................................191
      Команды.......................................................192
      Определение команд............................................194
      Привязка команд...............................................195
      Разрешение и запрещение команд................................195
      Обработка событий.............................................196
      Запись события................................................197
      Очистка событий...............................................198
      Несостоявшиеся события........................................198
      Модификация механизма обработки событий.......................198
      Централизованный сбор событий.................................199
      Переопределение метода GetEvent...............................199
      Использование времени простоя.................................200
      Связь между отображаемыми элементами..........................200
      Промежуточные отображаемые элементы...........................201
      Сообщения между отображаемыми элементами......................201
      Кто управляет оповещением?....................................203
      Все ли в порядке?.............................................203
      Какое окно верхнее?...........................................204
      Вызов метода HandleEvent......................................204
      ГЛАВА 10. Объекты приложения..................................206
      Организация объектов приложения...............................206
      Приложение как отображаемый элемент...........................206
      Приложение как группа.........................................207
      Приложение как владелец подэлементов..........................207
      Режимность приложения.........................................207
      Методы Init, Run и Done.......................................207
      Конструктор Init..............................................208
      Метод Run.....................................................208
      Деструктор Done...............................................209
      Построение объекта приложения.................................209
      Вызов наследуемого конструктора...............................209
      Конструктор TProgram..........................................210
      Порядок вызовов...............................................210
      Инициализация подсистем.......................................211

       B.Pascal 7 & Objects/TV#1     - 7 -

      Администратор памяти..........................................212
      Видеоадминистратор............................................212
      Администратор событий.........................................212
      Обработчик системной ошибки...................................213
      Администратор протокола.......................................213
      Изменение режимов экрана......................................214
      Настройка оперативной области.................................214
      Построение объекта оперативной области........................215
      Использование наследуемого метода.............................215
      Замена наследуемого метода....................................215
      Включение и выполнение окон...................................216
      Включение безрежимных окон....................................216
      Выполнение режимных отображаемых элементов....................216
      Упорядочивание окон...........................................217
      Задание области упорядочивания................................217
      Задание направления...........................................218
      Изменение фона................................................218
      Изменение символа образца.....................................218
      Изображение сложного фона.....................................219
      Выход в командный процессор DOS...............................221
      Настройка сообщения командного процессора.....................221
      Настройка строки состояния....................................221
      Определение границ строки состояния...........................222
      Использование невидимых строк состояния.......................222
      Создание определений состояния................................223
      Создание клавиш состояния.....................................224
      Использование функции NewStatusKey............................225
      Использование функций клавиш состояния........................225
      Добавление справочной информации в строку состояния...........226
      Обновление строки состояния...................................227
      Настройка меню................................................228
      Задание границ полосы меню....................................228
      Определение пунктов меню......................................229
      Использование функции NewItem.................................229
      Использование функции NewSubMenu..............................229
      Использование времени простоя.................................229
      Контекстно-зависимый справочник...............................231
      ГЛАВА 11. Объекты окон и диалоговых окон......................232
      Принципы построения окон......................................232
      Чем отличаются окна и диалоговые окна.........................233
      Работа с окнами...............................................234
      Построение оконных объектов...................................234
      Построение используемых по умолчанию окон.....................235
      Изменение флагов окна.........................................235
      Включение окон в оперативную область..........................236
      Выполнение режимных окон......................................238
      Перевод окна в режимное состояние.............................238
      Завершение режимного состояния................................238
      Обработка записей данных......................................239
      Изменение параметров окна, заданных по умолчанию..............239
      Использование стандартных палитр окна.........................239
      Изменение заголовка окна......................................240
      Изменение рамки окна..........................................240

       B.Pascal 7 & Objects/TV#1     - 8 -

      Использование номеров окон....................................241
      Управление размером окна......................................241
      Ограничение размера окна......................................241
      Распахивание окон.............................................241
      Создание полос прокрутки окна.................................242
      Работа с диалоговыми окнами...................................243
      Используемые по умолчанию атрибуты диалогового окна...........243
      Поведение режимного диалогового окна..........................243
      Обработка событий диалогового окна............................243
      Использование в диалоговом окне управляющих элементов.........244
      Добавление в диалоговое окно управляющих элементов............244
      Как пользователи наблюдают порядок табуляции..................245
      Как программист наблюдает порядок табуляции...................245
      Работа с управляющими элементами..............................245
      Определение записей данных окна...............................246
      Установка значений управляющих элементов......................246
      Считывание значений управляющих элементов.....................246
      Работа с управляющими элементами в режимных диалоговых
       окнах........................................................247
      Использование стандартных диалоговых окон.....................247
      Использование окон сообщений..................................247
      Строка сообщения и ее параметры...............................248
      Установка флагов окна сообщения...............................248
      Использование файловых диалоговых окон........................248
      Использование диалоговых окон смены каталога..................249
      ГЛАВА 12. Использование объектов управляющих элементов........250
      Использование объектов управляющих элементов..................250
      Построение объектов управляющих элементов.....................250
      Инициализация объектов управляющих элементов..................251
      Установка и считывание значений управляющих элементов.........251
      Установка значений управляющих элементов......................252
      Считывание значений управляющих элементов.....................254
      Настройка передачи данных.....................................254
      Вывод статического текста.....................................255
      Вывод простого текста.........................................256
      Форматирование статического текста............................256
      Построение статических текстовых отображаемых элементов.......256
      Задание и считывание статического текста......................257
      Вывод на экран параметризированного текста....................257
      Форматирование параметризированного текста....................257
      Построение параметризированных текстовых управляющих
       элементов....................................................259
      Установка и считывание параметризированного текста............259
      Использование полос прокрутки.................................259
      Построение управляющих элементов полос прокрутки..............260
      Манипулирование управляющими элементами полосы прокрутки......260
      Реакция на полосы прокрутки...................................260
      Использование кластерных объектов.............................261
      Работа с кластерными объектами................................262
      Построение кластерных объектов................................262
      Нажатие командной кнопки......................................262
      Указание на выбор кнопки......................................263
      Запрещение отдельных командных кнопок.........................263

       B.Pascal 7 & Objects/TV#1     - 9 -

      Использование кнопок с независимой фиксацией..................263
      Использование кнопок с зависимой фиксацией....................263
      Использование кнопок с независимой фиксацией с несколькими
       состояниями..................................................265
      Выбор из списков..............................................265
      Работа со средствами просмотра списков........................266
      Построение средства просмотра списка..........................266
      Получение текста элемента списка..............................267
      Реакция на выбор в списке.....................................268
      Использование управляющих элементов блока списка..............269
      Построение списка строк.......................................269
      Построение блока списка.......................................270
      Присваивание списка блоку списка..............................270
      Установка и считывание значений блока списка..................271
      Вывод схемы...................................................271
      Основные моменты использования схемы..........................272
      Графическая иерархия..........................................273
      Расширение и сжатие...........................................273
      Итерация элементов............................................273
      Поведение при перемещении фокуса и выборе.....................273
      Обновление схемы..............................................273
      Использование отображаемых элементов схемы....................273
      Создание дерева схемы.........................................274
      Построение отображаемого элемента схемы.......................274
      Получение выделенного узла....................................274
      Отмена схемы..................................................274
      Считывание данных, вводимых пользователем.....................275
      Построение управляющих элементов строки ввода.................275
      Установка значений и считывание строк ввода...................275
      Манипулирование строками ввода................................276
      Использование протоколов......................................276
      Определение списков протокола.................................277
      Управление блоком протокола...................................278
      Построение отображаемого элемента протокола...................278
      Метки управляющих элементов...................................279
      Построение объектов меток.....................................279
      Выбор управляющих элементом с метками.........................280
      Назначение клавиш-сокращений..................................280
      ГЛАВА 13. Проверка допустимости данных........................281
      Три вида проверки допустимости данных.........................281
      Фильтрация ввода..............................................282
      Проверка допустимости каждого поля............................282
      Проверка допустимости полных экранов..........................282
      Проверка допустимости режимных окон...........................282
      Проверка допустимости при изменении фокуса....................283
      Проверка допустимости по запросу..............................283
      Использование механизма проверки допустимости данных..........283
      Построение объектов проверки допустимости.....................284
      Добавление к управляющим элементам............................284
      Как работает проверка допустимости............................284
      Методы объекта проверки допустимости..........................285
      Проверка допустимости данных..................................285
      Проверка полной строки........................................286

       B.Pascal 7 & Objects/TV#1    - 10 -

      Проверка допустимости нажатий клавиш..........................286
      Сообщение о недопустимых данных...............................286
      Стандартные средства проверки допустимости....................287
      Абстрактный объект проверки допустимости......................287
      Фильтрация....................................................287
      Проверка диапазона............................................288
      Проверка допустимости с просмотром............................288
      Просмотр строк................................................289
      Проверка допустимости по шаблону..............................289
      ГЛАВА 14. Палитры и выбор цветов..............................291
      Использование палитр цветов...................................291
      Что такое палитры цветов?.....................................291
      Пример простой палитры........................................292
      Получение цветов палитры......................................292
      Атрибуты цветов...............................................293
      Отображение цветов палитр.....................................293
      Простое использование отображения цветов......................294
      Алгоритм отображения..........................................297
      Переопределение цветов, заданных по умолчанию.................297
      Палитры - централизованная информация о цветах................298
      Изменение палитры цветов......................................298
      Расширение палитры............................................299
      Добавление записи палитры.....................................299
      Использование существующего цвета.............................299
      Добавление нового цвета.......................................299
      Добавление записей в палитры владельцев.......................300
      Переписывание методов Draw....................................301
      Изменение цветов пользователями...............................301
      Использование TColorDialog....................................302
      Определение цветовых групп и элементов........................302
      Выполнение диалогового окна...................................303
      Сохранение и восстановление цветов............................303
      ГЛАВА 15. Редактор и текстовые отображаемые элементы..........304
      Что такое текстовый отображаемый элемент?.....................304
      Использование терминального отображаемого элемента............304
      Построение терминального отображаемого элемента...............305
      Управление буфером............................................305
      Присваивание текстового устройства............................305
      Запись в терминальный отображаемый элемент....................306
      Использование объекта редактора...............................307
      Как работает редактор.........................................308
      Работа буфера.................................................309
      Удаление текста...............................................310
      Вставка текста................................................310
      Отмена редактирования.........................................311
      Работа с блоками..............................................312
      Использование меню Edit.......................................312
      Обновление активных команд....................................312
      Привязка клавиш редактора.....................................312
      Работа с блоками..............................................313
      Параметры редактора...........................................313
      Поиск и замена................................................314
      Использование полей примечаний................................314

       B.Pascal 7 & Objects/TV#1    - 11 -

      Цвета примечания..............................................315
      Действие по типу управляющего элемента........................315
      Обработка табуляции...........................................315
      Установка и считывание значений...............................315
      Использование редакторов файлов...............................316
      Построение редактора файлов...................................316
      Работа с файлами..............................................317
      Загрузка файла................................................317
      Сохранение файла..............................................317
      Обеспечение сохранения изменений..............................318
      Работа с буферами.............................................318
      Задание памяти для буфера.....................................318
      Обслуживание буферов редактора файла..........................319
      Использование буфера вырезанного текста.......................319
      Построение редактора буфера вырезанного текста................320
      Присваивание переменной Clipboard.............................320
      Использование окна редактора..................................320
      Построение окна редактора.....................................321
      Другие соглашения по окну редактора...........................321
      ГЛАВА 16. Наборы..............................................322
      Объекты наборов...............................................322
      Динамическая установка размеров наборов.......................322
      Полиморфизм наборов...........................................323
      Проверка типа и наборы........................................323
      Объединение в набор элементов, не являющихся объектами........323
      Создание набора...............................................324
      Методы итератора..............................................325
      Итератор ForEach..............................................326
      Итераторы FirstThat и LastThat................................326
      Отсортированные наборы........................................327
      Наборы строк..................................................329
      Пересмотренные итераторы......................................330
      Нахождение элемента...........................................331
      Полиморфические наборы........................................331
      Наборы и управление памятью...................................334
      ГЛАВА 17. Потоки..............................................335
      Вопрос: объектный ввод-вывод..................................335
      Ответ: потоки.................................................336
      Полиморфизм потоков...........................................336
      Потоки обрабатывают объекты...................................336
      Смысл использования потоков...................................337
      Установка потока..............................................337
      Чтение из потока и запись в поток.............................338
      Метод Put.....................................................338
      Метод Get.....................................................338
      Метод Error...................................................339
      Закрытие потока...............................................339
      Как сделать объекты потоковыми................................339
      Методы загрузки и записи Load и Store.........................339
      Регистрация потока............................................340
      Номера идентификаторов объектов...............................341
      Автоматические поля...........................................341
      Регистрация на месте..........................................342

       B.Pascal 7 & Objects/TV#1    - 12 -

      Регистрация стандартных объектов..............................342
      Механизм потока...............................................342
      Процесс Put...................................................342
      Процесс Get...................................................343
      Обработка указателей объектов со значением nil................343
      Наборы в потоке: полный пример................................343
      Добавление методов Store......................................344
      Записи регистрации............................................345
      Регистрация...................................................346
      Запись в поток................................................346
      Как все хранится?.............................................347
      Экземпляры отображаемых подэлементов..........................347
      Создание экземпляров братских отображаемых элементов..........348
      Копирование потока............................................349
      Потоки произвольного доступа..................................349
      Необъектные элементы потоков..................................350
      Разработка пользователем собственных потоков..................350
      Обработка ошибок потока.......................................351
      Версии потоков................................................351
      Флаги версий..................................................351
      Работа в различных версиях....................................351
      ГЛАВА 18. Ресурсы.............................................352
      Преимущества использования ресурсов...........................352
      Содержимое ресурса............................................353
      Создание ресурса..............................................353
      Чтение ресурса................................................354
      Списки строк..................................................355
      Создание списков строк........................................356

         B.Pascal 7 & Objects/TV#1    - 13 -

═════════════════════════════════════════════════════════════════════════
─────────────────────────────────────────────────────────────────────────
                                       ВВЕДЕНИЕ
        ─────────────────────────────────────────────────────────────────

             В данной книге содержится полная документация по программно-
        му продукту Turbo Vision,  представляющему собой средство  разра-
        ботки объектно-ориентированных программ. Здесь рассматриваются не
        только возможности Turbo Vision и способы  их  реализации,  но  и
        свойства,  определяющие  эти  возможности.  Потратив определенное
        время на изучение основных принципов Turbo  Vision,  вы  получите
        мощное программное средство,  которое даст большие преимущества в
        работе и позволит сэкономить массу  времени.  Разработка  сложных
        непротиворечивых интерактивных  программ займет у вас значительно
        меньше времени, чем можно было предположить.

                         Что нового появилось в Turbo Vision?
        ─────────────────────────────────────────────────────────────────

             В Turbo Vision 2.0 к иерархии объектов добавлены новые объе-
        кты,  а также добавлены новые свойства уже существующих объектов.
        Изменения существующих объектов совместимы с более ранними верси-
        ями, вследствие чего программы на Turbo Vision будут компилирова-
        ться  без  изменений,  а  потоки  и ресурсы будут загружаться без
        ошибок.

             Turbo Vision 2.0 обладает следующими новыми особенностями:

             * поддержкой проверки допустимости данных (Глава 13);

             * большим количеством встроенных функций, включая:

                - выход в DOS;
                - мозаичное и каскадное расположение окон;
                - проверку корректности в обычных и диалоговых окнах;
                - стандартные функции работы с меню;

             * кнопками с независимой фиксацией, имеющие несколько состо-
               яний;

             * новым средством просмотра объектов.

             * введением версий потоков.

             * большими размерами кластеров кнопок с зависимой и  незави-
               симой фиксацией.

             Кроме этого, настоящее руководство включает следующий допол-
        нительный материал:

             - расширенный самоучитель (учебное руководство);

             - большее количество примеров программ;

             - главы,  описывающие,  как  использовать  окна,  прикладные

         B.Pascal 7 & Objects/TV#1    - 14 -

               программы,  органы  управления и средства,  обеспечивающие
               проверку допустимости данных;

             - более полное объяснение отображаемых элементов и событий.

                             Характеристика Turbo Vision
        ─────────────────────────────────────────────────────────────────

             Turbo Vision   представляет  собой  объектно-ориентированную
        прикладную систему для разработки программ по организации многоо-
        конного режима.  Применение этого программного продукта избавляет
        вас от бесконечного  процесса  воссоздания  базовой  части  своих
        прикладных программ.

             Turbo Vision  - это полная объектно-ориентированная система,
        которая включает следующие средства:

             - множественные перекрывающиеся окна с изменяемым размером;
             - опускающиеся меню;
             - поддержка "мыши";
             - диалоговые окна;
             - встроенная настройка цвета;
             - "кнопки", полосы прокрутки, окна ввода, кнопки с зависимой
               и независимой фиксацией;
             - стандартная  обработка  нажатий  клавиш  и  манипуляций  с
               "мышью".

             Возможно, что вы ранее пользовались библиотеками процедур  и
        функций или  объектов,  и на первый взгляд Turbo Vision похожа на
        библиотеку.  В конце концов,  вы можете купить библиотеки, дающие
        возможность работать с меню,  окнами,  мышью и многим другим.  Но
        это чисто внешнее сходство:  Turbo Vision - не просто библиотека,
        это прикладная система.

             При использовании Turbo Vision никогда нет необходимости из-
        менять текст программы.  Производятся  изменения  в  самом  Turbo
        Vision путем его расширения.  В рамках APP.TPU "скелет" программы
        TApplication остается неизменным. Добавления осуществляются путем
        введения новых типов объектов, а необходимые изменения достигают-
        ся путем переопределения унаследованных методов новыми  методами,
        которые пишутся для новых объектов.

             Кроме этого,  Turbo Vision представляет собой иерархию, а не
        ящик с беспорядочно сложенными в него инструментами.  При необхо-
        димости  воспользоваться  одним  из  них нужно пользоваться сразу
        всем комплектом. За каждой частью Turbo Vision стоит видение еди-
        ной архитектуры, и все эти инструменты работают совместно взаимо-
        зависимо друг от друга. Не следует пытаться взять из системы лишь
        поддержку "мыши" и стараться использовать ее. Это извлечение пот-
        ребует больших усилий,  чем самостоятельное  написание  алгоритма
        работы с мышью "с нуля".

             Работа с  Turbo  Vision представляет собой программирование,

         B.Pascal 7 & Objects/TV#1    - 15 -

        управляемое событиями, что позволяет писать гибкие программы, да-
        ющие  пользователям возможность управлять нужной частью программы
        вместо того,  чтобы работать под диктовку программы. Такая же мо-
        дель,  управляемая событиями, используется такой современной гра-
        фической средой, как Microsoft Windows.

             Turbo Vision была создана для того,  чтобы избавить  вас  от
        огромного  количества ненужной однообразной работы,  и обеспечить
        надежной средой, на которую можно положиться при построении прог-
        рамм.  Для получения максимальной выгоды от работы с Turbo Vision
        необходимо заставить ее работать на себя.

             Turbo Vision предоставляет основу интегрированной среды, на-
        писанную  за несравненно меньшее время,  чем потребовалось бы для
        написания всей среды. Turbo Vision позволяет использовать для ва-
        ших программ ту же самую основу.

                   Как возникло программное средство Turbo Vision?
        ─────────────────────────────────────────────────────────────────

             Фирма  Borland решила представить функциональные возможности
        ряда разработанных в ней программ,  содержащих  окна,  диалоговые
        окна, меню и поддержку "мыши", в виде пакета средств, допускающе-
        го их многократное использование.  Объектно-ориентированное прог-
        раммирование дало инструмент, в результате использования которого
        появилось программное средство Turbo Vision.

             В силу того,  что Turbo Vision использует стандартизованный,
        рациональный  подход  к  структуре экрана,  программа приобретает
        привычный вид.  Этот отображаемый элемент  напоминает  вид  самих
        языков семейства Turbo и основан на многолетнем опыте использова-
        ния этих программ.  Столь привычный и понятный вид программы дает
        явные преимущества вам и вашим пользователям.  Независимо от раз-
        личий в том,  что будет делать программа, способ ее использования
        будет знакомым, и кривая обучения будет расти быстрее.

             Turbo Vision также является быстрой системой. Она была опти-
        мизирована с  использованием языков Турбо Паскаль и ассемблер,  и
        за счет "гладкой" работы и "вылизанных" текстов скорость выполне-
        ния была увеличена.

                   Что следует знать для работы с Turbo Vision
        ─────────────────────────────────────────────────────────────────

             Для работы  с  Turbo  Vision вы должны быть хорошо знакомы с
        объектно-ориентированным программированием.  При написании  прик-
        ладных программ на Turbo Vision широко используются методы объек-
        тно-ориентированного программирования и,  в частности, наследова-
        ние  и полиморфизм.  Эти вопросы подробно рассматриваются в Главе
        "Объектно-ориентированное программирование" "Руководства пользова-
        теля".

             Кроме того,  вы  должны иметь представление об использовании

         B.Pascal 7 & Objects/TV#1    - 16 -

        указателей и динамических переменных,  т.к. практически все копии
        объекта Turbo Vision динамически размещаются в области динамичес-
        ки распределяемой памяти.  Если вы не знакомы с  указателями  или
        хотите освежить в памяти вопросы работы с ними,  то следует обра-
        титься к главе "Руководства пользователя" "Использование указате-
        лей".

                         Как пользоваться данной книгой?
        ─────────────────────────────────────────────────────────────────

             Руководство программиста  Turbo  Vision  расширено для того,
        чтобы оно было более полным и удобным в  использовании.  Если  вы
        уже знакомы с Turbo Vision,  то,  возможно,  захотите просмотреть
        главы 7,  13 и 19 на предмет появившихся новшеств. Если Turbo Vi-
        sion  нова  для  вас,  то вам следует полностью прочесть Часть 1,
        "Знакомство с Turbo Vision".  Вместе с  учебным  руководством  вы
        построите  полноразмерную программу для Turbo Vision,  на примере
        которой будут объяснены принципы работы Turbo Vision и попутно  -
        принципы программирования, обусловленного событиями.

                         Что содержится в данной книге?
        ─────────────────────────────────────────────────────────────────

             Руководство содержит три части:

             - Часть 1 знакомит с основными  принципами  Turbo  Vision  и
               представляет  средства  обучения  для написания прикладных
               программ Turbo Vision.

             - Часть 2 содержит более детальную  информацию  по  основным
               элементам Turbo Vision,  включая пояснения по всем элемен-
               там иерархии объектов Turbo Vision и предложения по  улуч-
               шению  написания прикладных программ.  Часть 2 также расс-
               матривает наборы, потоки и ресурсы. Они представляют собой
               важные инструменты работы с данными,  поставляемые с Turbo
               Vision.

             - Часть 3 представляет собой полный справочник по всем  объ-
               ектам и другим элементам, содержащимся в компонентах Turbo
               Vision.




         B.Pascal 7 & Objects/TV#1    - 17 -

─────────────────────────────────────────────────────────────────────────
                       ЧАСТЬ 1. ЗНАКОМСТВО С TURBO VISION
        ─────────────────────────────────────────────────────────────────

                       ГЛАВА 1. Погружение в Turbo Vision
        ─────────────────────────────────────────────────────────────────

             На  протяжение следующих нескольких глав вы построите полно-
        масштабную  программу  для Turbo Vision начиная с пустого кадра и
        заканчивая  достаточно  сложной системой ввода данных с проверкой
        допустимости ввода и контекстными подсказками.

             Этот переход состоит из двенадцати шагов:

                  - Шаг 1: Создание программы;

                  - Шаг 2: Настройка меню и строк состояния;

                  - Шаг 3: Формирование ответа на команды;

                  - Шаг 4: Добавление окна;

                  - Шаг 5: Добавление окна системного буфера;

                  - Шаг 6: Сохранение и загрузка рабочей области;

                  - Шаг 7: Использование ресурсов;

                  - Шаг 8: Создание окна ввода данных;

                  - Шаг 9: Установка контрольных величин;

                  - Шаг 10: Проверка допустимости ввода данных;

                  - Шаг 11: Добавление наборов данных;

                  - Шаг 12: Придание стандартного вида;

             Исходный текст программы из настоящего учебного  руководства
        на разных стадиях ее разработки имеется на дистрибутивных дисках.
        Эти файлы называются TUTOR01.PAS, TUTOR02.PAS и т.д., в соответс-
        твии с порядковыми номерами шагов из учебного руководства.

             В конце  руководства будут даны некоторые предложения по то-
        му, как придать уже написанной программе еще большие возможности.

                   Элементы прикладной программы Turbo Vision
        ─────────────────────────────────────────────────────────────────

             Рассмотрим  для  начала,  какие средства предоставляет Turbo
        Vision для разработки ваших прикладных программ.

                               Наименование частей
        ─────────────────────────────────────────────────────────────────

         B.Pascal 7 & Objects/TV#1    - 18 -


             Прикладная программа Turbo Vision представляет собой взаимо-
        действующее множество отображаемых элементов, событий и "безглас-
        ных" объектов.

                              Отображаемый элемент
        ─────────────────────────────────────────────────────────────────

             Отображаемый элемент - это любой элемент программы,  изобра-
        жаемый на экране;  все такие элементы являются объектами.  В кон-
        тексте Turbo Vision отображаемый элемент - это то,  что можно ви-
        деть на экране. Поля, заголовки полей, границы окон, полосы прок-
        рутки, строки меню, окна диалога являются отображаемыми элемента-
        ми. Отображаемые элементы могут объединяться и образовывать более
        сложные элементы,  такие,  как окна и окна диалога. Такие объеди-
        ненные отображаемые элементы называются группами,  и они функцио-
        нируют вместе как единый отображаемый элемент. Они могут считать-
        ся отображаемыми элементами и концептуально.

             Отображаемые  элементы всегда имеют прямоугольную форму. Это
        могут быть и прямоугольники, содержащие один символ, или строки в
        один символ высотой или шириной.

                   Примечание: Подробная  информация об отображаемых эле-
              ментах содержится в Главе 8.

                                     События
        ─────────────────────────────────────────────────────────────────

             Событием  является  какое-либо  явление,  на  которое должна
        отреагировать  ваша прикладная программа. Событиями являются ввод
        с клавиатуры, с помощью "мыши" или из других частей Turbo Vision.
        Например,  нажатие  клавиши,  а также кнопки "мыши"- это событие.
        Очередность событий в "скелете" прикладной программы Turbo Vision
        устанавливается по мере их наступления, и затем они обрабатывают-
        ся  в  данном порядке с помощью обработчика событий. Он имеется в
        объекте  TApplication, являющимся телом вашей прикладной програм-
        мы.  С  помощью  механизма, описание которого будет дано позднее,
        события,  которые  не  были обработаны в TApplication, передаются
        другим отображаемым элементам, имеющимся в программе, пока они не
        будут  обработаны  каким-либо отображаемым элементом или не будет
        получено сообщение об ошибке "отказ от обработки события".

             Например,  нажатием клавиши F1 запускается справочная систе-
        ма. Если каждый отображаемый элемент не имеет своего собственного
        входа в справочную систему (что имеет место в системе контекстной
        помощи), то  нажатие  клавиши F1 принимается обработчиком событий
        главной программы. Обычные алфавитно-цифровые клавиши или клавиши
        редактирования строк,  наоборот,  должны обрабатываться с помощью
        отображаемого элемента,  который в настоящий момент  находится  в
        "фокусе" (активен),  т.е. отображаемого элемента, с которым поль-
        зователь работает в данный момент.


         B.Pascal 7 & Objects/TV#1    - 19 -

                   Примечание: Подробнее о событиях см. в Главе 9.

                              "Безгласные" объекты
        ─────────────────────────────────────────────────────────────────

             "Безгласными"  называются любые объекты программы, не являю-
        щиеся отображаемыми. Они называются "безгласными", т.к. непосред-
        ственно  не  взаимодействуют с экраном. Они выполняют вычисления,
        осуществляют  связь с периферийными устройствами и в целом реали-
        зуют  функции  прикладной  программы.  Если "безгласному" объекту
        потребуется  вывести какую-либо информацию на экран, это делается
        с помощью его взаимодействия с отображаемым элементом.

             Эта концепция является очень важной для поддержания строгого
        порядка  в  прикладных  программах Turbo Vision: выход на дисплей
        имеют только отображаемые элементы.

             Ничто не может, однако, помешать выполнению вывода "безглас-
        ными"  объектами  с  помощью операторов языка Турбо Паскаль Write
        или Writeln.  Но при этом,  если Вы выводите текст на дисплей са-
        мостийно,  то  это  повлечет разрушение текста,  выводимого Turbo
        Vision,  и последний текст сотрет данный нарушающий текст (напри-
        мер, с помощью перемещения или изменения размеров окон).

             На Рис.  1.1 показан ряд распространенных объектов,  которые
        могут быть частью прикладной программы Turbo Vision.  Рабочая об-
        ласть - это заштрихованный фон,  на котором появляется  остальная
        часть  прикладной  программы.  Как и все остальные элементы Turbo
        Vision,  рабочая область является  объектом.  Объектами  являются
        также строки меню в верхней части экрана и строка состояния в его
        нижней части.  Слова в строке  меню  представляют  меню,  которые
        "раскрываются"  вниз (опускающиеся меню) путем выбора "мышью" или
        нажатия клавиш активации.

                   Примечание: Подробнее об этом см.  в Главе 8, "Отобра-
              жаемые элементы".

                  ┌──────────────────────────────────────┐
                  │  Строка меню                         │
                  ├──────────────────────────────────────┤
                  │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
                  │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
                  │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
                  │░░ Рабочая область░░░░░░░░░░░░░░░░░░░░│
                  │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
                  │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
                  ├──────────────────────────────────────┤
                  │  Строка состояния                    │
                  └──────────────────────────────────────┘

             Рис. 1.1. Расположение объектов Turbo Vision на экране.

             Текст, который появляется в строке состояния, задается вами,

         B.Pascal 7 & Objects/TV#1    - 20 -

        но  обычно там выдаются сообщения о текущем состоянии вашей прик-
        ладной программы,   показываются  доступные  клавиши  активизации
        (оперативные клавиши) или подсказки  команд,  которые  имеются  в
        распоряжении пользователей в данный момент.

             Когда меню опускается вниз, то выделенная строка перемещает-
        ся  вверх  и вниз по элементам меню в соответствии с перемещением
        "мыши"  или  курсора.  Когда вы нажимаете клавишу Enter или левую
        кнопку "мыши", то выполняется выбор элемента, который был выделен
        во время нажатия кнопки. При выборе элемента (пункта) меню произ-
        водится  передача управления соответствующей части вашей програм-
        мы.

             Связь вашей программы с пользователями обычно осуществляется
        через окно или несколько окон или окна диалога, которые появляют-
        ся в рабочей области на экране и исчезают в соответствии с коман-
        дами, поступающими с "мыши" или с клавиатуры. Turbo Vision распо-
        лагает  большим  набором  алгоритмов  работы  с окнами по вводу и
        изображению  информации  на  экране.  Внутренние  поля окон можно
        сделать  прокручиваемыми,  и  тогда  они будут служить воротами в
        более  крупные  изображения  данных, такие, как файлы документов.
        Прокрутка  окна по данным выполняется перемещением в полосе прок-
        рутки  по  нижней  части экрана, правой части экрана или по обеим
        этим  частям. Полоса прокрутки указывает положение окна относите-
        льно совокупности изображаемых на экране данных.

                            Шаг 1: Создание программы
        ─────────────────────────────────────────────────────────────────

             Традиционным  способом демонстрации применения любого нового
        языка или пакета, реализующего интерфейс с пользователем, являет-
        ся  представление  программы  "Hello, World" ("Здравствуй, мир"),
        написанной с помощью рассматриваемых средств. Эта программа обыч-
        но  включает  лишь элемент, достаточный для изображения на экране
        строки  "Hello,  World" ("Здравствуй, мир") и возврата управления
        DOS. На этом шаге вы сделаете следующее:

             - создадите минимально возможную программу для Turbo Vision;

             - разовьете базовую программу.

                         Построение простейшей программы
        ─────────────────────────────────────────────────────────────────

             Объект  прикладной  программы  дает  кадр,  на базе которого
        осуществляется  построение  реальной  программы. Тогда простейшая
        программа для Turbo Vision является просто копией базового объек-
        та программы, TApplication. Следующий текст показывает простейшую
        программу для Turbo Vision.

             program Minimal;

             uses App;

         B.Pascal 7 & Objects/TV#1    - 21 -

             var
               MyApp: TApplication;


             begin
               MyApp.Init;
               MyApp.Run;
               MyApp.Done;
             end.

             В объектно-ориентированном мире Turbo Vision даже ваша прог-
        рамма является объектом.  Позже вы увидите, что этот объект явля-
        ется одновременно и отображаемым элементом и группой. Определение
        основного  объекта программы содержится в модуле с названием App.
        Хотя эта программа использует непосредственно  лишь  модуль  App,
        она сама  по  себе  использует  несколько  других  модулей  Turbo
        Vision. Если вы будете дополнять эту программу, то будете исполь-
        зовать части всех этих модулей.

             При запуске этой программы очищается экран и создается рабо-
        чая  область, как показано на Рис. 1.2. Заметьте, что поле меню в
        верхней  части  экрана пусто, а в строке состояния в нижней части
        экрана  находится сообщение о доступности клавиши активации Alt-X
        для выхода из программы, а поле между ними затемнено.

                  ┌──────────────────────────────────────┐
                  │█████████████████████████████████████ │
                  ├──────────────────────────────────────┤
                  │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
                  │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
                  │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
                  │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
                  ├──────────────────────────────────────┤
                  │██Alt-X█Exit██████████████████████████│
                  └──────────────────────────────────────┘

             Рис. 1.2. Экран программы по умолчанию.

             Программа  Minimal  демонстрирует  существующее по умолчанию
        действие  объекта  TApplication. На самом деле TApplication может
        делать  гораздо  больше, чем просто отвечать на нажатие Alt+X или
        перещелкивание  кнопкой  мыши  над  строкой состояния. То, что вы
        видите на экране, представляет собой пустой кадр прикладной прог-
        раммы.  По мере того, как вы будете наращивать программу дополни-
        тельными возможностями, вы обнаружите, что этот заданный по умол-
        чанию  кадр уже обладает встроенными функциями для работы с боль-
        шинством из них.

                          Расширение объекта программы
        ─────────────────────────────────────────────────────────────────

             На  остальных стадиях настоящего самоучителя к объекту прог-

         B.Pascal 7 & Objects/TV#1    - 22 -

        раммы  вами будут добавлены новые возможности. Если вы не знакомы
        с  использованием  библиотек  объектов,  то у вас может появиться
        искушение  открыть файл APP.PAS и непосредственно изменить исход-
        ный  текст TApplication. Следует избегать этого искушения по сле-
        дующим причинам:

             * Целью прикладной среды программы является  создание  стан-
               дартного, надежного основания всей вашей программы. В слу-
               чае изменения этого основания для каждой программы вы  на-
               несете  удар по этому огромному преимуществу использования
               прикладной среды.

             * Изменение проверенного исходного текста представляет собой
               надежный путь внести подводные камни, на которые вы обяза-
               тельно нарветесь.  Объекты  Turbo  Vision  взаимодействуют
               друг с другом множеством взаимосвязанных способов,  и поэ-
               тому изменение одного из стандартных объектов  может  неп-
               редвиденно  сказаться  в  казалось  бы не связанных с этим
               местах.

             Одним из главных преимуществ объектно-ориентированного прог-
        раммирования является расширяемость.  Вместо переписывания исход-
        ного  текста  программы можно ввести новый тип объекта вместо су-
        ществующего,  и в результате этого вам придется  писать  исходный
        текст  только  для  отличающихся частей.  Только в этом случае вы
        сохраните твердое, надежное основание программы, и все ваши наст-
        ройки окажутся в удобных местах.

             Первым делом надо определить объект новой программы, в кото-
        рый будут вноситься изменения, как это показано в следующем текс-
        те:

             program Tutor01;

             uses App;                 { APP содержит объекты программы }

             type
               TTutorApp = object (TApplication);
                                           { определение типа программы }
               end;  { это оставляет возможность дальнейшего расширения }

             var TutorApp: TTutorApp;    { объявление копии нового типа }


             begin
               TutorApp.Init;
               TutorApp.Run;
               TutorApp.Done;
             end.

                   Примечание: См пример программы TUTOR01.PAS.

         B.Pascal 7 & Objects/TV#1    - 23 -


             Обычно  новый  тип  объекта  не  объявляется без определения
        полей или методов, однако они будут внесены в TTutorApp на после-
        дующих стадиях программирования. Tutor01 ведет себя точно так же,
        как  Minimal, поскольку пока что TTutorApp в точности совпадает с
        типом объекта-предка TApplication.

                 Создание командной части (программной единицы)
        ─────────────────────────────────────────────────────────────────

             Один из способов проверки гибкости и расширяемости программы
        для Turbo Vision - убедиться в том, что команды доступны ей в лю-
        бом ее месте.  Команды Turbo Vision являются целыми  константами.
        Простейший способ работы с ними заключается в создании отдельного
        модуля, содержащего лишь определения констант. В следующем исход-
        ном тексте показана часть модуля,  содержащего  определения  всех
        командных констант для Tutorial.

             Пока  не  стоит  придавать  этим  константам слишком большое
        значение. Главное - сделать их доступными.  Они будут активно ис-
        пользоваться на нескольких последующих стадиях разработки,  и  вы
        увидите удобство расположения их в одном месте.

             unit TutConst;
             { глобальные константы для программы Turbo Vision Tutorial }

             interface

             const
                cmOrderNew = 251;
                cmOrderWin = 252;
                cmOrderSave = 253;
                cmOrderCancel = 254;
                cmOrderNext = 255;
                cmOrderPrev = 250;
                cmClipShow = 260;
                cmAbout = 270;
                cmFindOrderWindow = 2000;

             const
                cmOptionsVideo = 1502;
                cmOptionsSave = 1503;
                cmOptionsLoad = 1504;

             implementation
             end.

             Хранение констант в отдельном модуле имеет несколько преиму-
        ществ. Использование такого модуля для централизованного хранения
        всех  констант  позволяет избежать их повторного определения. Оно
        также  несколько  ускоряет процесс компиляции, поскольку этот мо-
        дуль редко перекомпилируется.


         B.Pascal 7 & Objects/TV#1    - 24 -

                     Шаг 2: Настройка меню и строк состояния
        ─────────────────────────────────────────────────────────────────

             Объекты программы Turbo Vision разделяют экран на три основ-
        ных  части:  рабочую  область, полосу меню и строку состояния. На
        этом шаге вы узнаете понемногу о каждой из них, а затем вы узнае-
        те, как делать следующее:

             - настраивать строку состояния;

             - настраивать полосу меню.

             Вам редко представляется возможность изменять объект рабочей
        области, и с этой возможностью вы познакомитесь на Шаге 4.

                             Инициализация программы
        ─────────────────────────────────────────────────────────────────

             При  инициализации  объекта  программы для задания объектов,
        работающих с рабочей областью, меню и строкой состояния, констру-
        ктор  Init вызывает три виртуальных метода с именами InitDesktop,
        InitMenuBar  и  InitStatusLine.  Это означает, что можно изменять
        любой  из  этих  трех  объектов,  не изменяя при этом конструктор
        программы.  При  этом  вы просто заменяете метод, устанавливающий
        конкретный  объект. Необходимость изменять объект рабочей области
        возникает редко, поскольку его работа достаточно прямолинейна. Но
        вы почти всегда будете настраивать полосу меню и строку состояния
        программы.

                   Примечание. На  Шаге  3  вы  самостоятельно  расширите
              Init,  но вы будете производить надстройку над существующим
              методом, а не воспроизводить все его действия.

                           Настройка строки состояния
        ─────────────────────────────────────────────────────────────────

             Виртуальный метод объекта программы InitStatusLine инициали-
        зирует объект строки состояния и присваивает его глобальной пере-
        менной StatusLine.  При создании настроенной строки состояния для
        конструирования нового объекта строки  состояния  и  присваивания
        его StatusLine необходимо переопределить InitStatusLine.

             Конструирование объекта строки состояния производится в  три
        этапа:

             - установка границ строки состояния;

             - определение диапазонов контекстов подсказки;

             - определение клавиш состояния.

             Необходимо  убедиться  в  том, что в раздел объявления типов
        TTuturApp добавлено объявление InitStatusLine.

         B.Pascal 7 & Objects/TV#1    - 25 -


                                Установка границ
        ─────────────────────────────────────────────────────────────────

             Обычно  строка  состояния  расположена в нижней части экрана
        программы.  Необходимость располагать ее в другом месте возникает
        редко.  Программа,  заданная  по  умолчанию, предполагает, что ее
        последняя строка - это строка состояния,  поэтому при перемещении
        строки состояния в другое место необходимо проверить,  чтобы  над
        последней строкой  экрана  расположился какой-либо другой объект,
        такой, как рабочая область.

             Поскольку  границы  строки состояния зависят от границ самой
        программы,  которые  в  свою  очередь изменяются в зависимости от
        видео  режима, InitStatusLine должен запросить объект программы о
        его  границах,  и  в  соответствии  с ними установить собственные
        границы.

             Так как все отображаемые элементы Turbo Vision прямоугольны,
        они хранят границы в прямоугольном объекте типа TRect. TRect име-
        ет два поля,  A и B,  представляющие собой левый верхний и правый
        нижний углы отображаемого элемента. В свою очередь A и B являются
        точечными объектами,  представляющими координаты столбца и строки
        точки.

             Отображаемые  элементы имеют метод GetExtent, возвращающий в
        его  единственном  параметре  var  ограничивающий  прямоугольник.
        InitStatusLine  вызывает  GetExtent  программы,  а затем изменяет
        возвращенный прямоугольник:

             type
               TTutorApp = object (TApplication)
               procedure InitStatusLine; virtual;
                                                {объявляется новый метод}
               end;

               procedure TTutorApp.InitStatusLine;
               var R: TRect;
               begin
                  GetExtent (R);         { получение границ программы }
                  R.A.Y := R.B.Y - 1;
                        { установка верхней точки на одну выше нижней }
                   .
                   .
                   .


                   Определение диапазонов контекстов подсказки
        ─────────────────────────────────────────────────────────────────

             Каждый  отображаемый  элемент  имеет поле объекта типа Word,
        содержащее  его контекст подсказки. Контексты подсказки выполняют
        две  основные  функции.  Они хранят число, используемое системами

         B.Pascal 7 & Objects/TV#1    - 26 -

        контекстной  подсказки,  для  определения  отображаемого на экран
        кадра  подсказки, и определяют, какая строка состояния выдается в
        нижней части экрана.

                   Примечание. Полная информация  о  контексте  подсказки
              содержится в Главе 10, "Объекты прикладной программы".

             Объект  строки  состояния  содержит связанный набор записей,
        называемых  определениями состояния. Определение состояния содер-
        жит диапазон  контекстов подсказки и список элементов строки сос-
        тояния или клавиш состояния,  которые отображаются при  попадании
        контекста  подсказки программы в указанный диапазон.  Определение
        состояния задается путем вызова функции NewStatusDef.

             Присвоенный  StatusLine по умолчанию объект строки состояния
        определяет  единственное определение состояния с диапазоном, пок-
        рывающим все возможные контексты подсказки так, что независимо от
        текущего  контекста  подсказки  отображается  одна и та же строка
        состояния:

             New (StatusLine, Init (R,
                                 { используются границы, переданные в R }
                  NewStatusDef (0, $FFFF,
                     { покрывает контекст подсказки в диапазоне 0..FFFF }
                    StdStatusKeys (nil),
                               { включает стандартные клавиши состояния }
                  nil)));           { отсутствие дальнейших определений }


             Для своей программы вам требуются два определения состояния:
        для большинства контекстов подсказки - одно для большинства  кон-
        текстов подсказки,  а другое - специальное,  для контекстов подс-
        казки с адресами $F000 и выше.  В Шаге 7 вы создадите специальное
        окно ввода данных, устанавливающее контекст подсказки на значения
        выше $F000. Создание второго определения состояния - это лишь еще
        один вложенный вызов функции NewStatus- Def:

             procedure TTutorApp.InitStatusLine;
             var R:  TRect;
             begin
                  GetExtent (R);
                  R.A.Y. := R.B.Y - 1;
                  New (StatusLine, Init (R,
                    NewStatusDef (0, $EFFF,
                            { обратите внимание на различие в диапазоне }
                      StdStatusKeys (nil),
                    NewStatusDef ($F000, $FFFF,
                                     { охватывает диапазон $F000..$FFFF }
                      StdStatusKeys (nil),
                                         { пока те же клавиши состояния }
                    nil))));                          { еще одна скобка }
             end;


         B.Pascal 7 & Objects/TV#1    - 27 -

             Теперь  мы имеем два определения состояния, охватывающие два
        диапазона  контекстов подсказки, но оба они отображают один и тот
        же набор  элементов.  В следующем разделе вы определите настройку
        элемента строки состояния для каждого диапазона.

                          Определение клавиш состояния
        ─────────────────────────────────────────────────────────────────

             С каждым  определением состояния связан его собственный спи-
        сок клавиш состояния,  являющихся элементами, которые вы видите в
        строке  состояния  (хотя  позже вы увидите,  что можно определять
        клавиши состояния без текста).  Каждая клавиша состояния  состоит
        из четырех элементов:

             - текстовой строки, появляющейся в строке состояния;

             - кода опроса клавиатуры для клавиши активизации;

             - команды;

             - указателя на следующую клавишу состояния.

             Короче говоря, текст строки состояния определяет то, что по-
        является в строке состояния.  Любой текст в тильдах (~) изобража-
        ется выделенным.  Пустая текстовая строка означает, что текст во-
        обще не появляется на экране,  но привязывает к  команде  клавишу
        активации.

             Клавишей активации  может  быть любая "специальная" клавиша,
        такая,  как функциональные клавиши,  комбинация клавиши с Alt или
        Ctrl.  Модуль Turbo Vision Drivers определяет мнемонические конс-
        танты, соответствующие всем распространенным комбинациям клавиш.

             Все,  что  вам  необходимо  знать  о командах Turbo Vision в
        настоящий момент, это то, что они являются целочисленными конста-
        нтами.  Turbo  Vision определяет некоторые стандартные команды, и
        вы  также  можете определять свои собственные. Описание команды в
        объявлении клавиши состояния связывает команду с клавишей актива-
        ции и элементом строки состояния.  Щелчок "мышью" на клавише сос-
        тояния или нажатие клавиши активизации вызывает выполнение коман-
        ды.

                   Примечание: Вы  будете интенсивно использовать команды
              на Шаге 3.

             В следующем примере показана функция StdStatusKey, возвраща-
        ющая клавиши состояния, определенные по умолчанию.

             function StdStatusKeys (Next: PStatusItem) : PStatusItem;
             begin
               NewStatusKey :=
                  NewStatusKey ('', kbAltX, cmQuit,
                                                 { связь Alt+X c cmQuit }

         B.Pascal 7 & Objects/TV#1    - 28 -

                  NewStatusKey ('', kbF10, cmMenu,
                                                 { эти клавиши невидимы }
                  NewStatusKey ('', kbAltF3, cmClose, { но связаны с }
                  NewStatusKey ('', kbF5, cmZoom, { клавишами активации }
                  NewStatusKey ('', kbCtrlF5, cmResize,
                  NewStatusKey ('', kbF6, cmNext,
                  Next ))))));
                           { добавляет любые клавиши, переданные в Next }
             end;

             Элементы, показанные в строке состояния для каждого  опреде-
        ления состояния,  составляют связанный перечень клавиш состояния,
        созданный вложенными вызовами  функции  NewStatusKey.  В  сложных
        описаниях строки состояния все эти вложенные вызовы функции могут
        перемешаться. Одним из способов упрощения исходного текста в этом
        случае  является  определение  функций,  возвращающих определения
        состояния или перечни клавиш состояния, что особенно эффективно в
        случаях, когда в множественных определениях состояния имеются об-
        щие элементы.

             В приведенном ниже примере показана  расширенная  программа,
        включающая объявления нескольких новых клавиш состояния.

             program Tutor02a;

             uses App, Objects, Menus, Drivers, Views, TutConst;

             type
               TTutorApp = object (TApplication);
                  procedure InitStatusLine; virtual;
                                                { объявляет новый метод }
               end;
             procedure TTutorApp.InitStatusLine;
             var R: TRect;

             begin
               GetExtent (R);
               R.A.Y := R.B.Y - 1;
               New (StatusLine, Init (R,
               NewStatusDef (0, $EFFF,         { "нормальный" диапазон }
                       NewStatusKey ('~F3~Open', kbF3, cmOpen,
                                                          { связь с F3 }
                       NewStatusKey ('~F4~New', kbF4, cmNew,
                                                          { связь с F4 }
                       NewStatusKey ('~Alt+F3~Close', kbAltF3, cmClose,
                                                      { связь с Alt+F3 }
                       StdStatusKeys (nil)))),
                                       { добавляет стандартные клавиши }
                    NewStatusDef ($F000, $FFFF,      { другой диапазон }
                       NewStatusKey ('~Shift+F6~Next', kbF6, cmOrderNext,
                       NewStatusKey ('~Shift+F6~Prev', kbShiftF6,
                                                          cmOrderPrev,
                       StdStatusKeys (nil))),nil))));

         B.Pascal 7 & Objects/TV#1    - 29 -

                    nil)                   { более определений нет }
                     ));           { закрывающие скобки для New и Init }
             end;

             var TutorApp: TTutorApp;

             begin
               TutorApp.Init;
               TutorApp.Run;
               TutorApp.Done;
             end.

             Если вы запустите программу прямо сейчас,  то  увидите,  что
        она выглядит как и раньше, с той лишь разницей, что теперь появи-
        лись дополнительные клавиши состояния.  Пункт Alt+F3,  однако, не
        выделен, и программа не реагирует на мышь, поскольку по умолчанию
        команда cmClose, которую вы связали с Alt+F3, отключена.

             Turbo Vision автоматически отключает пункты (элементы), свя-
        занные с отключенными командами.  Как только будет открыто  окно,
        Turbo Vision откроет cmClose и пункт строки состояния Alt+F3.

                              Настройка полосы меню
        ─────────────────────────────────────────────────────────────────

             Точно так же, как метод программы InitStatusLine инициализи-
        рует  строку  состояния,  InitMenuBar  конструирует полосу меню и
        присваивает ее глобальной переменной MenuBar.  При создании  меню
        программы необходимо переопределить InitMenuBar.

             Так же, как и строка состояния, полоса меню делается из свя-
        занного перечня пунктов.  Пункты меню могут быть  либо  командами
        меню,  либо  связями  с опускающимися меню (называемыми подменю).
        Определенная по умолчанию программа не содержит никаких пунктов в
        полосе меню, поэтому для создания осмысленного меню его надо соз-
        давать полностью.

             Создание полосы меню производится в три этапа:

             - установка границ полосы меню;

             - определение пунктов меню;

             - определение подменю;

             Выполнив  эти  три шага, вы увидите, как при помощи функций,
        возвращающих  пункты  меню  и  подменю, можно скруглить некоторые
        острые углы.

                                Установка границ
        ─────────────────────────────────────────────────────────────────

             Как  и  строка состояния, полоса меню требует установки гра-

         B.Pascal 7 & Objects/TV#1    - 30 -

        ниц, зависящих от границ самой программы. Но вместо нижней строки
        экрана  меню  занимает  его верхнюю строку. И здесь самым простым
        способом  сделать  это  является метод GetExtent для отображаемых
        элементов:

               procedure TTutorApp.InitMenuBar;
               var R: TRect;
               begin
                  GetExtent (R);
                  R.A.Y := R.B.Y + 1;
                  New (MenuBar, Init (R,...));
                   .
                   .
                   .

                            Определение пунктов меню
        ─────────────────────────────────────────────────────────────────

             В  своей  простейшей  форме  полоса меню выглядит и работает
        почти так же, как строка состояния: горизонтальный набор пунктов,
        которые  пользователь может выбрать при помощи мыши. В отличие от
        строки  состояния,  однако,  полоса  меню  не является контекстно
        зависимой.  Полоса  меню  остается  неизменной,  если программа в
        явном виде не изменяет или не заменяет ее.

             Каждый пункт меню состоит из шести частей:

             - текстовой метки, описывающей команду меню;

             - другой текстовой метки, описывающей оперативные клавиши;

             - кода опроса клавиатуры для оперативной клавиши;

             - команды;

             - справочного контекста;

             - указателя на следующий элемент.

             Однако, когда элемент меню выводится непосредственно в стро-
        ке меню,  описание оперативной клавиши не выводится, но оператив-
        ная клавиша тем не менее работает.  Справочный контекст полезен в
        том случае,  если  вы  хотите  предусмотреть контекстно-зависимые
        описания элементов меню. Линии между элементами меню в полосе ме-
        ню не выводятся, хотя они показываются в вертикальных меню.

             В приведенном ниже примере показан метод InitMenuBar,  кото-
        рый описывает строку меню с элементами для открытия и  сохранения
        файлов:

             procedure TTutorApp.InitMenuBar;
             var R: TRect;


         B.Pascal 7 & Objects/TV#1    - 31 -

             begin
               GetExtent(R);
               R.B.Y := R.A.Y + 1;
               MenuBar := New(PMenuBar, Init(R, NewMenu(

                  NewItem('~N~ew', '', kbNoKey, cmNew, hcNew,
                  NewItem('~O~pen...', F3'', kbF3, cmOpen, hcOpen,
                  NewItem('~S~ave', 'F3', kbF3, cmSave, hcSave,
                  NewItem('Save ~a~s...', '', kbNoKey, cmSaveAs, hcSaveAs,
                  NewLine(
                  NewItem('~E~xit', 'Alt-X', kbAltX, cmQuit, hcExit,
                  nil)))))))));

             end;

                   Примечание: См. пример TUTOR02B.PAS.

                   Примечание: Константы  Turbo Vision,  включая hcXXXX и
              kbXXX, описаны в Главе 19 "Справочник по Turbo Vision".

             Как и в случае созданной вами строки состояния, единственным
        элементом, приводящим к какому-то действию, является пункт Alt-X,
        который завершает прикладную программу.  Другие пункты генерируют
        команды, реакция не которые еще не определена.

             Пункты меню в полосе меню довольно ограничены, поэтому таким
        образом они используются достаточно  редко.  Обычно  пункты  меню
        группируются в  подменю  - вертикальные блоки меню,  выводимые из
        других пунктов меню.

                               Определение подменю
        ─────────────────────────────────────────────────────────────────

             Элементы, создающие  подменю,  не  имеют оперативных клавиш,
        поэтому у них не так много параметров,  как у  других  элементов.
        Они воспринимают следующие параметры:

             - текстовую метку для подменю;

             - справочный контекст;

             - указатель на первый элемент в списке подменю;

             - указатель на следующий элемент или следующее подменю.

             Чтобы создать  простую  полосу меню с одним подменю с именем
        'File', которое содержит единственный элемент 'Open', можно пере-
        определить InitMenuBar следующим образом:

             procedure TTutorApp.InitMenuBar;
             var R: TRect;

             begin

         B.Pascal 7 & Objects/TV#1    - 32 -

               GetExtent(R);
               R.B.Y := R.A.Y + 1;
               MenuBar := New(PMenuBar, Init(R, NewMenu(
                                                 { создание полосы меню }
                  NewItem('~F~ile', '', hcNoContext, NewNemu(
                                                     { определение меню }
                  NewItem('~O~pen...', F3'', kbF3, cmOpen, hcOpen,
                                                              { элемент }
                  nil)),                         { больше нет элементов }
                  nil)                             { больше нет подменю }
                  )));                              { конец полосы меню }
             end;

                              ▒▒ File ▒▒▒▒▒▒▒▒▒▒▒▒▒
                               ┌────────────────┐░░
                               │░░Open F3░░░░░░░│▒░
                               └────────────────┘▒░
                              ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░
                              ░░░░░░░░░░░░░░░░░░░░░

             Для того,  чтобы  добавить второй элемент в меню 'File',  вы
        должны заменить nil в последнем  передаваемом  NewItem  параметре
        другим вызовом NewItem:

                              ▒▒ File ▒▒▒▒▒▒▒▒▒▒▒▒▒
                               ┌────────────────┐░░
                               │░░Open F3░░░░░░░│▒░
                               │  New  F4       │▒░
                               └────────────────┘▒░
                              ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░
                              ░░░░░░░░░░░░░░░░░░░░░

             MenuBar := New(PMenuBar, Init(R, NewMenu(
               NewSubMenu('~F~ile', hcNoContext, NewMenu(
                 NewItem('~O~pen', 'F3', kbF3, cmFileOpen, hcNoContext,
                 NewItem('~N~ew', 'F4', kbF4, cmNewWin, hcNoContext,
                 nil))),
               nil)
             )));

             Для того,  чтобы  добавить к строке меню второе подменю,  вы
        должны вложить в вызов NewSubMenu вызов другой функции NewSubMenu
        следующим образом:

                           ▒▒ File   Window▒▒▒▒▒▒▒▒▒▒▒
                           ░░░░░░░░┌───────────────┐░░
                           ░░░░░░░░│░░Next F6░░░░░░│▒░
                           ░░░░░░░░│  Zoom F5      │▒░
                           ░░░░░░░░└───────────────┘▒░
                           ░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░
                           ░░░░░░░░░░░░░░░░░░░░░░░░░░░

             MenuBar := New(PMenuBar, Init(hcNoContext, NewMenu(

         B.Pascal 7 & Objects/TV#1    - 33 -

               NewSubMenu('~F~ile', hcNoContext, NewMenu(
                 NewItem('~O~pen', 'F3', kbF3, cmFileOpen, hcNoContext,
                 NewItem('~N~ew', 'F4', kbF4, cmNewWin, hcNoContext,
                 nil))),           { закрывающая скобка для выбора меню }
               NewSubMenu('~W~indow', hcNoContext, NewMenu(
                 NewItem('~N~ext', 'F6', kbF6, cmNext, hcNoContext,
                 NewItem('~Z~oom', 'F5', kbF5, cmZoom, hcNoContext,
                 nil)),            { закрывающая скобка для выбора меню }
               nil)))                     { закрывающая скобка для меню }
             )));

             Чтобы поместить  горизонтальную линию между элементами меню,
        следует вставить вызов функции  NewLine  между  вызовами  функции
        NewItem следующим образом:

                              ▒▒ File  Window▒▒▒▒▒▒
                               ┌────────────────┐░░
                               │░░Open F3░░░░░░░│▒░
                               │  New  F4       │▒░
                               ├────────────────┤▒░
                               │  Exit  Alt-X   │▒░
                               └────────────────┘▒░
                              ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░
                              ░░░░░░░░░░░░░░░░░░░░░

            MenuBar := New(PMenuBar, Init(hcNoContext, NewMenu(
              NewSubMenu('~F~ile', hcNoContext, NewMenu(
                NewItem('~O~pen', 'F3', kbF3, cmFileOpen, hcNoContext,
                NewItem('~N~ew', 'F4', kbF4, cmNewWin, hcNoContext,
                NewLine(
                NewItem('E~x~it', 'Alt-X', kbAltX, cmNewWin, hcNoContext,
                         nil))))),
              NewSubMenu('~W~indow', hcNoContext, NewMenu(
                NewItem('~N~ext', 'F6', kbF6, cmNext, hcNoContext,
                NewItem('~Z~oom', 'F5', kbF5, cmZoom, hcNoContext,
                         nil))),
                nil))
            )));

                   Использование функций для возврата из меню
        ─────────────────────────────────────────────────────────────────

             Описания меню могут быть достаточно сложными,  особенно если
        у вас  есть меню со многими вложенными подменю.  Один из способов
        обойти эту сложность состоит в  использовании  связанных  списков
        элементов меню.  Turbo  Vision  предусматривает в модуле App нес-
        колько таких функций.  Например,  функция StdWindowMenuItem возв-
        ращает указатель на список стандартных элементов меню окна:

             function StdWindowMenuItems(Next: PMenuItem): PMenuItem;
             begin
               StdWindowMenuItem :=
                    NewItem('~T~ile, '', kbNoKey, cmTile, hcTile,

         B.Pascal 7 & Objects/TV#1    - 34 -

                    NewItem('~C~ascade, '', kbNoKey, cmCascade,
                             hcCascade,
                    NewItem('~C~lose all, '', kbNoKey, cmCloseAll,
                             hcCloseAll,
                    NewLine(
                    NewItem('~S~ize/Move, 'Ctrl+F5', kbCtrlF5,
                             cmResize, hcResize,
                    NewItem('~Z~oom, 'F5', kbF5, cmZoom, hcZoom,
                    NewItem('~N~ext', 'F6', kbF6, cmNext, hcNext,
                    NewItem('~P~revious, 'Shift+F5', kbShiftF6,
                             cmPrev, hcPrev,
                    NewItem('~C~lose', 'Alt+F3', kbAltF3,
                             cmClose, hcClose,
                    Next)))))))));
             end;

                   Примечание: App определяет также стандартные меню File
              и Edit.

             Хотя в программе Tutorial  используется  достаточно  сложная
        полоса меню,  ее описание будет намного менее сложно, так как ос-
        новывается  на  стандартных  функциях   меню:   StdFileMenuItems,
        StdEditMenuItems и StdWindowMenuItems:

             procedure TTutorApp.InitMenuBar;
             var R: TRect;
             begin
               GetExtent(R);
               R.B.Y := R.A.Y + 1;
               MenuBar := New(PMenuBar, Init(R, NewMenu(
               NewSubMenu('~P~file', hcNoContext, NewMenu(
                 StdFileMenuItem(nil)),
               NewSubMenu('~E~dit', hcNoContext, NewMenu(
                 StdEditMenuItem(
                 NewLine(
                 NewItem('~S~how clipboard', '', kbNoKey, cmClipShow,
                          hcNoContext, nil)))),
               NewSubMenu('~O~rders', hcNoContext, NewMenu(
                 NewItem('~N~ew', 'F9', kbF9, cmOrderNew, hcNoContext,
                 NewLine(
                 NewItem('~N~ext', 'PgDn', kbPgDn, cmOrderNext,
                          hcNoContext, nil)))))),
               NewSubMenu('~O~ptions', hcNoContext, NewMenu(
                 NewItem('~T~oggle video', '', kbNoKey, cmOptionsVideo,
                          hcNoContext,
                 NewItem('~S~ave Desktop', '', kbNoKey, cmOptionsSave,
                          hcNoContext,
                 NewItem('~L~oad desktop', '', kbNoKey, cmOptionsLoad,
                          hcNoContext, nil)))),
               NewSubMenu('~W~indow', hcNoContext, NewMenu(
                 NewItem('~O~rders', '', kbNoKey, cmOrderWin,
                          hcNoContext,
                 NewItem('~S~uppliers', '', kbNoKey, cmStockWin,

         B.Pascal 7 & Objects/TV#1    - 35 -

                          hcNoContext,
                 NewLine(
                 StdWindowMenuItems(nil)))))),
               NewSubMenu('~H~elp', hcNoContext, NewMenu(
                 NewItem('~A~bout...', '', kbNoKey, cmAbout,
                          hcNoContext, nil)), nil)))))))));
             end;

                   Примечание: Этот исходный код вы можете найти в приме-
              ре TUTOR02C.PAS.

                                 Подведем итоги
        ─────────────────────────────────────────────────────────────────

             Вы пока можете не ощущать объема проделанной работы. Хотя вы
        определили ряд команд и задали  способы  генерации  команд  через
        пункты меню и клавиши состояния, большинство команд пока запреще-
        ны и ничего не делают. Разочаровываться не стоит. Вы и так сдела-
        ли очень много.

                       Отделение событий от реакции на них
        ─────────────────────────────────────────────────────────────────

             В традиционном программировании,  не управляемом  событиями,
        если вы  хотите  ответить на определяемые команды,  то нужно вер-
        нуться назад к написанному коду и указать, какую процедуру следу-
        ет вызывать  при выборе пользователем каждого пункта меню.  То же
        самое нужно сделать для клавиш состояния. Но в Turbo Vision этого
        не  требуется.  Каждый  из этих пунктов меню и оперативных клавиш
        генерируют команду.  Вам нужно просто написать несколько подпрог-
        рамм, реагирующих на эти команду, не затрагивая при этом исходный
        код меню или строки состояния.

             Прикладная среда Turbo Vision поднимает вас на новую ступень
        по сравнению с традиционным модульным программированием.  Ваш ис-
        ходный код не только будет представлять собой функциональные пов-
        торно используемые  блоки,  но эти блоки будут более независимы и
        взаимозаменяемы.

                   Примечание: О программировании, управляемом событиями,
              рассказывается в Главе 9.

                             Гибкое программирование
        ─────────────────────────────────────────────────────────────────

             Теперь программа Tutorial имеет три способа генерации коман-
        ды cmNewWin: клавиша состояния, пункт меню и оперативная клавиша.
        На следующем шаге вы увидите,  как легко сделать так, чтобы прог-
        рамма открывала по этой команде окно.  Но важнее всего, что прик-
        ладной программе не важно, как генерируется команда или окно.

         B.Pascal 7 & Objects/TV#1    - 36 -


             Если вы позднее решите изменить привязку команды  (например,
        переопределить  выбор  в меню или назначение оперативных клавиш),
        вам не нужно будет думать о том, как это повлияет на определяющий
        реакцию код. Это основное преимущество программирования, управля-
        емого событиями.  Ваш интерфейс с пользователем отделен от работы
        программы,  что позволяет различным частям программы функциониро-
        вать независимо.



         B.Pascal 7 & Objects/TV#1    - 37 -

─────────────────────────────────────────────────────────────────────────
                           ГЛАВА 2. Реакция на команды
        ─────────────────────────────────────────────────────────────────

             Теперь, когда ваша программа генерирует команды,  вы  можете
        добавить в  нее возможность реакции на эти команды.  В этой главе
        рассказывается о том,  как работают команды,  а затем в программу
        Tutorial добавляются возможности:

             - изменения видеорежима;

             - вывода информационного окна "About";

             - разрешения и запрещения команд.

                               Что такое команды?
        ─────────────────────────────────────────────────────────────────

             На последнем этапе вы задали способы генерации  в  программе
        Tutorial команд,  но мы только слегка коснулись того, что реально
        представляют собой команды.  О командах вам предстоит узнать нам-
        ного больше,  а  затем вы напишите некоторый исходный код реакции
        на команды, определяемые на Шаге 2.

                               Понятие о командах
        ─────────────────────────────────────────────────────────────────

             На данным  момент вы знаете,  что команды представляют собой
        целочисленные константы,  обычно представляемые идентификаторами,
        начинающимися  с  cm.  Вы уже видели несколько стандартных команд
        Turbo Vision,  таких как cmQuit и cmNext,  и определяли для прог-
        раммы Tutorial свои собственные команды,  такие как cmOpenWindow.
        Вы также можете указать,  что эти команды связаны с определенными
        действиями, такими как нажатие оперативной клавиши или выбор эле-
        мента (пункта) меню.  В данном разделе вы увидите,  что  означает
        "генерация" команды, как команды связаны с событиями, и что озна-
        чает "реакция" на команду.

                               Что такое события?
        ─────────────────────────────────────────────────────────────────

             Мы уже говорили в данном руководстве о программировании, уп-
        равляемом событиями,  и некоторых его преимуществах.  Возможно вы
        поняли, что  оно  предусматривает написание программы таким обра-
        зом, что она реагирует на  внешние  действия,  такие  как  щелчки
        кнопкой "мыши"  или нажатия клавиш.  В таком случае говорят,  что
        ваша программа должна реагировать на события.

             Обычно мы пишем программу, которое выполняет некоторое дейс-
        твие, ожидает  ввода от пользователя и действует в соответствии с
        этим вводом.  Центральной частью в такой модели  программирования
        является цикл ввода,  за котором обычно следует оператор перехода
        по условию. Упрощенная версия может выглядеть так:


         B.Pascal 7 & Objects/TV#1    - 38 -

             repeat
               GetCommand;                         { получение команды }
             until Command <> 0;                                { цикл }
             case Command of
                1:  DoSometing;                   { некоторые действия }
                2:  DoSometingElse                   { другие действия }
                else EtCetera;
             end;

                   Примечание: Программа   моделирует   управляющий  цикл
              программы Паскаля.

             Процедуры DoSometing и DoSomethingElse  выполняют  некоторые
        действия и возвращаются обратно к циклу или,  возможно,  содержат
        свои собственные циклы ввода и действия. Основным недостатком та-
        кого  рода  программирования  является сильная привязка отдельных
        частей исходного кода друг к другу - одни части программы  должны
        знать  о  доступности  или  недоступности в каждый момент времени
        других частей.

             При программировании,  управляемом событиями,  вместо много-
        численных циклов  ввода  вся  программа имеет один цикл,  который
        называется циклом событий и управляет всем интерфейсом с "внешним
        миром" и  информацией о том,  что мы перешли в определенную часть
        программы. Данная структура допускает значительную гибкость. Нап-
        ример, если  вы выводите спускающееся меню,  а затем решили,  что
        хотите щелкнуть "мышью" в строке состояния,  вам не нужно сначала
        выбирать меню и выходить из "режима меню" перед тем,  как перейти
        куда-то еще. Цикл событий распознает, что означает щелчок "мышью"
        в строке  состояния и сообщает объекту строки состояния о реакции
        на щелчок кнопки "мыши".  Закрытие меню происходит автоматически,
        когда вы перемещаете фокус ввода на строку состояния.

                   Примечание: Программирование,  управляемое  событиями,
              часто называют "безрежимным  программированием",  поскольку
              пользователь может получить доступ к любой части программы,
              а не только к текущему режиму.

                               Реакция на события
        ─────────────────────────────────────────────────────────────────

             До сих пор мы не беспокоились о том,  как цикл событий опре-
        деляет, куда посылать  события.  Механизм  маршрутизации  событий
        подробно описывается в Главе 9 "Программирование, управляемое со-
        бытиями". Важно знать,  что цикл событий записывает информацию  о
        событии в  вариантную  запись типа TEvent и посылает ее в объект,
        которому нужно знать о событии.

             Все видимые объекты Turbo Vision имеют  виртуальные  методы,
        называемые обработчиками  событий.  Эти  методы всегда называются
        HandleEvent и воспринимают параметр-переменную типа TEvent. Таким
        образом, когда цикл событий прикладной программы обнаруживает со-
        бытие, он делает заключение о том,  какой объект должен обрабаты-

        вать событие, создает запись события и передает эту запись методу
        объекта HandleEvent.  Затем объект проверяет запись события и ре-
        шает, что нужно делать с событием.

             Например, если  событием является щелчок кнопкой "мыши",  то
        запись события содержит такую информацию, как экранные координаты
        щелчка "мышью" и наличие двойного щелчка. Нажатие клавиши на кла-
        виатуре посылает событие,  включающее в себя код опроса  или  код
        символа нажатой клавиши.
             На данном шаге вы узнаете о том,  как обрабатывать командные
        события.

                           Обработка командных событий
        ─────────────────────────────────────────────────────────────────

             Каждая запись события содержит поле типа Word с именем What,
        которое цикл сообщений заполняет константой,  указывающей,  какой
        тип события описывается в записи. Одной из этих констант является
        evCommand, что указывает на командное событие. Если событие явля-
        ется  командным событием,  то запись содержит также поле с именем
        Command,  содержащее командную константу, связанную с пунктом ме-
        ню,  клавишей состояния или оперативной клавишей, которые генери-
        рует командное событие.

             Например, если вы щелкните "мышью" в элементе строки состоя-
        ния Alt+F3 (или нажмете клавиши Alt+F3),  цикл событий генерирует
        командное событие,  устанавливает  поле  записи  события  What  в
        evCommand,  а поле Command - в cmClose. Затем он направляет собы-
        тие в активное окно. Оконные объекты знают, что когда они получа-
        ют  команду  cmClose,  то  требуется  их  закрытие - вызов метода
        Close:
               if Event.What = evCommand then
                 case Event.Command of
                   cmClose:
                   begin
                     Close;
                     ClearEvent;
                   end;
                 .
                 .

                   Примечание: Это   сильно   упрощенная   часть   метода
              TWindow.HandleEvent.

             Заметим, что после реакции  на  событие  объекты  сбрасывают
        (очищают) событие, вызывая метод ClearEvent. Это указывает другим
        объектам, что событие обработано и в дальнейшей его обработке нет
        необходимости.

                            Шаг 3: Реакция на команды
        ─────────────────────────────────────────────────────────────────

             Теперь, когда мы рассмотрели этот процесс в теории,  настало

         B.Pascal 7 & Objects/TV#1    - 40 -

        время написать фактическую реакцию на командные события.  На этом
        шаге вы реализуете реакцию на следующие команды:

             * Изменение видеорежима.

             * Вывод окна "About".

             Кроме того, вы узнаете о разрешении и запрещении команд.

                              Изменение видеорежима
        ─────────────────────────────────────────────────────────────────

             Если вы выведете  спускающееся  меню  Options  (Возможности)
        программы Tutorial,  то  заметите,  что первый элемент называется
        Toggle Video Mode (Переключение видеорежима).  Метод  InitMenuBar
        привязывает этот пункт меню к команде cmOptionsVideo. Чтобы опре-
        делить реакцию на эту команду, вам нужно задать для TTutorApp ме-
        тод HandleEvent,   который   знает  о  том,  как  реагировать  на
        cmOptionsVideo. Обработчик событий показан ниже:

             procedure TTutorApp.HandleEvent(var Event: TEvent);
             begin
               inherited HandleEvent(Event);     { сначала вызывается
                                                   наследуемый метод }
               if Event.What = evCommand then    { если не обработано,
                                                   проверить на команды }
               case Event.Command of
                 cmOptionsVideo;
                   begin
                     SetScreenMode(ScreenMode xor smFont8x8);
                                             { переключение бита режима }
                     ClearEvent(Event);      { отметить событие, как
                                               обработанное }
                   end;
               end;
             end;

                   Примечание: Это переопределение обработчика событий из
              примера программы TUTOR03A.PAS.

             Если вы теперь запустите программу и выберете в меню Options
        пункт Toggle,  то программа переключит видеорежим со стандартного
        25-строчного  режима на 43- или 50-строчный режим EGA/VGA или об-
        ратно,  переключив бит smFont8x8 в переменной ScreenMode.  На мо-
        нохромных  системах или системах с CGA эта команда действовать не
        будет.

                   Примечание: Работа с  битовыми  флагами  поясняется  в
              Главе 7.


         B.Pascal 7 & Objects/TV#1    - 41 -

                            Вызов наследуемых методов
        ─────────────────────────────────────────────────────────────────

             Как вы  можете  заметить,  первое,  что  делает  новый метод
        HandleEvent -  это  вызов  метода  HandleEvent,  наследуемого  из
        TApplication. Как  правило,  когда вы переопределяете виртуальный
        метод в Turbo Vision,  в некоторой точке нового метода вызывается
        наследуемый метод.

             Вызов нового метода по существу передает новому методу пове-
        дение своего предка. В предыдущем примере TTutorApp вызывает нас-
        ледуемый метод HandleEvent, а затем определяет некоторое дополни-
        тельное поведение.  При этом как бы говорится:  "TTutorApp должна
        вести себя  как TApplication и выполнять некоторую дополнительную
        обработку".

             Вы можете также определить методы HandleEvent, которые отме-
        няют часть наследуемого поведения, установив перед вызовом насле-
        дуемого метода определенные события,  а затем сбросив событие та-
        ким образом, что наследуемый метод не будет его обрабатывать. Это
        означает: "Кроме обработки отдельных событий,  данный объект дол-
        жен обрабатывать события как предок".

             В общем случае, если вы хотите устранить некоторое наследуе-
        мое поведение,  то вам следует переопределить его  перед  вызовом
        наследуемого метода или вовсе не вызывать наследуемый метод. Если
        вы хотите добавить к наследуемому  поведению  дополнительное,  то
        вызовите сначала наследуемый метод, а затем определите нужные до-
        полнительные действия.

                        Вывод информационного окна About
        ─────────────────────────────────────────────────────────────────

             Программы часто  имеют  пункты меню,  которые выводят окно с
        информацией о  программе.  Такое  окно  обычно  называется  окном
        About. Turbo Vision предусматривает утилиту окна сообщения, кото-
        рую вы можете использовать для вывода пользователям сообщений.  В
        следующем разделе  вы  используете  окно  сообщений  для создания
        простого окна About.

             Меню Help  (Справка)  программы  Tutorial   содержит   пункт
        "About...". Многоточие  после  имени  пункта меню указывает,  что
        этот пункт выводит диалоговое окно.  Этот пункт меню связан с ко-
        мандой cmAbout,  поэтому,  чтобы вывести на экран ваше диалоговое
        окно, вам нужно сообщить методу HandleEvent TTutorApp  о  реакции
        на cmAbout.  На этот раз вместо фактического вывода на экран окна
        About из  HandleEvent  вы  вызываете  другой   метод   с   именем
        DoAboutBox, который  фактически  выводит окно About.  Необходимые
        изменения кода приведены ниже:

             procedure TTutorApp.DoAboutBox;
             begin   { #3 - центрирование строки; #13 - перевод строки }
             begin

         B.Pascal 7 & Objects/TV#1    - 42 -

               MessageBox(#3'Учебная программа Turbo Vision'#13 +
                 #3Copyright 1992'#13#3'Borland International',
                 nil mfInformation or mfOKButton); { задание заголовка
                                                     и кнопки }
             end;

             procedure TTutorApp.HandleEvent(var Event: TEvent);
             begin
               inherited HandleEvent(Event);  { сначала вызывается
                                                наследуемый метод }
               if Event.What = evCommand then { если не обработано,
                                                проверить на команды }
               case Event.Command of
                 cmOptionsVideo;
                   begin
                     SetScreenMode(ScreenMode xor smFont8x8);
                                          { переключение бита режима }
                     ClearEvent(Event);   { отметить событие, как
                                            обработанное }
                   end;
               cmAbout:
                 begin
                   DoAboutBox;      { вызов метода информационного окна }
                   ClearEvent(Event);  { отметка события как
                                         обработанного }
               end;
             end;

                   Примечание: Этот  пример  программы с добавлением окна
              About вы можете найти в программе TUTOR03B.PAS.

             Теперь, когда вы запустите программу,  то можете  выбрать  в
        меню окно About и закрыв его, щелкнув "мышью" на кнопке OK.

                          Использование окон сообщений
        ─────────────────────────────────────────────────────────────────

             Функция MessageBox предоставляет вам простой способ информи-
        рования или уведомления пользователя с помощью ограниченного объ-
        ема информации и ограниченной обратной связи посредством "нажима-
        емых" пользователем командных кнопок.

             MessageBox воспринимает три параметра.  Первый - это выводи-
        мая строка сообщения. Если текст строки превышает одну строку, то
        он автоматически продолжается с новой строки. Вы можете также ис-
        пользовать принудительное  разбиение  строки  (как   это   делает
        DoAboutBox), включив  в  нее символ возврата каретки (#13).  Если
        строка начинается с #3,  то строка сообщения вместо  выравнивания
        влево центрируется.

             Второй параметр  - это указатель на массив записей элементов
        данных, поставляемых в строку сообщения (если они имеются). Стро-
        ка сообщения может содержать символы форматирования,  которые за-

         B.Pascal 7 & Objects/TV#1    - 43 -

        меняются элементами данных  из  второго  параметра.  Для  простых
        текстовых сообщений второй параметр имеет значение nil.

                      Комбинирование флагов окна сообщения
        ─────────────────────────────────────────────────────────────────

             Последний параметр MessageBox представляет собой набор бито-
        вых флагов,  указывающий  выводимый  в окне сообщения заголовок и
        помещаемые под текстом командные кнопки.  Простейший способ уста-
        новки этих  бит состоит в использовании предопределенных констант
        флагов сообщений,  которые имеют идентификаторы,  начинающиеся  с
        mf.

             Для комбинирования mfInformation,  mfWarning, mfConfirmation
        или mfError с mfOKButton, mfOKCancel или mfYesNoCancel используй-
        те операцию or.

             Чтобы увидеть различные эффекты, попробуйте подставить в ди-
        алоговое окно About  в  программе  Tutorial  различные  сочетания
        констант mfXXXX.

                  Чтение значений, возвращаемых окном сообщения
        ─────────────────────────────────────────────────────────────────

             Когда пользователь щелкает "мышью"  на  одной  из  командных
        кнопок в окне сообщения, окно сообщения закрывается, а MessageBox
        возвращает значение  команды,  связанное  с  "нажатой"  командной
        кнопкой. Этим  значением всегда будет cmOK,  cmCancel,  cmYes или
        cmNo, так что вы можете использовать блоки сообщений для  простых
        вопросов пользователю  и  получения  простых ответов (типа да/нет
        или OK/не OK).

             В случае окна About вам не важно, как пользователь закрывает
        окно (это несущественная информация), так что вы можете игнориро-
        вать возвращаемое MessageBox значение. Используя расширенный син-
        таксис Паскаля,  вы можете вызывать функцию как процедуру, отбра-
        сывая возвращаемое значение.

                   Примечание: Расширенный синтаксис  {$X+}  используется
              по умолчанию.

                         Разрешение и запрещение команд
        ─────────────────────────────────────────────────────────────────

             Теперь, когда вы определили реакцию на некоторые команды ме-
        ню, настало  время  больше узнать о командах Turbo Vision в общем
        плане. Как вы уже видели,  Turbo Vision  автоматически  запрещает
        некоторые команды (например, команду cmClose, когда закрывать не-
        чего). Вы уже видели,  что в меню Window пункты Next (Следующий),
        Previous (Предыдущий) и Zoom (Распахивание) запрещены,  поскольку
        соответствующие действия отсутствуют. На следующем шаге мы реаль-
        но добавим окна в оперативную область,  и вы увидите, что эти ко-
        манды стали разрешенными.

         B.Pascal 7 & Objects/TV#1    - 44 -


             Конечно, Turbo Vision может автоматически обрабатывать опре-
        деляемые вами команды,  и могут быть моменты, когда вы, например,
        хотите запретить стандартную команду,  которая в противном случае
        доступна. В данном разделе вы узнаете,  как разрешать и запрещать
        отдельные команды и группы команд.

                         Какие команды можно запретить?
        ─────────────────────────────────────────────────────────────────

             Как вы уже видели, команды представляют собой константы типа
        Word, но вы можете запрещать только команды в  диапазоне  0..255,
        так как  запрещение действует только на множество (набор) команд,
        а множества  Паскаля содержат только элементы в данном диапазоне.
        Когда вы определите команды, перед присваиванием значения посмот-
        рите, сможете ли вы запрещать команду. Поскольку запретить вы мо-
        жете только ограниченное число команд,  присваивайте значения со-
        ответствующим образом.

             Имейте в виду, что Turbo Vision резервирует некоторые коман-
        ды в  качестве  стандартных  команд,  включая команды в диапазоне
        0..99, которые вы можете запретить, и 256..999, которые вы запре-
        тить не можете. Поэтому вы можете определить 100..255 запрещаемых
        команд и 1000..65535 не запрещаемых.

                                Запрещение команд
        ─────────────────────────────────────────────────────────────────

             Turbo Vision предусматривает для набора команд множественный
        тип TCommandSet.  Каждый визуальный объект Turbo Vision имеет ме-
        тод DisableCommands, воспринимающий TCommandSet в качестве одного
        из параметров и запрещающий команды в этом множестве.

             Когда вы запрещаете команду,  она запрещается во всей  прик-
        ладной программе,  так как вы не хотите, чтобы другие части прог-
        раммы генерировали команду,  которую вы не  хотите  обрабатывать.
        Все элементы меню,  клавиши состояния и командные кнопки, которые
        генерируют запрещенные команды,  сами являются  запрещенными.  Вы
        можете щелкать на них "мышью", но действовать они не будут. Выво-
        дятся эти пункты "серыми".

             Например, ни одна из первых команд в меню Window пока ничего
        не делает,  так  что  вы можете сначала запретить их в программе,
        разрешив их только при наличии соответствующих операций.  Неплохо
        сделать это в конструкторе прикладной программы:

             constructor TTutorApp.Init;
             begin
               inherited Init;       { стандартная установка приложения }
               DisableCommands([cmOrderWin, cmStockWin, cmSupplierWin]);
             end;

         B.Pascal 7 & Objects/TV#1    - 45 -


                                Разрешение команд
        ─────────────────────────────────────────────────────────────────

             Аналогично тому, как любой видимый объект Turbo Vision может
        запрещать команды,  он имеет и соответствующий разрешающий их ме-
        тод EnableCommands.   В   Шаге   11   вы   будете    использовать
        EnableCommands, чтобы вновь разрешить команды меню Orders.



         B.Pascal 7 & Objects/TV#1    - 46 -

─────────────────────────────────────────────────────────────────────────
                            ГЛАВА 3. Добавление окон
        ─────────────────────────────────────────────────────────────────

             До сих пор вы настраивали строку  меню  и  строку  состояния
        прикладной программы и видели, как можно реагировать на их коман-
        ды. В данной главе вы будет добавлять окна к  рабочей  области  и
        управлять ими.

             В этой главе вы выполните следующие шаги:

             * Добавление простого окна.

             * Перекрывающиеся и неперекрывающиеся окна.

             * Добавление окон файлового редактора.

             * Использование  стандартного диалогового окна открытия фай-
               ла.

             * Добавление окна буфера вырезанного изображения.

                             Шаг 4: Добавление окна
        ─────────────────────────────────────────────────────────────────

             Одно из основных преимуществ Turbo Vision состоит в том, что
        она создание и управление множеством перекрывающихся окон с изме-
        няемым размером.  Ключевым  моментом в управлении окнами является
        оперативная область,  которая знает, как отслеживать все заданные
        ей окна и которая может выполнять такие операции,  как вывод окон
        без перекрытия,  с перекрытием и циклическое переключение по дос-
        тупным окнам.

             Оперативная (рабочая)  область  -  это пример группы в Turbo
        Vision; то есть видимый объект, который содержит одни и управляет
        другими  видимыми  элементами.  Вы уже использовали одну группу -
        само приложение (прикладную программу), которая управляет строкой
        меню, строкой состояния и оперативной областью.  По мере изучения
        вы обнаружите,  что окна и диалоговые окна также составляют груп-
        пы.

             Аналогично полосе меню и строке состояния,  объект оператив-
        ной области строится в виртуальном методе объекта приложения, ко-
        торый называется  InitDesktop и назначается глобальной переменной
        Desktop. По умолчанию Desktop охватывает весь  экран  приложения,
        не перекрываемый меню и строкой состояния.

             Добавления окна  к  оперативной  области  приложения требует
        трех шагов:

             * Назначения границ окна.
             * Построения оконного объекта.
             * Включения окна в оперативную область.

         B.Pascal 7 & Objects/TV#1    - 47 -

                            Добавление простого окна
        ─────────────────────────────────────────────────────────────────

             На первом шаге вы можете добавить окно в оперативную область
        в ответ на выбор пункта New (Новый) меню File (Файл).  Этот пункт
        генерирует команду cmNew, так что вам нужно определить реакцию на
        эту команду в методе  HandleEvent  приложения.  В  данном  случае
        просто вызовите  метод  с именем NewWindow,  который будете затем
        модифицировать.

             procedure TTutorApp.HandleEvent(var Event: TEvent);
             begin
               inherited HandleEvent(Event);
               if Event.What = evCommand then
               begin
                 case Event.Command of
                    cmNew:
                     begin
                       NewWindow;
                       ClearEvent(Event);
                     end;
                  .
                  .
             end;

             procedure TTutorApp.NewWindow;
             var
                R: TRect;
                TheWindow: PWindow;
             begin
                R.Assign(0, 0, 60, 20);        { назначение границ окна }
                TheWindow := New(PWindow,
                     Init(R, 'Окно', wmNoNumber));    { построение окна }
                Desktop^.Insert(TheWindow);           { включение окна в
                                                    оперативную область }
             end;

             Изменения HandleEvent  должны  быть  вам   знакомы.   Однако
        NewWindow содержит несколько новых строк.

                             Назначение границ окна
        ─────────────────────────────────────────────────────────────────

             Вы уже встречались с переменными типа TRect.  Однако для по-
        лосы меню  и  строки состояния размеры задаются на основе размера
        приложения (с помощью метода GetExtent).  В NewWindow вы присваи-
        ваете новому окну набор абсолютных координат с помощью Assign.

                           Построение оконного объекта
        ─────────────────────────────────────────────────────────────────

             Следующий оператор  строки  динамический  экземпляр   общего

         B.Pascal 7 & Objects/TV#1    - 48 -

        объектного типа окна TWindow.  Построение окна требует трех пара-
        метров: границ окна,  строки заголовка окна и номера окна. В дан-
        ном случае окно имеет заголовок 'Окно' и не имеет номера (так как
        вы передали константу wnNoNumber).

             Если вы присваиваете окну номер, то пользователь может акти-
        визировать окно  в оперативной области нажатием клавиши Alt и со-
        ответствующего окну номера.

                                 Включение окна
        ─────────────────────────────────────────────────────────────────

             Insert - это общий метод для всех групп Turbo Vision. Он да-
        ет способ передачи управления группе и входящим в  нее  объектам.
        Когда вы вставляете TheWindow в оперативную область, то сообщаете
        оперативной области, что она может управлять TheWindow.

             Если вы теперь запустите программу и выберете  New  из  меню
        File, то  выводится  пустое голубое окно с заголовком 'Окно' (или
        'The Window', если вы работаете с примером с дистрибутивного дис-
        ка).  Если  вы  снова  выберете New,  то в том же месте выводится
        идентичное окно, поскольку NewWindow назначает для окна точно та-
        кие же координаты. Используя "мышь", вы можете выбрать другие ок-
        на.

             Пункты меню под Window и оперативные клавиши,  связанные  со
        строкой состояния, работают теперь с окнами. Заметим, что элемен-
        ты меню и строки состояния не изменились. Им ничего не известно о
        своих окнах.  Они просто выдают команды, на которые уже могут от-
        вечать окна и оперативная область.

                            Более надежное включение
        ─────────────────────────────────────────────────────────────────

             Объект приложения содержит несколько методов, которые вы мо-
        жете использовать для упрощения общих операций и  обеспечения  их
        большей надежности.  Под надежностью мы понимаем, что здесь менее
        вероятно возникновение таких проблем,  как превышение объема дос-
        тупной памяти.  Ваш  объект  приложения  наследует метод с именем
        InsertWindow, который берет на себя часть Desktop^.Insert() вклю-
        чения окна.  Кроме того, InsertWindow обеспечивает успешное пост-
        роение окна и непревышение доступной памяти.

             Если использовать InsertWindow, то newWindow выглядит следу-
        ющим образом:

             procedure TTutorApp.NewWindow:
             var
               R: TRect;
               TheWindow: PWindow;
             begin

         B.Pascal 7 & Objects/TV#1    - 49 -

               R.Assign(0, 0, 60, 20);
               New(TheWindow, Init(R, 'Окно', wnNoNumber));
               InsertWindow(TheWindow);
             end;

                   Примечание: Пример  надежного включения окна вы можете
              найти в программе TUTOR01A.PAS.

             Если нет веских причин обойти его механизмы обеспечения  на-
        дежности, неплохо  всегда  использовать  InsertWindow для вставки
        окон в оперативную область.

                    Вывод окон с перекрытием и без перекрытия
        ─────────────────────────────────────────────────────────────────

             Одним из свойств оперативной области является ее возможность
        обеспечивать вывод окон с перекрытием и без перекрытия.  Приложе-
        нию просто  нужно  сообщить оперативной области,  когда это нужно
        сделать. Используемый по умолчанию в TApplication обработчик  со-
        бытий отвечает  на  стандартные  команды меню cmTile и cmCascade,
        вызывая, соответственно, методы TApplication Tile и Cascade.

             Такое используемое по умолчанию поведение является одной  из
        важных причин вызова наследуемых методов HandleEvent.

                            Добавление окна редактора
        ─────────────────────────────────────────────────────────────────

             Теперь, когда вы видели поведение окон в общем, можно  вклю-
        чить более полезное окно, такое как окно файлового редактора. Мо-
        дуль Editors в Turbo Vision именно такое окно,  так что вы можете
        изменить NewWindow для включения вместо общего окна окна редакто-
        ра.

             Добавление окна редактора требует только двух дополнительных
        шагов и изменения одного шага:

             * Определения буфера редактирования файла.

             * Задания диалоговых окон редактора.

             * Построения окна файлового редактора.

                     Определения буфера редактирования файла
        ─────────────────────────────────────────────────────────────────

             Если вы хотите, чтобы ваше приложение использовало какие-ли-
        бо редакторы файлов (включая буфер вырезанного изображения),  вам
        нужно инициализировать переменную MaxHeapSize модуля Memory  (это
        делается перед  построением объекта приложения).  MaxHeapSize ре-
        зервирует часть памяти над обычной динамически распределяемой об-
        ластью, которая  будет  использоваться для буферов редактирования
        файлов.

         B.Pascal 7 & Objects/TV#1    - 50 -


             MaxHeapSize устанавливает число 16-байтовых параграфов,  ко-
        торые прикладная  программа может использовать свою обычную дина-
        мически распределяемую память,  оставляя остальную свободную  па-
        мять для   буферов   редактирования  файла.  Изменения  программы
        Tutorial, включая установку MaxHeapSize в значение 8192 (что  оз-
        начает резервирования 128К памяти, что достаточно для такой прос-
        той программы) показаны в приведенном ниже примере.

                   Примечание: О MaxHeapSize и буферах файлового редакто-
              ра подробнее рассказывается в Главе 15.

                        Задание диалоговых окон редактора
        ─────────────────────────────────────────────────────────────────

             Модуль содержит    процедурную    переменную    с     именем
        EditorDialog, которая  работает  со всеми диалоговыми окнами всех
        объектов редактора в вашей программе.  По умолчанию  EditorDialog
        реально ничего  не делает,  так что перед использованием объектов
        редактора вам нужно присвоить EditorDialog функцию, выводящую по-
        лезные диалоговые окна и возвращающую нужные значения.

             Turbo Vision  обеспечивает такую функцию,  которую вы можете
        использовать. Это функция StdEditorDialog.  Если вы хотите  полу-
        чить более  сложные  диалоговые  окна,  то можете определить свою
        собственную функцию.  StdEditorDialog будет для этого хорошей ос-
        новой. Чтобы  использовать стандартные диалоговые окна редактора,
        просто поместите в конструктор приложения оператор:

             EditorDialog := StdEditorDialog;

             Пример такого добавления в TTutorApp.Init  вы  можете  найти
        ниже.

                            Построение окна редактора
        ─────────────────────────────────────────────────────────────────

             Конструктор окна редактора воспринимает точно те же парамет-
        ры, что и общее окно,  которое вы уже построили. Основным измене-
        нием является  тип  конструируемого  окна   (TEditWindow   вместо
        PWindow) и передаваемый окну заголовок.

             Построение окна  редактора  с  пустой строкой заголовка дает
        окно с заголовком "Unrtitled",  который указывает, что набираемая
        в редакторе  информация еще не присвоена конкретному файлу.  Пос-
        кольку вы создаете этот редактор в ответ на команду File│New,  то
        следует создать окно редактора без заголовка, как показано в при-
        веденном ниже примере:

             constructor TTutorApp.Init;
             begin
               MaxHeapSize :- 8192; { устанавливает буфер редактирования
                                      файла над оперативной областью }

         B.Pascal 7 & Objects/TV#1    - 51 -

               EditorDialog := StdEditorDialog { использовать стандартные
                                      диалоги редактора }
               inherited Init;
               DisableCommands([cmOrderWin, CmStockWin, cmSupplierWin]);
             end;

             procedure TTutorNewWindow;
             var
               R: TRect;
               TheWindow: PEditWindow; { обратите внимание на изменение
                                         типа }
             begin
               R.Assign(0, 0, 60, 20);
               New(TheWindow, Init(R, '', wmNoNumber)); { построение окна
                                         редактирования }
               InsertWindow(TheWindow);
             end;

                   Примечание: Включение окна файлового редактора  выпол-
              няется программой TUTOR04B.PAS.



         B.Pascal 7 & Objects/TV#1    - 52 -

                    Использование стандартных диалоговых окон
        ─────────────────────────────────────────────────────────────────

             Иметь редактор файла, создающий новые файлы, полезно, но вам
        необходима также  возможность  редактировать  существующие файлы.
        Для этого вам нужно сообщить редактору файла, какой файл вы хоти-
        те редактировать.  Хотя вы можете использовать простую подсказку,
        позволяющую получить имя файла у пользователя, значительно лучшим
        подходом является подход, позволяющий вывести пользователю список
        доступных файлов,  из которых он может выбирать нужные файлы, пе-
        ремещаясь  по различным подкаталогам.  Стандартный диалоговый мо-
        дуль Turbo Vision предусматривает объект диалогового окна,  кото-
        рый выполняет именно эти функции.

         ╔═ []════════════ Open File ════════════════════════════════╗
         ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
         ║▒▒▒File Name▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
         ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
         ║▒▒▒ ASCIIINR.PAS                         ▒▒▒▒▒▓▓Open▓▓▓▒▒▒▒▒║
         ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█████████▒▒▒▒║
         ║▒▒▒Files▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
         ║▒▒▒ ASCIIINR.PAS                         ▒▒▒▒▒▓▓Ok▓▓▓▓▓▒▒▒▒▒║
         ║▒▒▒                                      ▒▒▒▒▒▒█████████▒▒▒▒║
         ║▒▒▒                                      ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
         ║▒▒▒                                      ▒▒▒▒▒▓▓Cancel▓▒▒▒▒▒║
         ║▒▒▒                                      ▒▒▒▒▒▒█████████▒▒▒▒║
         ║▒▒▒                                      ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
         ║▒▒▒                                      ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
         ║▒▒▒                                      ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
         ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
         ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
         ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
         ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
         ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
         ║                                                            ║
         ╚════════════════════════════════════════════════════════════╝

             Рис. 1.3  Диалоговое  окно  File  Open  стандартного  модуля
        StdDlgs.

             При наличии объекта файлового диалогового окна вам нужно вы-
        полнить его. Выполнение здесь аналогично вставке, которую вы реа-
        лизовали при  работе  с окнами текстового редактора,  но при этом
        создается также режимное диалоговое окно.  Его режимность означа-
        ет, что  диалоговое  окно  активно только в части приложения - вы
        можете щелкать "мышью" в других частях прикладной программы,  та-
        ких как строка меню,  но реакции при этом не последует. После то-
        го, как окно или диалоговое окно станут режимными,  вы не сможете
        взаимодействовать с  другими частями данного окна или диалогового
        окна, пока не закроете его или не выполните другое окно.

             Чтобы отредактировать  существующие  файлы,  вам  необходимо
        следующее:

         B.Pascal 7 & Objects/TV#1    - 53 -


             * Построение файлового диалогового окна.

             * Выполнение файлового диалогового окна для вывода пользова-
               телю подсказки с именем файла.

             * Построения окна редактирования для этого файла.

                      Построение файлового диалогового окна
        ─────────────────────────────────────────────────────────────────

             Конструктор файлового диалогового окна воспринимает пять па-
        раметров: три строки,  три слова,  содержащих флаги параметров, и
        номер списка протокола. Передаваемые строки - это начальная маска
        имени файла (например, '*.*') и метка строки ввода, где пользова-
        тель будет набирать имя файла (в данном порядке).

             Флаги параметров  действуют  аналогично тем,  которые вы ис-
        пользовали ранее для окна сообщения. Они указывают, какие команд-
        ные кнопки  выводятся  в окне в дополнение к кнопке Cancel (Отме-
        на), которая включается всегда.  В зависимости  от  использования
        диалогового окна  в  целях выбора файла для открытия или сохране-
        ния, вы используете различные комбинации начинающихся с fd  конс-
        тант.

             Пока в  качестве номера протокола передавайте просто ненуле-
        вое значение.  Позднее вы увидите,  как легко  можно  отслеживать
        имена открытых файлов.

                           Выполнение диалогового окна
        ─────────────────────────────────────────────────────────────────

             Метод ExecuteDialog работает аналогично InsertWindow. Он вы-
        полняет проверку,  чтобы убедиться в передаче допустимого объекта
        диалогового окна и наличии достаточного для  выполнения  действия
        объема  памяти.  Затем  он включает диалоговое окно в оперативную
        область и делает его режимным.

             Второй передаваемый ExecuteDialog параметр указывает на  за-
        пись данных,  которую диалоговое окно может использовать для ини-
        циализации, когда оно становится режимным. Например, файловое ди-
        алоговое окно воспринимает строку, содержащую имя файла. Передача
        в этом параметре значения nil указывает,  что вы не хотите, чтобы
        диалоговое окно  инициализировало свои управляющие элементы и что
        при завершении вы не хотите считывать значения  управляющих  эле-
        ментов.

                   Примечание: Об  управляющих элементах и их инициализа-
              ции рассказывается в Главе 12 "Объекты управляющих  элемен-
              тов".

             ExecuteDialog -  это функция,  которая аналогично MessageBox
        возвращает значение  команды,  закрывающей  окно.  Поэтому,  если

         B.Pascal 7 & Objects/TV#1    - 54 -

        пользователь "нажал" командную кнопку Cancel, ExecuteDialog возв-
        ращает cmCancel;  выбор OK приводит  к  тому,  что  ExecuteDialog
        возвращает cmOK и так далее.  Таким образом, ваша программа, счи-
        тывая данные из управляющих элементов (если пользователь не отме-
        нил окно),  может  сообщить,  принял пользователь диалоговое окно
        или отменил его.  Заметим, что OpenWindow открывает окно редакти-
        рования только если значение, возвращаемое ExecuteDialog, не рав-
        но cmCancel.

                      Построение окна редактирования файла
        ─────────────────────────────────────────────────────────────────

             Построение диалогового окна редактирования файла выполняется
        аналогично. Это подобно тому,  что вы делали в NewWindow,  только
        вместо пустой строки,  как при построении окна редактора, переда-
        ется имя файла.

             В ответ на команду cmOpen от пункта Open меню File ваше при-
        ложение должно вызывать новый метод с именем OpenWindow:

             procedure TTutorApp.OpenWindow
             var
               R: TRect;                { границы для окна
                                          редактирования }
               FileDialog: PFileDialog; { выбор файла в диалоговом окне }
               TheFile: PNameStr;       { строка для имени файла }
             const
               FDOptions: Word = fdOKButton or fdOpenButton; { параметры
                                          диалога }
             begin
               TheFile := '*.*';        { начальная маска для имени
                                          файла }
               New(FileDialog, Init(TheFile, 'Open File', '~F~ile name',
                   FDOptions, 1));
               if ExecuteDialog(FileDialog, @TheFile) <> cmCancel then
               begin
                 R.Assign(0, 0, 75, 20);
                 InsertWindow(New(PEditWindow, Init(R, TheFile,
                              wmNoNumber)));
               end;
             end;

              Шаг 5: Добавление окна буфера вырезанного изображения
        ─────────────────────────────────────────────────────────────────

             Редакторы и окна редактирования значительно  более  полезны,
        если вы можете вырезать текст и вставлять его в буфер вырезанного
        изображения (или из него),  выполнять обмен текстом между  окнами
        переупорядочивать текст и так далее.  Редакторы Turbo Vision пол-
        ностью поддерживают средство буфера вырезанного изображения.

             Буфер вырезанного изображения (карман) - это  просто  объект
        редактора, который  всегда  присутствует  в прикладной программе.

         B.Pascal 7 & Objects/TV#1    - 55 -

        Если вы хотите, чтобы буфер вырезанного изображения работал в фо-
        новом режиме, вам даже не нужно задавать этот буфер для окна. Од-
        нако, в программе Tutorial вы создаете  окно  буфера  вырезанного
        изображения, так что вы можете выводить на экран буфер вырезанно-
        го изображения и его содержимое.

             Добавление к окну  буфера  вырезанного  изображения  требует
        двух шагов:

             * Построения окна редактора.

             * Создание редактора в буфере вырезанного изображения.

                            Построение окна редактора
        ─────────────────────────────────────────────────────────────────

             Построение окна для буфера вырезанного изображения аналогич-
        но построению  нового  окна  редактирования файла.  Вы назначаете
        границы окна,  строите неименованное окно  с  этими  границами  и
        включаете окно в оперативную область.  Однако,  в случае окна бу-
        фера вырезанного изображения вам не требуется видеть  окно,  пока
        для этого не будет дан специальный запрос.  Таким образом,  перед
        вставкой окна нужно вызвать его метод  Hide.  Метод  Hide  делает
        объект невидимым, пока вы не вызовите его метод Show.

             Окно следует сделать скрытым перед его вставкой. В противном
        случае окно будет появляться и исчезать на экране (мерцать),  что
        раздражает пользователей.  Поскольку проверка допустимости обычно
        выполняется в InsertWindow,  вам потребуется отдельная  проверка.
        Функция  ValidView объекта TApplication выполняет те же проверки,
        что и методы InsertWindow и ExecuteDialog.  ValidView  возвращает
        значение  nil  в случае недопустимости отображаемого элемента или
        указатель на отображаемый элемент,  если он допустимый. Использо-
        вание функции ValidView показано в приведенном ниже примере. Пос-
        ле завершения проверки допустимости отображаемого элемента вы мо-
        жете сделать его скрытым и включить его в оперативную область.

              Присваивание редактора буфера вырезанного изображения
        ─────────────────────────────────────────────────────────────────

             Модуль Editors определяет переменную с именем Clipboard, ко-
        торую другие  объекты редактора используют для операций вырезания
        и вставки.  Если Clipboard имеет значение nil, то эти операции не
        действуют. Поскольку вы строите окно буфера вырезанного изображе-
        ния, то вам нужно установить переменную Clipboard таким  образом,
        чтобы  она  указывала  на редактор буфера вырезанного изображения
        (как показано в приведенном ниже примере).

             Единственное, о чем еще нужно побеспокоиться при  построении
        буфера вырезанного  изображения  - это запрещение его возможности
        отмены. Объекты редактора Turbo Vision могут обычно отменять  са-
        мые последние  изменения  редактирования,  но  буфер  вырезанного
        изображения этого не поддерживает. Для запрета отмены нужно прос-

         B.Pascal 7 & Objects/TV#1    - 56 -

        то установить поле CanUndo в значение False.

             constructor TTutorApp.Init;
             var R: TRect;
             begin
               MaxHeapSize := 8192;
               inherited Init;
               Desktop^.GetExtent(R);           { получение границ окна }
               ClipboardWindow := New(PEditWindow, Init(R, '',
                                      wnNoNumber));
             if ValidView(ClipboardWindow) <> nil then  { убедиться, что
                                                  он работает }
             begin
               ClipboardWindow^.Hide;   { скрыть окно буфера вырезанного
                                          изображения }
               InsertWindow(CliopboardWindow); { включение скрытого окна
                                        буфера вырезанного изображения }
               Clipboard^.CanUndo := False; { буфер вырезанного
                              изображения не допускает операций отмены }
             end;
             end;

                   Примечание: ClipboardWindow - это новое поле в объекте
              TTutorApp.

               Вывод окна буфера вырезанного изображения на экран
        ─────────────────────────────────────────────────────────────────

             Теперь, когда  у вас есть буфер вырезанного изображения,  вы
        можете свободно вырезать и вставлять текст между окнами.  Но  что
        если вы хотите видеть или редактировать то, что находится в буфе-
        ре вырезанного изображения?  Окно буфера вырезанного  изображения
        скрыто, поэтому вам нужен способ его вывода.

             Стандартное меню Edit (Редактирование) включает в себя пункт
        'Show clipboard' ('Вывод буфера вырезанного изображения'),  кото-
        рый генерирует  команду cmClipShow.  В ответ на эту команду нужно
        вывести окно буфера вырезанного изображения:

             procedure TTutorApp.HandleEvent(var Event: TEvent);
             begin
               if Event.What = evCommand then
               begin
                 case Event.Command of
                   cmClipShow:
                     begin
                       cmClipBoardWindow^.Show;
                       ClearEvent(Event);
                     end;
                 .
                 .
                 .


         B.Pascal 7 & Objects/TV#1    - 57 -

             Если у вас есть другие открытые окна,  то  с  помощью  этого
        подхода вы заметите,  в чем проблема. Другие окна расположены пе-
        ред окном буфера вырезанного изображения.  Кроме того, это первое
        окно, включенное в оперативную область;  все другие окна открыва-
        лись "поверх" скрытого окна буфера вырезанного  изображения.  Эти
        слои видимых объектов называются Z-последовательностью.  Она поз-
        воляет группам знать,  какие объекты расположены  перед  другими,
        какие   окна   нужно  активизировать, при  использовании  команды
        Window│Next и т.д.

                   Примечание: О Z-последовательности подробнее рассказы-
              вается в Главе 8 "Отображаемые элементы".

             Решением здесь является расположение окна буфера вырезанного
        изображения перед его выводом перед другими элементами. Все види-
        мые объекты Turbo Vision наследуют методы Select,  которые вы мо-
        жете вызвать, чтобы сделать данный объект выделенным отображаемым
        подэлементом,  то есть расположенным в группе самым первым.  Если
        вы измените реакцию на cmClipShow и включите метод Select,  то он
        будет выглядеть следующим образом:

             procedure TTutorApp.HandleEvent(var Event: TEvent);
             begin
               if Event.What = evCommand then
               begin
                 case Event.Command of
                   cmClipShow:
                     with ClipBoardWindow^ do
                     begin
                       Select;
                       Show;
                       ClearEvent(Event);
                     end;
                 .
                 .
                 .

                   Примечание: Вывод окна буфера вырезанного  изображения
              на переднем разделе выполняет программа TUTOR05.PAS.



         B.Pascal 7 & Objects/TV#1    - 58 -

─────────────────────────────────────────────────────────────────────────
                    ГЛАВА 4. Использование потоков и ресурсов
        ─────────────────────────────────────────────────────────────────

             Теперь, когда  вы  обеспечили  реальную   работу   программы
        Tutorial, следующим  логичным шагом является возможность сохране-
        ния работы.  Используя потоки Turbo Vision для записи объектов на
        диск, вы  сможете сохранять состояние оперативной области и позд-
        нее ее восстанавливать.  Вы также увидите, как можно использовать
        для упрощения меню и строк состояния расширение потоков,  которое
        называется ресурсами.

             В следующих двух шагах данной главы мы рассмотрим:

             * Сохранение объектов на диске.

             * Восстановление объектов с диска.

             * Определение объектов в ресурсах.

             Шаг 6: Сохранение и восстановление оперативной области
        ─────────────────────────────────────────────────────────────────

             Чтобы сохранить вашу оперативную область в файле,  вам необ-
        ходим механизм для сохранения различных типов объектов. Кроме то-
        го, вам требуется записывать объекты оперативной области, различ-
        ные оконные объекты,  объекты редактирования и т.д., а затем счи-
        тывать их обратно.

             Turbo Vision  использует потоки для записи объекта в файл на
        диске или в память EMS.  Вместо интерпретации файла, как обычного
        файла Паскаля,  потоки представляют поток байт,  записываемых или
        считываемых последовательно.  Запись объекта в поток предусматри-
        вает сообщение потоку, какой вид объекта он получает, затем посы-
        лает описывающую объект информацию. При считывании объекта обрат-
        но  из  потока  вы сначала получаете вид объекта,  так что будете
        знать, как интерпретировать последующие байты.

             Как вы увидите на этом шаге,  использование потоков  намного
        проще, чем это звучит.  Сохранение и загрузка оперативной области
        предусматривает три шага:

             * Регистрацию объектов в потоках.
             * Сохранение оперативной области.
             * Загрузку оперативной области.

                              Регистрация в потоках
        ─────────────────────────────────────────────────────────────────

             Чтобы использовать в потоках объектные типы, вам нужно заре-
        гистрировать тип с помощью потоков Turbo  Vision.  Регистрация  -
        это способ  сообщения потоку,  с каким видом объекта ему придется

         B.Pascal 7 & Objects/TV#1    - 59 -

        иметь дело,  как его идентифицировать,  как считывать или записы-
        вать данные  объекта.  Регистрацию лучше выполнять в конструкторе
        приложения. Этим обеспечивается,  что доступ к потокам происходит
        только после регистрации объектов.

             Все модули Turbo Vision имеют процедуры, которые регистриру-
        ют их объекты для использования потоков.  Например,  чтобы  заре-
        гистрировать объекты   в   модуле   Editors,   вызывается   метод
        RegisterEditors. Сам объект оперативной области находится в моду-
        ле App,   так   что   вам   нужно  также  вызвать  RegisterApp  и
        RegisterViews. В следующем примере показано  новая  версия  конс-
        труктора приложения:

             constructor TTutorApp.Init;
             var R: TRect;
             begin
               MaxHeapSize := 8192;
               EditorDialog := StdEditorDialog;
               StreamError := @TutorStreamError;
               RegisterObjects;
               RegisterViews;
               RegisterEditors;
               RegisterApp;
               inherited Init;
               Desktop^.GetExtent(R);
               ClipBoardWindow := New(PEditWindow, Init(R, '', 0));
               if ValidView(ClipboardWindow) <> nil then
               begin
                 ClipboardWindow^.SetState(sfVisible, False);
                 InsertWindow(ClipboardWindow);
                 Clipboard := ClipboardWindow^.Editor;
                 Clipboard^.CanUndo := False;
               end;
             end;

             Это все,  что нужно сделать. Теперь Tutorial может использо-
        вать объектные типы из модулей Objects,  Views,  App и Editors  с
        потоками.

                           Отслеживание ошибок потоков
        ─────────────────────────────────────────────────────────────────

             Чтобы зарегистрировать объекты,  в приводимом ниже примере в
        прикладную программу  добавлено  средство обеспечения надежности.
        Переменная StreamError указывает на процедуру, которая вызывается
        потоком Turbo   Vision,  при  обнаружении  ошибки.  По  умолчанию
        StreamError имеет значение nil и поэтому никогда не вызывается. В
        Tutor06A значение  этому  указателю  присваивается таким образом,
        чтобы он указывал на процедуру TutorSteramError, которая сообщает
        об ошибке и выполняет останов:

             procedure TutorStreamError(var S: TStream); far;
             var ErrorMessage: String;

         B.Pascal 7 & Objects/TV#1    - 60 -

             begin
               case S.Status of
                 stInitError: ErrorMessage := 'Ошибка доступа к потоку';
                 stReadError: ErrorMessage :=
                                    'Невозможно инициализировать поток';
                 stWriteError: ErrorMessage :=
                                    'Невозможно расширить поток';
                 stGetError: ErrorMessage :=
                          'Чтение из потока незарегистрированного типа';
                 stPutError: ErrorMessage :=
                            'Запись в поток незарегистрированного типа';
               end;
               ClearScreen;                           { очистка экрана }
               PrintStr('Ошибка: ' + ErrorMessage); { вывод сообщения
                                                      об ошибке }
               Halt(Abs(S.Status));                { останов с ошибкой }
             end;

             TutorStreamError -  не очень "элегантный" обработчик ошибки,
        но он сообщает об обнаруженных в потоках ошибках.

                         Сохранение оперативной области
        ─────────────────────────────────────────────────────────────────

             Как вы видели в Шаге 4,  объект оперативной области является
        группой. Это означает,  что он является  отображаемым  элементом,
        который  работает с другими отображаемыми элементами.  Часть этой
        работы заключается в обеспечении записи в поток при записи  груп-
        пового объекта.  Эта возможность встроена в TGroup, так что когда
        вы записываете в поток любую группу,  убедитесь, что она вызывает
        наследуемый метод записи в поток.

             Чтобы сохранить оперативную область и все окна,  которую она
        содержит, вам нужно сделать следующее:

             * Открыть поток.

             * Сохранить объект оперативной области.

             * Закрыть поток.

             В данном случае, так как вы выполняете запись в файл, то мо-
        жете использовать  тип  TDosStream,  но лучшую производительность
        получите при использовании TBufStream -  буферизированной  версии
        TDosStream. Поток  DOS связывает поток Turbo Vision с файлом DOS,
        и буферизированный поток позволяет вам задать размер  буфера  для
        чтения с диска и записи на диск.

                             Запись объекта в поток
        ─────────────────────────────────────────────────────────────────

             Пункт Store Desktop (Сохранение  оперативной  области)  меню
        Options (Возможности)  в  программе  Tutorial  генерирует команду

         B.Pascal 7 & Objects/TV#1    - 61 -

        cmOptionsSave, поэтому вы должны расширить обработчик событий та-
        ким образом, чтобы он отвечал на cmOptionsSave вызовом нового ме-
        тода с именем SaveDesktop:

             procedure TTutorApp.HandleEvent(var Event: TEvent);
             begin
               inherited HandleEvent(Event);
               if Event.What = evCommand then
               begin
                 case Event.Command of
                     cmOptionsSave:
                        begin
                          SaveDasktop;
                          ClearEvent(Event);
                        end;
                         .
                         .
                         .
             end;

             procedure TtutorApp.SaveDesktop;
             var DesktopFile: TBufStream;
             begin
               DesktopFile.Init('DESKTOP.TUT', stCreate, 1024);
                                                        { открыть поток }
               DesktopFile.Put(Desktop);         { сохранение оперативной
                                                   области }
               DesktopFile.Done;                        { закрыть поток }
             end;

             SaveDesktop достаточно простой метод.  Он инициализирует бу-
        феризированный поток, связывая его с файлом DESKTOP.TUT и задавая
        ему буфер размером 1К. Использование константы stCreate указывает
        потоку  на  создание  нового  файла,  даже если он уже существует
        (аналогично процедуре Rewrite Паскаля).

             Запись всей оперативной области,  включая все ее  окна,  вы-
        полняется вызовом единственного метода - метода Put потока. Вызов
        метода Put записывает информацию об объекте в поток,  затем вызы-
        вает метод Store для записи объекта,  переданный в качестве пара-
        метра.

             Любой объект Turbo Vision,  который будет  использоваться  с
        потоками, должен иметь метод Store, записывающий информацию в по-
        ток  (и, как вы увидите в следующей части данного шага, соответс-
        твующий конструктор  Load).  Та как TDesktop является наследником
        TGroup, он записывает все включенные в него отображаемые  подэле-
        менты, включая фон и окна.

             Не вызывайте метод Store непосредственно.  Нужно указать по-
        току на запись объекта, и он будет вызывать в соответствующий мо-
        мент метод Store.


         B.Pascal 7 & Objects/TV#1    - 62 -

             Вызов метода Done потока сбрасывает буфер потока и закрывает
        соответствующий файл.

                    Сохранение буфера вырезанного изображения
        ─────────────────────────────────────────────────────────────────

             Теперь вы,  возможно, подумали: "Это не может быть настолько
        простым". Вы и правы, и нет. Это действительно просто, и метод из
        предыдущего примера будет сохранять оперативную область таким об-
        разом, что вы сможете позднее восстановить ее.  Но вы правы также
        в отношении других моментов, которые требуют рассмотрения.

             Как вы можете вспомнить, при создании окна буфера вырезанно-
        го изображения вы устанавливаете глобальную переменную  Clipboard
        таким образом,  чтобы она указывала на редактор окна буфера выре-
        занного изображения. К сожалению, если вы записываете окно буфера
        вырезанного изображения на диск,  а затем считываете его обратно,
        то этот указатель будет недействительным,  и невозможно  без  су-
        щественных усилий установить указатель так,  чтобы он ссылался на
        восстановленный редактор окна.

             Простым решением является исключение из операций  сохранения
        и загрузки буфера вырезанного изображения.  Кроме того, буфер вы-
        резанного изображения редко требуется сохранять между сеансами. В
        следующем примере  показан надежный способ сохранения оперативной
        области:

             procedure TTutorApp.SaveDesktop;
             var DesktopFile: TBufStream;
             begin
               DesktopFile^.Delete(ClipboardWindow); { удаление буфера из
                                                    оперативной области }
               DesktopFile.Init('DESKTOP.TUT', stCreate, 1024);
                                                  { открыть поток }
               DesktopFile.Put(Desktop);          { сохранение
                                                    оперативной области }
               DesktopFile.Done;                  { закрыть поток }
               InsertWindow(ClipboardWindow);     { восстановление окна
                                                    оперативной области }
             end;

                   Примечание: Сохранение  и  восстановление  оперативной
              области  без  буфера  вырезанного изображения выполняется в
              TUTOR06A.PAS.

             Исключение буфера вырезанного изображения из сохранения опе-
        ративной области по существу делает буфер вырезанного изображения
        частью прикладной программы, а не частью оперативной области, хо-
        тя управляет  им оперативная область. В следующем разделе мы вне-
        сем изменения для работы с буфером вырезанного изображения.

                       Восстановление оперативной области
        ─────────────────────────────────────────────────────────────────

         B.Pascal 7 & Objects/TV#1    - 63 -


             Восстановление оперативной  области по существу представляет
        собой операцию,  обратную ее сохранению, но здесь требуется осто-
        рожность. Вместо того,  чтобы просто считывать объект оперативной
        области и вызывать его в оперативную область,  вам следует выпол-
        нить проверку и убедиться, что это рабочий объект оперативной об-
        ласти. На данном шаге вы сделаете следующее:

             * Загрузка объекта из потока.

             * Обеспечение допустимости объекта.

             * Замена существующей оперативной области.

             Поскольку загрузка новой оперативной области влияет на  спо-
        соб работы вашей программы,  вам следует соблюдать особую предос-
        торожность, когда вы просто записываете объект оперативной облас-
        ти в поток. Важными шагами являются обеспечение допустимости заг-
        ружаемого объекта и аккуратная  замена  существующей  оперативной
        области.

                      Загрузка объекта оперативной области
        ─────────────────────────────────────────────────────────────────

             Шаги при загрузке объекта в точности соответствуют шагам  по
        ее сохранению:

             * Открытие потока.
             * Считывание объекта.
             * Закрытие потока.

             Исходный код  для считывания объекта оперативной области по-
        казан в следующем примере:

             DesktopFile.Init('DESKTOP.TUT', stOpenRead, 1024);
                                                      { открытие потока }
             TempDesktop := PDesktop(DesktopFile.Get);
                                        { получение оперативной области }
             DesktopFile.Done;                        { закрытие потока }

             В этом фрагменте  исходного кода стоит отметить два интерес-
        ных момента.  Во-первых,  загруженная  оперативная  область здесь
        присваивается временной переменной, а не самой переменой Desktop,
        так как  вы  не  хотите потерять старое значение Desktop в случае
        недопустимости вновь считанного объекта.  Кроме того, старое зна-
        чение Desktop  следует использовать для освобождения используемой
        памяти. Во-вторых, следует отметить использование метода Get. Get
        - это метод,  парный по отношению к Put,  который вы использовали
        для записи объекта в поток.

             Get считывает информацию, которую записывает Put, так что он

         B.Pascal 7 & Objects/TV#1    - 64 -

        знает, какой вид объекта загружается, и вызывает конструктор объ-
        екта Load для считывания объекта из потока.  Load - это конструк-
        тор, аналогичный Init, но вместо сохранения объекта на основе пе-
        реданных ему параметров,  Load строит объект и считывает его зна-
        чения из потока, переданного в качестве параметра.

             Отметим, что Get возвращает указатель типа Pobject,  поэтому
        вы должны привести тип результата к типу,  соответствующему  типу
        объекта. Так  как  вы считываете объект оперативной области,  тип
        возвращаемого Get указателя приводится к типу PDesktop.

                          Проверка допустимости объекта
        ─────────────────────────────────────────────────────────────────

             После получения  объекта  оперативной  области из потока вам
        нужно перед использованием объекта вместо  существующей оператив-
        ной области обеспечить допустимость объекта. Для этого вызывается
        один из методов приложения ValidView.

             ValidView возвращает указатель на объект, если объект допус-
        тимый, или nil в случае его недопустимости.  Перед этим он выпол-
        няет две важных проверки отображаемого элемента:

             * Во-первых, ValidView проверяет, что приложение при постро-
               ении объекта не превышает доступной памяти. Приложение ре-
               зервирует некоторую память в конце динамически распределя-
               емой области для буфера безопасности. Если при распределе-
               нии памяти (например,  при построении динамического объек-
               та)  превышается  граница  этого  буфера безопасности,  то
               ValidView возвращает значение nil.

             * Во-вторых,  ValidView вызывает метод  Valid  отображаемого
               элемента, который проверяет корректность построения объек-
               та.  Если Valid возвращает значение  False,  то  ValidView
               возвращает nil.

             После загрузки  объекта  из потока его лучше всего использо-
        вать после передачи ValidView:

                                 { загрузка объекта }
             if VlaidView(TempDesktop) <> nil then
                                 { замена Desktop TempDeskrtop }

                           Замена оперативной области
        ─────────────────────────────────────────────────────────────────

             После того как вы решите, что объект оперативной области яв-
        ляется допустимым,  можно выполнить замену существующей оператив-
        ной области.  Замена оперативной области предусматривает пять ша-
        гов:

             * Удаление из приложения оперативной области.


         B.Pascal 7 & Objects/TV#1    - 65 -

             * Уничтожение старого объекта оперативной области.
             * Установку переменной Desktop.
             * Включение новой оперативной области.
             * Позиционирование оперативной области.

             Удаление старой оперативной области и уничтожение объекта  -
        это важные  шаги.  Помните  о том,  что приложение также является
        группой и содержит указатель на объект оперативной области в  ка-
        честве одного из отображаемых элементов,  которыми оно управляет.
        Если вы уничтожите этот объект без удаления его из объекта прило-
        жения, то  объект приложения будет уничтожать старый отображаемый
        элемент при завершении своей работы,  что приведет к ошибке этапа
        выполнения. После  удаления  старой оперативной области вы можете
        благополучно уничтожать ее:

             Delete(Desktop);  { удаление оперативной области из объекта
                                 приложения }
             Dispose(Desktop, Done); { уничтожение старой оперативной
                                 области }

             После успешного устранения старой оперативной области вы мо-
        жете теперь включить новую оперативную область:

             Desktop := TempDesktop;
             Insert(Desktop);

             Последнее не является очевидным,  если вы не меняли видеоре-
        жим между моментом сохранения оперативной области и  моментом  ее
        загрузки. Так как все размеры и позиции сохраненного объекта опе-
        ративной области и все окна,  которые он  содержит,  основаны  на
        размере приложения,  вам необходимо,  чтобы они были настроены на
        текущий  размер.  Восстановление  оперативной  области  43-   или
        50-строчного приложения на 25-строчном экране означает потерю ин-
        формации.

             К счастью,  легко  установить  границы оперативной области в
        соответствии с текущим отображаемым элементом приложения,  а опе-
        ративная область позаботится об изменении размером окон:

             GetExtent(R);         { получить границы приложения }
             R.Grow(0, -1);        { допускается для полосы меню и строки
                                     состояния }
             Desktop^.Locate(R);   { устанавливает границы оперативной
                                     области }

             Последним заслуживающим  рассмотрения моментом является окно
        буфер вырезанного изображения.  Так как вы исключили его при сох-
        ранении оперативной области, вам нужно сделать это также при заг-
        рузке новой оперативной области. Перед тем как избавиться от ста-
        рой оперативной области, не забудьте удалить окно буфера вырезан-

         B.Pascal 7 & Objects/TV#1    - 66 -

        ного изображения и включить его при установке  новой  оперативной
        области.

             Полный метод LoadDesktop показан в следующем примере:

             procedure TTutorApp.LoadDesktop;
             var
               DesktopFile: TBufStream;
               TempDesktop: PDesktop;
               R: TRect;
             begin
               DesktopFile.Init('DESKTOP.TUT', stOpenRead, 1024);
               TempDesktop := PDesktop(DesktopFile.Get);
               Desktop := PDesktop(DesktopFile.Get);
               DesktopFile.Done;
               if VelidView(TempDesktop) <> nil then
               begin
                 Desktop^.Delete(ClipboardWindow);
                 Delete(Delete);
                 Dispose(Desktop, Done);
                 Desktop := TempDesktop;
                 Insert(Desktop);
                 GetExtent(R);
                 R.Grow(0, -1);
                 Desktop^.Locate(R);
                 InsertWindow(ClipboardWindow);
               end;
             end;

                          Шаг 7: Использование ресурсов
        ─────────────────────────────────────────────────────────────────

             Ресурсы представляют собой удобный способ определения  неко-
        торых визуальных элементов вашей программы.  Кроме того, они дают
        то преимущество,  что вам не нужно включать в свою программу  код
        инициализации.

             На данном шаге вы будете делать с ресурсами следующее:

             * Создание файла ресурса.
             * Загрузка из файла ресурса полосы меню.
             * Загрузка из файла ресурса строки состояния.
             * Загрузка из файла ресурса окна About.

             Как вы  видели  в  Шаге 2,  исходный код построения объектов
        строки состояния и полосы меню может  быть  весьма  запутанным  и
        включать в себя многочисленные вложенные вызовы функций. Одним из
        способов избавления вашей программы от сложностей такого рода яв-
        ляется построение этих объектов из ресурсов.


         B.Pascal 7 & Objects/TV#1    - 67 -

                             Создание файла ресурса
        ─────────────────────────────────────────────────────────────────

             Перед загрузки в свои программы объектов из  файла  ресурсов
        вы должны иметь файл ресурса из которого  будете  его  загружать.
        Одним из достоинств ресурсов является то,  что вашей программе не
        важно,  откуда поступают ресурсы - она просто считывает объекты и
        использует их.  Аналогично,  программе не важно,  что находится в
        ресурсе.  Например,  когда вы загружаете полосу  меню,  программа
        просто  получает указатель на объект полосы меню.  Ваша программа
        не знает, сколько пунктов содержит меню, в каком порядке они сле-
        дуют, и какие связаны с ними команды.

             В некоторой точке вашу программу и ресурсы необходимо скоор-
        динировать.  Кроме того,  бессмысленно загружать ресурсы,  только
        генерирующие команды,  на которые не отвечает программа.  Ресурсы
        дают вам гибкость определения структуры меню (разметки диалогово-
        го окна и др.) вне программы. Это означает, что вы можете модифи-
        цировать ресурсы и интерфейс с пользователем, не меняя программы.

                             Что такое файл ресурса?
        ─────────────────────────────────────────────────────────────────

             Файлы ресурсов тесно связаны с потоками.  Фактически,  файлы
        ресурсов используют  потоки  для  хранения и считывания объектов.
        Основное различие между ними с точки зрения программы  состоит  в
        том, что файл ресурса позволяет вам именовать записываемые объек-
        ты и считывать их в любом порядке. При инициализации файла ресур-
        са вы передаете ему поток, который содержит его объекты. Файл ре-
        сурса сам поддерживает индекс, отслеживающий имена и расположение
        всех объектов.

             В файл ресурса, как и в поток, вы можете записать любой объ-
        ект Turbo Vision. Поскольку файл ресурса имеет в своей основе по-
        ток, вам нужно обеспечить регистрацию всех объектных типов, кото-
        рые вы считываете или записываете как ресурсы.

                             Запись ресурсов в файл
        ─────────────────────────────────────────────────────────────────

             Запись объекта в виде ресурса почти полностью аналогична за-
        писи его в поток, только для него требуется задать имя. Предполо-
        жим, например,  что у вас есть полоса меню с именем MyMenu, кото-
        рую вы хотите записать в файл ресурса с  именем  'MAINMENU'.  Это
        будет выглядеть следующим образом:

             var
               ResFile: TResourceFile;
               MyMenu: PMenuBar;

             begin
               MyMenu := ...                { инициализация полосы меню }
               ResFile.Init(New(PBufSteram, Init('File.Ext', stCreate,

         B.Pascal 7 & Objects/TV#1    - 68 -

                             10-24)));
               ResFile.Put(MyMenu, 'MAINMENU');        { запись ресурса }
               ResFile.Done;        { отмена файла ресурса и его потока }
             end;

             В данном примере ресурсы содержатся в буферизированном пото-
        ке, но вы можете использовать любой вид потока. Часто при наличии
        большого файла  ресурса весь этот файл для более быстрого доступа
        копируется в поток EMS или поток памяти.

             Файл TUTRES.PAS на дистрибутивных дисках содержит программу,
        создающую файл  ресурса,  который  содержит  ресурсы полосы меню,
        строки состояния и окна About (они будут использоваться в следую-
        щих трех этапах).

                          Загрузка ресурса полосы меню
        ─────────────────────────────────────────────────────────────────

             Загрузка любого объекта  из  файла  ресурса  предусматривает
        следующие три шага:

             * Открытие файла ресурса.

             * Загрузку объекта.

             * Закрытие файла ресурса.

             Если из  одного  и  того же файла ресурса вы загружаете нес-
        колько объектов,  то файл ресурса обычно открывается только  один
        раз, из  него считываются все объекты,  а затем файл закрывается.
        Если вашей прикладной программе требуется  считывать  объекты  из
        файла ресурса на различных этапах работы,  можно открыть файл ре-
        сурса при инициализации программы и закрыть  его  при  завершении
        работы.

                             Открытие файла ресурса
        ─────────────────────────────────────────────────────────────────

             Программе Tutorial доступ к ресурсам требуется  в  различные
        моменты работы.  Полоса меню и строка  состояния  устанавливаются
        при  инициализации  прикладной  программы,  но пользователь может
        вызвать информационное окно About в любой момент, так что доступ-
        ность  файла  ресурсов необходима в любое время.  Лучшим решением
        здесь является открытие файла ресурса в конструкторе объекта при-
        ложения и закрытие его в деструкторе приложения.

             Поскольку некоторые шаги зависят от других, уже выполненных,
        очень важен  порядок  операторов  в конструкторе.  Следующие шаги
        должны выполняться в указанном порядке:

             1. Регистрация потока.

             2. Инициализация файла ресурса.

         B.Pascal 7 & Objects/TV#1    - 69 -


             3. Инициализация приложения.

             Так как вы хотите убедиться в том,  что вы можете  загрузить
        ресурс в любой момент после открытия файла ресурса, вам нужно за-
        регистрировать объекты перед открытием файла ресурса. Файл ресур-
        са нужно открыть перед вызовом наследуемого конструктора приложе-
        ния, так как он будет вызывать виртуальные методы  InitMenuBar  и
        InitStatusLine, которые  вы собираетесь модифицировать для считы-
        вания из файла ресурса.

             В приведенном ниже примере показан модифицированный для ини-
        циализации файла ресурса TUTORIAL.TVR конструктор TTutorApp:

             var ResFile: TResourceFile;
                  .
                  .
                  .
             constructor TTutorApp.Init;
             begin
               MaxHeapSize := 8192;
               RegisterMenus;         { регистрация объектов с потоками }
               RegistgerView;
               RegisterEditors;
               RegisterDialogs;
               RegisterApps;
               ResFile.Init(New(PBufStream, Init('TUTORIAL.TVR',
                                                 { инициализация потока }
                          stOpenRead, 1024)));   { открытие для чтения,
                                                   буфер 1К }
               inherited Init;       { инициализация объекта приложения }
                   .
                   .
                   .
             end;

                          Загрузка ресурса полосы меню
        ─────────────────────────────────────────────────────────────────

             Инициализация полосы меню из файла ресурса выполняется  ана-
        логично ее   созданию:   вы   переопределяете  виртуальный  метод
        InitMenuBar, но вместо вызова всех вложенных функцию для создания
        пунктов меню  и подменю вы загружаете объект меню из файла ресур-
        са. Ниже показана модификация метода InitMenuBar для загрузки ре-
        сурса меню с именем 'MAINMENU' из файла ресурса:

             procedure TTutorApp.InitMenuBar;
             begin
               MenuBar := PMenuBar(ResFile.Get('MAINMENU'));
             end;

             Это все. Объект полосы меню, загруженный из ресурса, функци-
        онирует точно также как создаваемый вами.  В этом фрагменте пред-

         B.Pascal 7 & Objects/TV#1    - 70 -

        полагается, что ресурс полосы меню создавался с  соответствующими
        границами. Поскольку все видеорежимы, поддерживаемые в данный мо-
        мент Turbo Vision, имеют одну и ту же ширину экрана, это не долж-
        но вызывать проблем. Когда вы загружаете ресурс строки состояния,
        то нужно выполнить настройку для различных позиций на экране.

             Как и в случае потоков,  метод Get файла ресурса  возвращает
        указатель на тип PObject.  Вам нужно привести тип этого указателя
        к типу, соответствующему загружаемому объекту.

                             Закрытие файла ресурса
        ─────────────────────────────────────────────────────────────────

             Закрытие и  отмена  файла  ресурса  выполняется деструктором
        объекта файла ресурса. Так как вы инициализировали файл ресурса в
        конструкторе приложения,  вам  следует  отменить  файл  ресурса в
        деструкторе приложения:

             destructor TTutorApp.Done;
             begin
               ResFile.Done            { сброс и закрытие файла ресурса }
               inherited Done;         { уничтожение объекта приложения }
             end;

                        Загрузка ресурса строки состояния
        ─────────────────────────────────────────────────────────────────

             Загрузка из  файла ресурса объекта строки состояния выполня-
        ется аналогично загрузке полосы меню.  Поскольку в последнем раз-
        деле мы  добавили  исходный код для открытия и закрытия файла ре-
        сурса, вам не нужно повторять этого, поэтому мы сосредоточимся на
        двух шагах:

             * Загрузка объекта строки состояния.

             * Настройка позиции строки состояния.

                        Загрузка объекта строки состояния
        ─────────────────────────────────────────────────────────────────

             Загрузка объекта строки состояния из файла ресурса  выполня-
        ется аналогично загрузке полосы меню, но вам нужно задать имя ре-
        сурса строки состояния:

             procedure TTutorApp.InitStatusLine;
             begin
               StatusLine := PStatusLine(ResFile.Get('STATUS'));
             end;

             В примере полосы меню можно предполагать,  что ресурс полосы
        меню создан таким образом,  что занимает  верхнюю  строку  экрана
        (поскольку там всегда находятся меню, и верхние строки меню имеют
        одни и те же границы). Но поскольку в различных видеорежимах ниж-

         B.Pascal 7 & Objects/TV#1    - 71 -

        няя строка занимает различные позиции,  неразумно  полагать,  что
        строка состояния автоматически имеет допустимые границы. В следу-
        ющем разделе вы настроите границы загруженной  строки  состояния,
        чтобы поместить ее на последнюю строку экрана приложения.

                       Настройка позиции строки состояния
        ─────────────────────────────────────────────────────────────────

             При создании объекта строки состояния на Шаге 2 вы обеспечи-
        вали вывод  строки  состояния всегда на последней строке приложе-
        ния, считывая границы приложения  и  устанавливая  соответственно
        относительные границы строки состояния.  Единственное отличие при
        загрузке строки состояния из ресурса состоит в том,  что вы наст-
        раиваете ее  позицию после загрузки,  а не устанавливаете позицию
        при создании объекта.  Метод,  однако,  будет тем же. Он даст вам
        представление о том, как изменить позицию существующих отображае-
        мых элементов.

             В следующем примере показаны два альтернативных способа  по-
        зиционирования строки состояния на последнюю строку экрана:

             procedure TTutorApp.InitStatusLine;
             var R: TRect;
             begin
               StatusLine := PStatusLine(ResFile.Get('STATUS'));
               GetExtent(R);
               StatusLine^.MoveTo(0, R.B.Y -1);
             end;

             procedure TTutorApp.InitStatusLine;
             var R: TRect;
             begin
               StatusLine := PStatusLine(ResFile.Get('STATUS'));
               GetExtent(R);
               R.A.Y :=  R.B.Y - 1;
               StatusLine^.Locate(R);
             end;

             Ни один из этих подходов не имеет особых  преимуществ  перед
        другим. Фактически,  MoveTo  задает прямоугольник на основе пере-
        данных координат и размера отображаемого элемента,  а затем вызы-
        вает Locate, так что эти два метода почти идентичны.

                   Загрузка ресурса информационного окна About
        ─────────────────────────────────────────────────────────────────

             Общепринятым использованием  ресурсов  является  определение
        сложных диалоговых окон. Окно About, которое вы определили в Шаге
        3 путем вызова MessageBox,  достаточно ограничено.  Вы не  можете
        определить заголовок  окна  и  можете передать в него только одну
        строку текста.  В данном разделе вы будете создавать более  инте-
        ресное окно About и сохранять его в ресурсе.


         B.Pascal 7 & Objects/TV#1    - 72 -

             Использование диалогового окна предусматривает следующие три
        шага:

             * Определение ресурса диалогового окна.

             * Загрузка ресурса диалогового окна.

             * Выполнение диалогового окна.

                      Определение ресурса диалогового окна
        ─────────────────────────────────────────────────────────────────

             Как и  любой другой ресурс Turbo Vision,  ресурс диалогового
        окна - это просто записанный в поток именованный объект,  так что
        для создания  ресурса диалогового окна вам требуется сначала соз-
        дать объект диалогового окна.  Поскольку созданию диалоговых окон
        будут посвящены шаги 7 и 8, мы не будем здесь вдаваться в детали.
        Вам достаточно пока знать,  что диалоговое окно является группой,
        в которую включаются все другие отображаемые элементы, называемые
        управляющими элементами. Управляющие элементы - это специализиро-
        ванные отображаемые элементы,  с которыми взаимодействует пользо-
        ватель, такие как командные кнопки, блоки списка и кнопки с неза-
        висимой фиксацией.

             Чтобы создать  объект диалогового окна (или объект управляю-
        щего элемента для включения в диалоговое окно), вам нужно сделать
        следующее:

             - задать  границы диалогового окна (или управляющего элемен-
               та);

             - построить объект;

             - включить управляющий элемент или записать  диалоговый  ре-
               сурс.

             В следующем примере показан исходный код для создания нового
        окна About и его управляющих элементов:

             R.Assign(0, 0, 40, 11);  { задать границы диалогового окна }
             AboutBox := New(PDialog, Init(R, 'About Tutorial'));
                                      { построить его }
             with AboutBox^ do
             begin
               Options := Options or ofCentered;  { обеспечить его
                                         центрирование }
               R.Assign(4, 2, 36, 4);  { задать границы статического
                                         текста }
               Insert(New(PStaticText, Init(R,
                  { построить статический текстовый управляющий элемент }
                     #3'Turbo Vision'#13#3'Tutorial program')));
                                       { с данным текстом }
               R.Assign(4, 5, 36, 7);  { установить границы второго

         B.Pascal 7 & Objects/TV#1    - 73 -

                                         статического текста }

               Insert(New(PStaticText, Init(R,
                  { построить статический текстовый управляющий элемент }
                     #3'Copyright 1992'#13#3'Borland International')));
               R.Assign(15, 8, 25, 10);  { установить границы
                                           командной кнопки OK }
               Insert(New(PButton, Init(R, 'O~k~', cmOk, bfDefault)));
             end;
             ResFile.Put(AboutBox, 'ABOUTBOX'); { записать диалог в файл
                                           ресурса }

             Как вы видели при записи в поток оперативной области,  груп-
        повые объекты  сохраняют все отображаемые элементы,  которыми они
        управляют, поэтому  запись диалогового окна автоматически  приво-
        дит к записи всех включенных в него управляющих элементов.  Когда
        вы загружаете окно About из ресурса,  оно автоматически загружает
        все свои управляющие элементы.

             Когда вы вызываете метод Put файла ресурса,  то задаете объ-
        ект, который хотите записать,  и имя этого ресурса.  Это  имя  вы
        позднее будете использовать для загрузки ресурса с помощью Get. В
        приведенном выше примере диалоговое  окно  AboutBox  записывается
        под именем 'ABOUTBOX'.

                        Загрузка ресурса диалогового окна
        ─────────────────────────────────────────────────────────────────

             Загрузка ресурса диалогового окна аналогична загрузке любого
        другого ресурса,  так  что она должна выглядеть для вас знакомой.
        Все, что вам нужно сделать - это вызов метода Get  объекта  файла
        ресурса и  передача  ему  имени  вашего ресурса диалогового окна.
        Поскольку Get возвращает общий указатель PObject,  вам, возможно,
        потребуется преобразовать этот указатель в тип PDialog:

             MyDialog := PDialog(ResFile.Get('MYDIALOG'));

                   Примечание: Перед загрузкой диалогового окна из потока
              или ресурса не забудьте вызвать RegisterDialogs.

             Во многих случаях,  как вы увидите в следующем разделе,  вам
        даже не потребуется присваивать указатель переменной.

                           Выполнение диалогового окна
        ─────────────────────────────────────────────────────────────────

             Чтобы выполнить свое диалоговое окно, используйте тот же ме-
        тод ExecuteDialog объекта приложения, который вы применяли на Ша-
        ге 4  для выполнения стандартного диалогового окна открытия  фай-
        ла:

         B.Pascal 7 & Objects/TV#1    - 74 -


             procedure TTutorApp.DoAboutBox;
             begin
               ExecuteDialog(PDialog(ResFile.Get('ABOUTBOX')), nil);
             end;

                   Примечание: Выполнение специализированного диалогового
              окна осуществляет программа TUTOR07.PAS.

             Так как Get выделяет память и возвращает указатель на нее, а
        ExecuteDialog уничтожает диалоговое окно  после  его  выполнения,
        вам не требуется присваивать чему-либо указатель диалогового окна
        About, что делает DoAboutBox очень простым методом.



         B.Pascal 7 & Objects/TV#1    - 75 -

─────────────────────────────────────────────────────────────────────────
                       ГЛАВА 5. Создание окон ввода данных
        ─────────────────────────────────────────────────────────────────

             До сих пор все используемые  вами  объекты,  за  исключением
        объекта приложения,  который был существенно расширен, были стан-
        дартными объектами Turbo Vision.  Это дало  вам  представление  о
        возможностях Turbo Vision,  но в некоторых случаях вы определенно
        захотите создавать свои собственные объекты.  В данной  главе  мы
        рассмотрим следующие вопросы:

             * Создание окна ввода данных.
             * Использование объектов управляющих элементов.
             * Проверка допустимости введенных данных.

             В следующих нескольких шагах вы реализуете простую складскую
        систему для сферы малого бизнеса.  Эта  программа  реально  может
        быть не  особенно полезной,  но иллюстрирует множество принципов,
        используемых в прикладных программах Turbo Vision.

                        Шаг 8: Создание окна ввода данных
        ─────────────────────────────────────────────────────────────────

             Ввод данных  обычно имеет место в диалоговом окне.  В данном
        примере создаваемые вами диалоговое окно не будет  режимным,  как
        те, которые вы до сих пор использовали. Вместо того, чтобы выпол-
        нять его (что сделает окно модальным),  вы включаете его, как это
        делается с  другими  окнами.  Диалоговое  окно Turbo Vision - это
        просто специализированный вид окна, а тип TDialog является потом-
        ком TWindow.

             Создание экрана ввода данных подразделяется на три части:

             * Создание нового оконного типа.
             * Предотвращение дублирования окон.
             * Добавление в окно управляющих элементов.



         B.Pascal 7 & Objects/TV#1    - 76 -

                          Создание нового оконного типа
        ─────────────────────────────────────────────────────────────────

             Поскольку в свои окна ввода данных  вам  необходимо  вводить
        ряд модификаций, для такого окна вам потребуется определить новый
        объектный тип,  который называется TOrderWindow. Поскольку прило-
        жению требуется отслеживать окно заказа,  вы будете задавать объ-
        екту приложения указатель на объект окна заказа.

        ┌─[*]─────────────────────── Orders ────────────────────────────┐
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒Order #:▒▒            ▒▒▒Date of order: ▒▒▒               ▒▒▒│
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒Stock #:▒▒            ▒▒▒Quantity ordered:▒▒              ▒▒▒│
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒Payment method:▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒                                                           ▒▒│
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒      R             ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒Notes:▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒                                                           ▒▒│
        │▒▒                                                           ▒▒│
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒▒▒██New████▒▒▒▒▒██Save███▒▒▒▒▒██Cancel█▒▒▒▒▒██Next███▒▒▒▒▒▒▒▒│
        │▒▒▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒│
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        └───────────────────────────────────────────────────────────────┘

             Рис. 5.1 Законченное окно ввода заказов.

             Order # - номер заказа; Date of order - дата заказа; Stock #
        - артикул;  Quantity ordered - объем заказа; Payment method - ха-
        рактер оплаты;  Notes - примечания;  New - новый; Save - сохране-
        ние; Cancel - отмена; Next - следующий.

             Для команды меню cmOrderWin вы добавите метод реакции,  свя-
        занный с  пунктом Examine (Проверка) меню Orders (Заказы).  Когда
        вы выбираете Orders│Examine,  то хотите вывести всплывающее  окно
        ввода заказов,  поэтому нужно научить прикладную программу ее об-
        рабатывать. Данные изменения показаны в следующем примере:

             type
               POrderWindow = ^TOrderWindow;
               TOrderWindow = object(TDialog)  { окно заказа - это
                                                 диалоговое окно }
                 constructor Init;
             end;

             TTutorApp = object(TApplication)
                ClipboardWindow: PEditWindow;

         B.Pascal 7 & Objects/TV#1    - 77 -

                OrderWindow: POrderWindow;     { задать указатель для
                                                 окна заказов }
                    .
                    .
                    .
                procedure OpenOrderWindow;
             end;

             constructor TOrderWindow.Init;
             var R: TRect;
             begin
               R.Ass gn(0, 0, 60, 17);          { присвоить границы }
               inherited Init(R, 'Orders'); { построить диалоговое окно }
               Options := Options or ofCentered; { обеспечить
                                                   центрирование }
               HelpCtx := $F000;            { задать содержимое
                                              справочного контекста }
             end;

             procedure TtutorApp.HandleEvent(var Event: TEvent);
             begin
               inherited HandleEvent(Event);
               if Event.What = evCommand then
                   cmOrderWin: OpenOrderWindow;   { открыть окно заказа }
                      .
                      .
                      .
             end;

             procedure TTutorApp.OpenOrderWindow;
             begin
               OrderWindow := New(POrderWindow, Init); { создание нового
                                                         экземпляра }
               InsertWindow(OrderWindow);   { включить его в оперативную
                                              область }
             end;

             В остальной части данного шага и в следующем вы  добавите  к
        TOrderWindow новые возможности.

             Если вы  теперь  запустите программу,  то заметите несколько
        изменений. Во-первых,  если вы выбираете Orders│Examine, диалого-
        вое окно  с  заголовком 'Orders' выводится в середине оперативной
        области. Установка бита ofCentered в поле Options окна  обеспечи-
        вает центрирование окна в оперативной области.

                   Примечание: Флаги  Options поясняются в Главе 8 "Отоб-
              ражаемые элементы".

             Как вы можете заметить,  при выводе диалогового окна  строка
        состояния изменяется. Это связано с тем, что TOrderWindow изменя-
        ет текущий контекст подсказки (с помощью поля HelpCtx). Поскольку
        на Шаге 2 вы задали отдельное определение состояния для контекста

         B.Pascal 7 & Objects/TV#1    - 78 -

        подсказки $F000...$FFFF, вывод отображаемого элемента, устанавли-
        вающего контекст подсказки в этом диапазоне,  автоматически выво-
        дит соответствующую строку состояния. Если вы закрываете окно за-
        казов, то  строка состояния изменяется на прежнюю,  так как соот-
        ветственно изменяется контекст подсказки.

                            Ограничение открытия окна
        ─────────────────────────────────────────────────────────────────

             Что произойдет,  если вы выберете команду Orders│Examine при
        уже открытом окне заказов?  OpenOrderWindow назначает OrderWindow
        новое окно заказов и включает его в оперативную область. Теперь у
        вас два окна заказов, которыми может свободно управлять оператив-
        ная область.  Однако объект приложения знает только  о  последнем
        окне.  Это может вызвать проблемы при обслуживании складской сис-
        темы, поэтому нужно обеспечить запрет открытия окна заказов, если
        такое  окно уже открыто.  Вместо этого окно выводится на передний
        план.

             Один из подходов к решению данной проблемы состоит в провер-
        ке OrderWindow  и  присваивании  нового окна только в том случае,
        если это не nil.  Это возлагает на вас  некоторую  дополнительную
        ответственность, так как вы должны обеспечить,  чтобы при отсутс-
        твии допустимого окна заказов OrderWindow всегда  имела  значение
        nil. Простое решение состоит в том, чтобы позволить окну и прило-
        жению самим обрабатывать эту ситуацию.

                               Передача сообщений
        ─────────────────────────────────────────────────────────────────

             Более надежный способ состоит в том,  чтобы определить нали-
        чие открытого окна заказов таким образом, чтобы окно само сообща-
        ло об  этом.  Turbo Vision предоставляет вам возможность посылать
        отображаемым элементам сообщения. Сообщения - это специальные со-
        бытия, во многом аналогичные командам,  которые доставляют инфор-
        мацию конкретному объекту отображаемого элемента и позволяют  по-
        лучающему сообщение  отображаемому  элементу  передать информацию
        обратно.  В данном случае вы используете сообщение оповещения, то
        есть  сообщение,  которое  получатель  посылает  каждому из своих
        отображаемых подэлементов. Определив специальное сообщение, кото-
        рое способны обрабатывать только окна заказов, вы сможете опреде-
        лить по наличию ответа существование окна заказов.

             Передать сообщение несложно.  Вы вызываете функцию с  именем
        Message, передавая ей указатель на получателя, некоторую информа-
        цию о сообщении и указатель на данные,  которыми вы можете сопро-
        вождать сообщение.  Message возвращает значение nil, если нет от-
        вечающих на сообщение отображаемых элементов,  или  указатель  на
        отображаемый элемент, который обрабатывает событие сообщение.

             В следующем  примере  показана передача сообщение оповещения
        объекту оперативной области,  который будет затем передавать  его
        всем управляемым им окнам.  Если одно из них отвечает,  вы можете

         B.Pascal 7 & Objects/TV#1    - 79 -

        быть уверены в том,  что это окно заказов,  и вывести  с  помощью
        вызова Select данное окно на переднем плане.

             procedure TTutorApp.OpenOrderWindow;
             begin
               if Message(Desktop, evBroadcast, cmFindOrderWindow, nil) =
                          nil then
               begin
                 OrderWindow := New(POrderWindow, Init);
                 Application^.InsertWindow(OrderWindow);
               end
               else
                 if PView(OrderWindow) <> Desktop^.TopView then  { если
                                            окна еще нет }
                     OrderWindow^.Select; { вывести окно на переднем
                                            плане }
             end;

                              Реакция на сообщения
        ─────────────────────────────────────────────────────────────────

             Поскольку сообщения просто представляют собой события, реак-
        ция на сообщения аналогична реакции на другие события.  В  данном
        случае вы знаете,  что вы хотите,  чтобы окно заказов отвечало на
        сообщение оповещения,  содержащее команду cmFindOrderWindow,  так
        что вы задаете для объекта окна заказов метод HandleEvent,  кото-
        рый знает, как отвечать на это:

             procedure TOrderDialog.HandleEvent(var Event: TEvent);
             begin
               inherited HandleEvent(Event);  { обработать все обычные
                                                диалоговые события }
               if (Event.What = evBroadcast) and { найти оповещение ...
                  (Event.Command = cmFindOrderWindow) then { ... по
                                                этой команде }
                  ClearEvent(Event);
             end;

                   Примечание: Реакцию на сообщение оповещения  реализует
              программа TUTOR08B.PAS.

             Все что требуется в реакции на сообщение - это очистка собы-
        тия. Кроме пометки события как обработанного, ClearEvent устанав-
        ливает поле  InfoPtr записи события в адрес отображаемого элемен-
        та, которые вызывает ClearEvent,  а Message возвращает событие из
        InfoPtr. Поэтому,  если вам нужно знать, какой отображаемый  эле-
        мент ответил  на  сообщение,  вы  можете  проверить  возвращаемое
        Message значение.

             В данном случае вы знаете, что окно отвечает (если какой-ли-
        бо объект делает это), поскольку целью данного шага является пре-
        дохранение вас от создания более одного окна заказа. Если Message
        возвращает значение nil,  это означает,  что ни один отображаемый

         B.Pascal 7 & Objects/TV#1    - 80 -

        элемент не обрабатывает оповещение, поэтому в оперативной области
        нет окна заказов.  Отличное от nil значение указывает на  наличие
        окна заказов,  поэтому  его следует поместить перед всеми другими
        окнами оперативной области.

                     Добавление в окно управляющих элементов
        ─────────────────────────────────────────────────────────────────

             Чтобы использовать  созданное  вами  окно ввода данных,  вам
        нужно задать для него поля ввода данных. Эти поля состоят из раз-
        личного вида управляющих элементов Turbo Vision. Управляющие эле-
        менты - это  специализированные  отображаемые  элементы,  которые
        позволяют пользователям манипулировать данными в диалоговом окне,
        такими как командные кнопки,  кнопки с  независимой  фиксацией  и
        строки ввода.

             Добавление управляющих  элементов требует следующих трех ша-
        гов:

             * Добавления поля к объекту диалогового блока (не обязатель-
               но).

             * Установка границ управляющего элемента.

             * Включение управляющего элемента.

                            Добавление полей объекта
        ─────────────────────────────────────────────────────────────────

             Перед фактическим созданием  объекта  управляющего  элемента
        вам нужно рассмотреть,  потребуется ли вам позднее непосредствен-
        ный доступ к нему.  В режимном диалоговом окне в этом обычно  нет
        необходимости, поэтому вы редко присваиваете в нем поля управляю-
        щего элемента. В безрежимном диалоговом окне, каким является окно
        заказов,  вам может потребоваться считывать и устанавливать конк-
        ретный управляющий элемент, пока диалоговое окно открыто, поэтому
        ему может потребоваться присвоить поля.

             В Шаге  9 вы увидите способы установки и считывания значений
        всех управляющих элементов вместе.  Возможны ситуации,  когда вам
        потребуется доступ к отдельным управляющим элементам,  так что вы
        часто будете создавать в своих диалоговых объектах поля для конк-
        ретных управляющих элементов.

                          Установка границ и включение
        ─────────────────────────────────────────────────────────────────

             Построение объектов управляющих элементов аналогично постро-
        ению других  отображаемых  элементов,  которое вы уже видели.  Вы
        присваиваете управляющему элементу прямоугольник с границами, вы-
        зываете конструктор  объекта  и включаете полученный в результате
        объект в объект диалогового окна.  В некоторых случаях это  можно
        выполнить в одном операторе,  но в других случаях вам потребуется

         B.Pascal 7 & Objects/TV#1    - 81 -

        поддерживать временный указатель на объект,  так что  вы  сможете
        связать с данным управляющим элементом другой управляющий элемент
        (обычно объект метки).

             В следующем примере показан исходный код  для  добавления  к
        диалоговому окну  поля  ввода с соответствующей меткой.  Заметим,
        что управляющие элементы метки требуют только одного оператора, в
        то  время  как для объекта строки ввода необходимы дополнительные
        шаги (так как вам нужно хранить указатель на него, который вы мо-
        жете передавать конструктору метки).

             constructor TOrderWindow.Init;
             var
               R: TRect;
               Field: PInputLine;              { временная переменная для
                                                 полей ввода }
             begin
               R.Assign(0, 0, 60, 17);
               inherited Init(R, 'Orders');
               Options := Options or ofCentered;
               HelpCtx := $F000;

               R.Assign(13, 2, 23, 3);         { установка границ для поля
                                                 ввода }
               Field := New(PInputLine, Init(R, 8)); { построить его }
               Insert(Field);               { включить в диалоговое окно }
               Insert(New(PLabel, Init(R, '~O~rder #:', Field)));
                                 { построение и включение, связь с полем }
             end;

             Следующий пример показывает полную инициализацию окна  ввода
        данных:

             constructor TOrderWindow.Init;
             var
               R: TRect;
               Field: PInputLine;
               Cluster: PCluster;
               Memo: PMemo;
             begin
               R.Assign(0, 0, 60, 17);
               inherited Init(R, 'Orders');
               Options := Options or ofCentered;
               HelpCtx := $F000;

               R.Assign(13, 2, 23, 3);
               Field := New(PInputLine, Init(R, 8));
               Insert(Field);
               Insert(New(PLabel, Init(R, '~O~rder #:', Field)));

               R.Assign(43, 2, 53, 3);
               Field := New(PInputLine, Init(R, 8));
               Insert(Field);

         B.Pascal 7 & Objects/TV#1    - 82 -

               R.Assign(26, 2, 41, 3);
               Insert(New(PLabel, Init(R, '~D~ate of order:', Field)));

               R.Assign(13, 4, 23, 5);
               Field := New(PInputLine, Init(R, 8));
               Insert(Field);
               R.Assign(2, 4, 12, 5);
               Insert(New(PLabel, Init(R, '~S~tock #:', Field)));

               R.Assign(46, 4, 53, 5);
               Field := New(PInputLine, Init(R, 5));
               Insert(Field);
               R.Assign(26, 4, 44, 5);
               Insert(New(PLabel, Init(R, '~Q~uantity ordered:',
                          Field)));
               R.Assign(3, 7, 57, 8);
               Cluster := New(PRadioButton, Init(R,
                   NewItem('Cash     ',
                   NewItem('Check    ',
                   NewItem('P.O.     ',
                   NewItem('Account',nil))))));
               Insert(Cluster);
               R.Assign(2, 6, 21, 7);
               Insert(New(PLabel, Init(R, '~P~ayment method:',
                      Cluster)));

               R.Assign(22, 8, 37, 9);
               Cluster := New(PCheckBoxes, Init(R, NewSItem(~R~eceived',
                              nil)));
               Insert(CLuster);

               R.Assign(3, 10, 57, 13);
               Memo := New(PMemo, Init(R, nil, nil, nil, 255));
                                          { добавление поля комментария }
               Insert(Memo);
               R.Assign(2, 9, 9, 10);
               Insert(New(PLabel, Init(R, 'Notes:', Memo)));

               R.Assign(2, 14, 12, 16);
               Insert(New(PButton, Init(R, '~N~ew', cmOrderNew,
                          bfNormal)));
               R.Assign(13, 14, 23, 16);
               Insert(New(PButton, Init(R, '~S~ave', cmOrderSave,
                          bfDefault)));
               R.Assign(24, 14, 34, 16);
               Insert(New(PButton, Init(R, 'Re~v~ert', cmOrderCancel,
                          bfNormal)));
               R.Assign(35, 14, 45, 16);
               Insert(New(PButton, Init(R, 'N~e~xt', cmOrderNext,
                          bfNormal)));
               R.Assign(46, 14, 56, 16);
               Insert(New(PButton, Init(R, '~P~rev', cmOrderPrev,
                          bfNormal)));

         B.Pascal 7 & Objects/TV#1    - 83 -

               SelectNext(False);
             end;

             Отметим, что  порядок,  в  котором вы добавляете управляющие
        элементы, имеет важное значение, поскольку он определяет для диа-
        логового окна порядок табуляции. Порядок табуляции указывает, ку-
        да перемещается фокус ввода,  когда вы нажимаете клавишу Tab. По-
        рядок табуляции  на самом деле совпадает с Z-последовательностью,
        о которой мы уже упоминали в Шаге  4,  но  поскольку  управляющие
        элементы обычно не перекрываются, вам не нужно отмечать, что один
        из них находится "перед" другим.

             Если вы теперь выполните прикладную программу, то обнаружите
        наличие полнофункционального  окна ввода данных.  Вы можете наби-
        рать данные в строках ввода, работать с кнопками с зависимой фик-
        сацией и т.д.  На следующем шаге вы узнаете,  как устанавливать и
        считывать значения управляющих элементов,  а затем добавите реак-
        цию на "нажатие" командных кнопок вдоль нижней границы окна.

                 Шаг 9: Установка значений управляющих элементов
        ─────────────────────────────────────────────────────────────────

             Теперь, когда у вас есть окно ввода данных,  вам нужно полу-
        чить возможность  устанавливать для управляющих элементов началь-
        ные значения и считывать данные при завершении работы с окном. Вы
        создали интерфейс  с пользователем.  Теперь вам нужно создать ин-
        терфейс с программой.  Данный шаг охватывает три момента, которые
        вы должны  предусмотреть при организации взаимодействия программы
        с диалоговым окном:

             - установку записи данных;
             - установку управляющих элементов на основе записи данных;
             - считывание управляющих элементов в запись данных.

                              Задание записи данных
        ─────────────────────────────────────────────────────────────────

             Чтобы установить  или считать значения управляющих элементов
        в диалоговом окне,  вам нужно создать буфер  (обычно  это  запись
        данных), содержащий данные для каждого управляющего элемента. По-
        рядок полей в записи данных соответствует порядку  табуляции  для
        управляющих элементов,  то  есть,  управляющие элементы считывают
        свои данные из записи в том же порядке,  в каком вы включаете эти
        управляющие элементы в диалоговое окно.

             Чтобы создать запись данных, вам нужно:

             - определить  необходимые  для каждого управляющего элемента
               данные;

             - создать структуру записи.



         B.Pascal 7 & Objects/TV#1    - 84 -

                         Определение необходимых данных
        ─────────────────────────────────────────────────────────────────

             Каждый тип управляющего элемента требует для своей инициали-
        зации специального вида или объема данных. Например, строка ввода
        считывает строку конкретной длины,  набор кнопок с зависимой фик-
        сацией считывает значение типа Word, а командная кнопка не считы-
        вает ничего. Простейший способ организации данных состоит в запи-
        си каждого управляющего элемента в порядке его включения в диало-
        говое окно,  а затем записи данных,  которые он воспринимает. Это
        показано в следующей таблице.

                            Управляющие элементы
              диалогового окна и необходимые для них данные   Таблица 5.1
        ┌───────────────┬─────────────────────────┬─────────────────────┐
        │    Поле       │ Управляющий элемент     │ Требуемые данные    │
        ├───────────────┼─────────────────────────┼─────────────────────┤
        │    Order #    │ строка ввода            │ string[8]           │
        │               │ метка                   │ нет                 │
        ├───────────────┼─────────────────────────┼─────────────────────┤
        │    Date       │ строка ввода            │ string[8]           │
        │               │ метка                   │ нет                 │
        ├───────────────┼─────────────────────────┼─────────────────────┤
        │    Stock #    │ строка ввода            │ string[8]           │
        │               │ метка                   │ нет                 │
        ├───────────────┼─────────────────────────┼─────────────────────┤
        │    Quantity   │ строка ввода            │ string[5]           │
        │               │ метка                   │ нет                 │
        ├───────────────┼─────────────────────────┼─────────────────────┤
        │    Payment    │ кнопки с зависимой      │ Word                │
        │     method    │  фиксацией              │                     │
        │               │ метка                   │ нет                 │
        ├───────────────┼─────────────────────────┼─────────────────────┤
        │    Reseived   │ кнопки с независимой    │ Word                │
        │               │  фиксацией              │                     │
        ├───────────────┼─────────────────────────┼─────────────────────┤
        │    Notes      │ комментарий             │ Word и              │
        │               │                         │  array of Char      │
        ├───────────────┼─────────────────────────┼─────────────────────┤
        │    New        │ командная кнопка        │ нет                 │
        ├───────────────┼─────────────────────────┼─────────────────────┤
        │    Save       │ командная кнопка        │ нет                 │
        ├───────────────┼─────────────────────────┼─────────────────────┤
        │    Cancel     │ командная кнопка        │ нет                 │
        ├───────────────┼─────────────────────────┼─────────────────────┤
        │    Next       │ командная кнопка        │ нет                 │
        └───────────────┴─────────────────────────┴─────────────────────┘



         B.Pascal 7 & Objects/TV#1    - 85 -

                            Создание структуры записи
        ─────────────────────────────────────────────────────────────────

             При наличии всей информации для управляющих элементов вы мо-
        жете определить запись с полями соответствующего типа и в  нужном
        порядке. Ниже  показан  тип  записи  для  управляющих элементов в
        TOrderWindow:

             POrder = ^TOrder;
             TOrder = record
                OrderNum: string[8];
                OrderDate: string[8];
                StockNum: string[8];
                Quantity: string[5];
                Payment, Received, MemoLen: Word;
                MemoText: array[0..255] of Char;
             end;

             Для установки и считывания значений управляющих элементов вы
        будете использовать одну и ту же структуру записи.

                    Установка значений управляющих элементов
        ─────────────────────────────────────────────────────────────────

             Для установки значений управляющих  элементов  в  диалоговом
        окне нужно  установить требуемые значения в записи данных,  затем
        вызвать метод SetData объекта диалогового окна,  передав ему  эту
        запись. SetData - это метод, который диалоговое окно наследует из
        TGroup. SetData в группе вызывает методы SetData каждого  отобра-
        жаемого подэлемента,  которыми эта группа управляет. Это происхо-
        дит в Z-последовательности,  поэтому для полей записи должен соб-
        людаться порядок включения управляющих элементов.

             Чтобы задать   данные   для  текущего  порядка,  добавьте  в
        Tutorial глобальную переменную с именем  OrderInfo  типа  TOrder.
        После инициализации  OrderInfo  вы  можете установить управляющие
        элементы в диалоговом окне,  вызвав перед выполнением диалогового
        окна SetData. Это показано в следующем примере:

             var OrderInfo: TOrder;
             constructor TTutorApp.Init;
             begin
               .
               .
               .
               with OrderInfo do  { установить начальные поля OrderInfo }
               begin
                 OrderNum := '42';
                 StocjNum := 'AAA-9999';
                 OrderDate := '01/15/61';
                 Quantity := '1';
                 Payment := 2;
                 Received := 0;

         B.Pascal 7 & Objects/TV#1    - 86 -

                 MemoLen := 0;
               end;
             end;;

             procedure TTutorApp.OpenOrderWindow;
             var R: TRect;
             begin
               if Message(Desktop, evBroadcast, cmPindOrderWindow, nil)
                           = nil then
               begin
                 OrderWindow := New(POrderWindow, Init);
                 Application^.InsertWindow(OrderWindow);
               end
               else
                 if PView(OrderWindow) <> Desktop^.TopView then
                     OrderWindow^.Select;        { ShowOrder устанавливает
                                                    управляющие элементы }
             end;

             procedure TTutorApp.ShowOrder(AOrderNum: Integer);
             begin
               OrderWindows^.SetData(OrderIOnfo) { установить значения
                                                   управляющих элементов }
             end;

                    Считывание значений управляющих элементов
        ─────────────────────────────────────────────────────────────────

             Считывание значений  управляющих элементов в диалоговом окне
        - это операция,  обратная установке  значений.  При  этом  вместо
        SetData используется соответствующий метод GetData. Метод GetData
        диалогового окна вызывает методы GetData каждого его отображаемо-
        го подэлемента в Z-последовательности,  предоставляя  каждому  из
        них возможность записать свое значение в заданную запись данных.

             Добавьте в объект приложения метод, который считывает значе-
        ния управляющих  элементов окна заказов обратно в OrderInfo в от-
        вет на команду cmOrderSave,  связанную с командной  кнопкой  Save
        окна заказов (как показано в следующем примере).  Не забудьте до-
        бавить метод в описание  объекта  и  в  оператор  case  в  методе
        HandleEvent приложения:

             procedure TTutorApp.SaveOrderData;
             begin
               OrderWindow^.GetData(OrderInfo); { считать значение в
                                                  OrderInfo }
             end;

                   Примечание: Использование  GetData для считывания зна-
              чений  управляющих  элементов   реализовано   в   программе
              TUTOR09.PAS.

             Теперь, если  вы запускаете приложение и выводите окно зака-

         B.Pascal 7 & Objects/TV#1    - 87 -

        зов, оно будет все равно содержать значения по умолчанию, присво-
        енные конструктором  приложения.  Но если вы модифицируете в окне
        значения управляющих элементов,  щелкаете  "мышью"  на  командной
        кнопке Save (Сохранение), закрываете окно, а затем открываете его
        вновь, то управляющие элементы будут содержать те значения, кото-
        рые они имели при закрытии окна. Сохранение данных приводит к ко-
        пированию в поля OrderInfo новых значений,  так  что  управляющие
        элементы в окне будут иметь сохраненные значения.

             В Шаге 11 вы будете использовать этот же механизм для созда-
        ния и обновления простой базы данных инвентарных записей.



         B.Pascal 7 & Objects/TV#1    - 88 -

                  Шаг 10: Проверка допустимости вводимых данных
        ─────────────────────────────────────────────────────────────────

             Теперь, когда у вас есть рабочее окно ввода данных,  которое
        вы можете использовать для вывода на  экран,  ввода  и  изменения
        данных, встает вопрос проверки допустимости этих данных. Проверка
        допустимости - это обеспечение включения в поля  корректных  дан-
        ных. Turbo Vision предоставляет вам возможность проверки допусти-
        мости отдельных полей или всего экрана данных.

             В общем случае вам требуется  проверять  только  управляющие
        элементы, представляющие  собой  строку  ввода - это единственный
        вид управляющих элементов,  которые допускают  ввод  в  свободной
        форме (кроме  полей  примечаний  memo,  которые предназначены для
        комментариев и не обязаны быть точными).

             Проверка допустимости поля данных предусматривает только два
        шага:

             * Назначение объектов проверки допустимости.

             * Вызов методов Valid.

             Все объекты   проверки   допустимости  содержатся  в  модуле
        Validate. Не забудьте включить Validate в оператор uses программы
        или модуля, использующих проверку допустимости.

                    Назначение объектов проверки допустимости
        ─────────────────────────────────────────────────────────────────

          Каждый объект строки ввода содержит поле, указывающее на объект
        проверки допустимости.  Объекты проверки допустимости - это прос-
        тые объекты,  которые проверяют содержимое соответствующей строки
        ввода по некоторому критерию допустимости (например,  попаданию в
        диапазон значений, шаблону или виду поля).

             Назначение объекта проверки допустимости предусматривает два
        шага, хотя выполняются они обычно одним оператором:

             - построение объекта проверки допустимости;

             - присваивание строке ввода объекта проверки допустимости.

                    Построение объекта проверки допустимости
        ─────────────────────────────────────────────────────────────────

             Объекты проверки допустимости очень просты, и, поскольку они
        не являются отображаемыми элементами, то требуют только достаточ-
        ного числа параметров,  сообщающих им, как проверять допустимость
        данных. Например,  средство  проверки  допустимости  по диапазону
        воспринимает только два параметра - нижнюю и верхнюю границу  до-
        пустимого диапазона. Следующий пример может показывать, как можно
        построить объект проверки допустимости,  допускающий ввод  только

         B.Pascal 7 & Objects/TV#1    - 89 -

        четырехзначных чисел:

             RangeValidator := New(PRangeValidator, Init(1000, 9999));

             Программа Tutorial  использует  только два вида средств про-
        верки допустимости: проверку допустимости по диапазону и проверку
        допустимости по шаблону,  которые подробно описываются в Главе 13
        "Объекты проверки допустимости".

              Назначение строке ввода объекта проверки допустимости
        ─────────────────────────────────────────────────────────────────

             Объекты строки  ввода  содержат метод SetValidator,  который
        присваивает полю Validator объекта строки ввода  объект  проверки
        допустимости. Так  как вашей программе почти никогда не требуется
        доступ к конкретному средству проверки допустимости,  отличный от
        присваивания его строке ввода,  построение и присваивание объекта
        проверки допустимости выполняется обычно одним оператором:

             SetValidator(New(PRangeValidator, Init(1000, 9999)));

             После присваивания объекта проверки допустимости о нем можно
        не беспокоиться.  Строка ввода знает,  где вызывать средство про-
        верки допустимости,  а объект проверки допустимости сам  информи-
        рует пользователя  в  случае  обнаружения недопустимых данных.  В
        следующем примере показаны изменения в конструкторе TOrderWindow,
        позволяющие добавить  к  четырем  объектам  строки ввода средства
        проверки допустимости.

             constructor TOrderWindow.Init;
             begin
               .
               .
               .
               R.Assign(13, 4, 23, 5);
               Field := New(PInputLine, Init(R, 8));
               Field^.SetValidator(New(PRangeValidator,
                                   Init(1, 99999))); { номер заказа -
                                          положительное целое значение }
               Insert(Field);
                  .
                  .
                  .
               R.Assign(43, 4, 53, 3);
               Field := New(PInputLine, Init(R, 8));
               Field^.SetValidator(New(PCXPictureValidator,
                             Init('[{#[#]}/{#[#]}/{##[##]}', True)));
                                  { дата - это ММ/ЧЧ/ГГ }
               Insert(Field);
                  .
                  .
                  .
               R.Assign(13, 4, 23, 5);

         B.Pascal 7 & Objects/TV#1    - 90 -

               Field := New(PInputLine, Init(R, 8));
               Field^.SetValidator(New(PCXPictureValidator,
                                 { шаблон Paradox }
                             Init('&&&-####', True)));
                                  { артикул - это 3 буквы и 4 цифры }
               Insert(Field);
                  .
                  .
                  .
               R.Assign(46, 4, 53, 5);
               Field := New(PInputLine, Init(R, 5));
               Field^.SetValidator(New(PRangeValidator,
                             Init(1, 99999)));
                                 { количество - это положительное целое }
               Insert(Field);
                  .
                  .
                  .
             end;

             Теперь вы можете запустить программу и набрать число, напри-
        мер,  99999 в поле номера заказа и попытаться закрыть окно. Выво-
        дится окно сообщения, информирующее вас, что число лежит вне диа-
        пазона,  и возвращающее вас в поле, где произошла ошибка допусти-
        мости.  Аналогично,  ошибки в других полях предотвращают закрытие
        окна, пока ошибки не будут исправлены.

             Но вы можете также обнаружить, что можете сохранить недопус-
        тимые данные. По умолчанию диалоговое окно проверяет допустимость
        своих полей только при его закрытии,  поэтому в следующем разделе
        вы увидите,  как проверять допустимость данных в другие  моменты,
        например, перед их сохранением.

                       Вызов методов проверки допустимости
        ─────────────────────────────────────────────────────────────────

             При проверке допустимости возникает два ключевых  вопроса  -
        что является допустимым и когда проверять допустимость. На первый
        вопрос вы отвечаете присваиванием строкам ввода конкретных  типов
        объектов проверки  допустимости.  Второй  вопрос  несколько более
        сложен. Проверка допустимости данных имеет место в методах  Valid
        объектов строки ввода, а Valid можно вызывать различные моменты.

             Имеется три момента, когда вы можете вызывать Valid:

             - при закрытии окна;
             - когда фокус перемещается в другое поле (по клавише Tab);
             - когда пользователь запрашивает проверку допустимости.

                       Проверка допустимости при закрытии
        ─────────────────────────────────────────────────────────────────

             По умолчанию при закрытии отображаемых элементов для обеспе-

         B.Pascal 7 & Objects/TV#1    - 91 -

        чения допустимости закрытия вызывается метод Valid. Окна редакти-
        рования, созданные вами на Шаге 4, например, перед закрытием про-
        веряют, что изменения в окне сохранены на диске (или преднамерен-
        но отброшены).

             Когда вы закрываете диалоговое окно,  то как и случае  любой
        другой группы  метод Valid диалогового окна вызывает методы Valid
        всех своих  отображаемых  подэлементов и возвращает значение True
        только в том случае, если все отображаемые подэлементы возвращают
        True.  Так  как метод Valid строки ввода выполняет проверки с по-
        мощью своего объекта проверки допустимости,  закрытие окна  имеет
        эффект проверки допустимости всех полей.

                       Проверка допустимости по табуляции
        ─────────────────────────────────────────────────────────────────

             Вы можете принудить пользователя вводить в определенном поле
        допустимые данные перед перемещением в  другое  поле.  Для  этого
        нужно установить   флаг   ofValidate   строки  ввода.  Если  флаг
        ofValidate установлен,  то когда пользователь или программа пыта-
        ются переместить  фокус  со  строки ввода,  строка ввода вызывает
        свой метод Valid,  и если Valid возвращает False, то фокус не пе-
        ремещается.

             Такую проверку  допустимости вам следует использовать только
        в тех случаях,  когда это действительно необходимо,  так как  это
        затрудняет процесс ввода данных.  Однако это позволяет предотвра-
        тить ввод целого экрана бесполезных данных.

                        Проверка допустимости по запросу
        ─────────────────────────────────────────────────────────────────

             Возможно,  наиболее полезным видом проверки допустимости яв-
        ляется проверка допустимости по запросу.  То есть в некоторый мо-
        мент вы просто сообщаете окну или отдельному полю о необходимости
        своей проверки.  Это решает проблему сохранения недопустимых дан-
        ных: проверка данных выполняется перед их сохранением.  Изменения
        в SaveOrderData показаны в следующем примере.  Эти изменения пре-
        дотвращают копирование  управляющих  элементов в OrderInfo,  пока
        все управляющие элементы не сообщают о наличии допустимых данных.

             procedure TTutorApp.SaveOrderData;
             begin
               if OrderWindow^.Valid(cmClose) then
                   OrderWindow^.GetData(OrderInfo);
             end;

                   Примечание: Проверку допустимости данных перед  сохра-
              нением выполняет программа TUTOR10.PAS.

             Обратите внимание  на  использование cmClose в вызове Valid.
        Valid может работать с различными  видами  проверки  допустимости
        для различных  команд.  По  умолчанию Turbo Vision использует два

         B.Pascal 7 & Objects/TV#1    - 92 -

        вида проверки допустимости. Передача методу Valid cmValid исполь-
        зуется для  определения  корректности  построения объекта.  Вызов
        ValidView использует проверку cmValid. Вы увидите также, что окна
        и диалоговые  окна вызывают Valid перед закрытием,  передавая ему
        cmClose - команду, указывающую на намерение закрыть окно.

             Вызов метода Valid(cmClose) аналогичен  вопросу:  "Будет  ли
        допустимо закрытие  окна в данный момент?" Вызов его перед сохра-
        нением действует как проверка возможности сохранить данные.



         B.Pascal 7 & Objects/TV#1    - 93 -

─────────────────────────────────────────────────────────────────────────
                             ГЛАВА 6. Наборы данных
        ─────────────────────────────────────────────────────────────────

             Теперь, после разработки окна ввода данных, имеет смысл свя-
        зать его с базой данных.  Имейте в виду,  что используемый пример
        предназначен для того, чтобы обучить вас работе с Turbo Vision, а
        не управлению базой данных или системой заказов. Некоторые аспек-
        ты программы преднамеренно упрощены, что позволило сосредоточить-
        ся на Turbo Vision, не уделяя слишком большого внимания использу-
        емой базе данных.

             Чтобы связать ваше окно ввода данных с базой  данных,  нужно
        сделать следующее:

             * Загрузить из потока набор записей данных.

             * Вывести на экран, модифицировать и добавить записи.

             * Создать специализированный отображаемый элемент.

                        Шаг 11: Добавление набора данных
        ─────────────────────────────────────────────────────────────────

             Turbo Vision предусматривает гибкий и мощный объектно-ориен-
        тированный тип  управления  данными,  который называется набором.
        Набор аналогичен расширяемому массиву указателей,  которые  могут
        указывать на любой вид данных, такие как объекты или записи.

             На данном шаге вы сделаете следующее:

             - создайте объект данных;
             - загрузите данные из потока;
             - выведите записи данных на экран;
             - будете перемещаться от записи к записи;
             - добавите новые записи;
             - научитесь  отменять изменения,  внесенные при редактирова-
               нии.

                             Создание объекта данных
        ─────────────────────────────────────────────────────────────────

             Как вы уже видели на Шаге 9,  данные для установки управляю-
        щих элементов в диалоговом окне имеют форму записи (в данном слу-
        чае типа TOrder). Но если вы хотите использовать свои наборы дан-
        ных в потоке,  то это должен  быть  объект,  являющийся  потомком
        TObject. Решением является создание охватывающего объекта,  кото-
        рый просто позволяет создать "оболочку" вокруг ваших данных.


         B.Pascal 7 & Objects/TV#1    - 94 -

             Использование охватывающего объекта с потоками требует  сле-
        дующего:

             - поля или полей, содержащих данные;
             - метода Store для записи данных в поток;
             - конструктора Load для чтения данных из потока;
             - записи регистрации.

             В следующем примере показано описание простого охватывающего
        объекта TOrderObj, который является оболочкой TOrder:

             type
               POrderObj = ^TOrderObj;
               TOrderObj = object(TObject)
                  TransferRecord: TOrder;
                  constructor Load(var S: TStream);
                  procedure Store(var S: TStream);]
             end;

             constructor TOrderObj.Load(var S: TStream);
             begin
               inherited Init;                     { построение объекта }
               S.Read(TransferRecord, Sizeof(TransferRecord));
                                               { получить данные потока }
             end;

             procedure TOrderObj.Store(var S: TStream);
             begin
               S.Write(TransferRecord, Sizeof(TransferRecord));
                                                     { сохранить запись }
             end;

             Если вы вспомните Шаг 6,  все используемые с потоками объек-
        ты, должны регистрироваться с потоками, поэтому вам нужно создать
        для TOrderObj запись регистрации.  По соглашению записи регистра-
        ции потока Turbo Vision имеют имя,  совпадающее с типом  объекта,
        но  первая буква T в имени типа заменяется на R.  Поэтому записью
        регистрации для TOrderObj будет ROrderObj. Описание ROrderObj по-
        казано в следующем примере:

             const
               ROrderObj: TStreamRec = (
                  ObjType: 15000;
                  VmtLink: Ofs(TypeOf(TOrderObj)^);
                  Load:    @TOrderObj.Load;
                  Store:   @TOrderObj.Store;
             );

             Единственной частью записи регистрации,  о которой вам нужно
        подумать, является поле ObjType. Это должно быть уникальное число

         B.Pascal 7 & Objects/TV#1    - 95 -

        типа Word.  Turbo Vision резервирует все числа в диапазоне 0..99,
        но для своих объектов вы можете использовать любые другие  числа.
        Единственным ограничением  является  их уникальность.  Все прочие
        поля всегда создаются аналогичным образом.

                                 Загрузка набора
        ─────────────────────────────────────────────────────────────────

             Набор может иметь дело с любым видом указателя,  но при чте-
        нии его из потока или записи в поток предполагается, что элементы
        в наборе являются зарегистрированными потомками TObject, имеющими
        методы Load и Store. Если это предположение неверно, то вам нужно
        переопределить несколько  методов  набора,  как  это  делается  в
        TStringCollection. Но поскольку вы создали набор, удовлетворяющий
        тому, что   ожидает  TCollection,  вам  не  нужно  модифицировать
        TCollection.

             В следующем примере показана  процедура,  которая  загружает
        набор в порядок считывания записей из потока.  Файл ORDERS.DAT на
        вашем дистрибутивном диске содержит поток с несколькими  простыми
        заказами.  Не забудьте добавить в программу глобальную переменную
        OrderColl типа PCollection.  Добавляя  эту  переменную,  добавьте
        также целочисленную переменную с именем CurrentOrder,  которую вы
        можете использовать для отслеживания позиции заказа в наборе.

             procedure LoadOrders;
             var OrderFile: TBufStream;
             begin
               OrderFile.Init('ORDERS.DAT',, stOpenRead, 1024);
               OrderColl := PCollection(OrderFile.Get);
               OrderFile.Done;
             end;

             Этот пример  показывает  некоторые  преимущества  сохранения
        данных в  наборе.  За один шаг вы можете загрузить все данные без
        необходимости считывать и распределять отдельные  записи,  искать
        конец файла и т.д.  Вы просто получаете набор, и он выполняет всю
        работу по загрузке элементов.

                              Вывод записи на экран
        ─────────────────────────────────────────────────────────────────

             Теперь вы имеете в памяти набор записей заказов и можете ис-
        пользовать их в качестве данных для окна заказов. Вместо создания
        начальной записи для OrderInfo в конструкторе приложения,  вы мо-
        жете теперь скопировать первый элемент из набора.  Это показано в
        следующем примере:

             constructor TTutorApp.Init;
             begin
               .
               .
               .

         B.Pascal 7 & Objects/TV#1    - 96 -

               LoadOrders;
               CurrentOrder := 0;
               OrderInfo :=
                  POrderObj(OrderColl^.At(CurrentOrder))^.TransferRecord;
               DisableCommands(([cmOrderNest, cmOrderPrev,
                  cmOrderCancel]);
             end;

             На первый взгляд это может показаться несколько сложным. Ме-
        тод  At набора возвращает указатель на конкретный элемент в набо-
        ре. Поскольку набор содержит нетипизированные указатели, вам нуж-
        но преобразовать их тип в POrderObj,  после чего вы сможете полу-
        чить доступ к его полю TransferRecord. Это информация, которую вы
        хотите присвоить OrderInfo.


         B.Pascal 7 & Objects/TV#1    - 97 -


             Так как  вам  не нужно реагировать на перечисленные команды,
        пока их можно запретить. Позднее на данном шаге, когда вы  разра-
        ботаете другие методы для работы с базой данных,  вы в нужный мо-
        мент разрешите их.  Теперь, когда вы открываете окно заказов, оно
        содержит запись из базы данных.  Это показано на следующем рисун-
        ке.

        ┌─[*]─────────────────────── Orders ────────────────────────────┐
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒Order #:▒▒ 04423      ▒▒▒Date of order: ▒▒▒  3/23/91      ▒▒▒│
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒Stock #:▒▒ MSF-0012   ▒▒▒Quantity ordered:▒▒ 23           ▒▒▒│
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒Payment method:▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒                                                           ▒▒│
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒      R             ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒Notes:▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒                                                           ▒▒│
        │▒▒                                                           ▒▒│
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒▒▒██New████▒▒▒██Save███▒▒▒██Cancel█▒▒▒██Next███▒▒▒██Prev███▒▒│
        │▒▒▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒│
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│
        └───────────────────────────────────────────────────────────────┘

             Рис. 6.1 Вывод первой записи в базе данных.

             Order # - номер заказа; Date of order - дата заказа; Stock #
        - артикул;  Quantity ordered - объем заказа; Payment method - ха-
        рактер оплаты;  Notes - примечания;  New - новый; Save - сохране-
        ние; Cancel - отмена; Next - следующий; Prev - предыдущий.

                                Сохранение записи
        ─────────────────────────────────────────────────────────────────

             Когда вы щелкаете кнопкой "мыши" на командной  кнопке  Save,
        SaveOrderData будет  копировать  в OrderInfo значения управляющих
        элементов, но теперь вам нужно также  скопировать  его  в  наборы
        данных и  сохранить  обновленный  набор на диске.  Это показано в
        следующем примере:

             procedure TTutorApp.SaveOrderData;
             begin
               if OrderWindow^.Valid(cmClose) then
               begin
                 OrderWindow^.Valid(cmClose) then
                 begin
                   OrderWindow^.GetData(OrderInfo);

         B.Pascal 7 & Objects/TV#1    - 98 -

                   POrderObj(OrderColl^.At(CurrentOrder))^.TransferRecord
                     := OrderInfo;
                   SaveOrders;
                 end;
             end;

             procedure SaveOrders;
             var OrderFile: TBufStream;
             begin
               OrderFile.Init('ORDERS.DAT', stOpenWrite, 1024);
               OrderFile.Put(OrderColl);
               OrderFile.Done;
             end;

                         Перемещение от записи к записи
        ─────────────────────────────────────────────────────────────────

             Теперь, когда вы можете редактировать первую запись  в  базе
        данных, вам  нужно получить возможность доступа к другим записям.
        Вы определили команды меню и строки состояния.  Теперь пора опре-
        делить реакцию  на  эти команды.  Нужно сделать так,  чтобы метод
        HandleEvent приложения вызывал ShowOrder и изменял ShowOrder  для
        перемещения к заданному заказу. Это показано в следующем примере:

             procedure TTutorApp.HandleEvent(var Event: TEvent);
             begin
               inherited HandleEvent(Event);
               if Event.What = evCommand then
               begin
                 case Event.Command of
                    cmOrderNext:
                      begin
                        ShowOrder(CurrentOrder + 1);
                        ClearEvent(Event);
                      end;
                   cmOrderPrev:
                      begin
                        ShowOrder(CurrentOrder - 1);
                        ClearEvent(Event);
                      end;
                       .
                       .
                       .
             end;

             procedure TTutorAopp.ShowOrder(AOrderNum: Integer);
             begin
               CurrentOrder := AOrderNum;
               OrderInfo :=
                POrderObj(OrderColl^.At(CurrentOrder))^.TransferRecord;
                OrderWindow^.SetData(OrderInfo);
                if CurrentOrder > 0 then EnableCommands([[[[cmOrderPrev])
                else DisableCommands([cmOrderPrev]);

         B.Pascal 7 & Objects/TV#1    - 99 -

                if OrderColl^.Count > 0 then
                              EnableCommands([cmOrderNext]);
                if CurrentOrder >= OrderColl^.Count - 1 then
                              DisableCommands([cmOrderNext]);
             end;

             ShowOrder манипулирует командами cmOrder и cmOrderPrev. Раз-
        решая и запрещая в нужное время команды,  вы можете избежать про-
        верки необходимости реакции в методах  реакции.  Это  полезно  по
        двум причинам:

             * Ваша программа выглядит проще.  Например, если cmNextOrder
               всегда запрещена при редактировании  последнего  заказа  в
               наборе, в вашей реакции на cmNextOrder не требуется прове-
               рять наличие следующего заказа.

             * Пользователь знает, что происходит. Лучше запретить непод-
               ходящую  команду,  чем предлагать ее и затем либо ничего с
               ней не делать,  либо выводить сообщение  о  несоответствии
               команды.

             Естественно, чтобы  эта схема правильно работала,  вам нужно
        при первоначальном открытии окна  соответственно  задать  команды
        Next и Prev:

             procedure TTutorApp..OpenOrderWindow;
             var R: TRect;
             begin
               if Message(Desktop, evBroadcast, cmFindOrderWindow, nil) =
                       nil then
               begin
                 OrderWindow := New(POrderWindow, Init);
                 InsertWindow(OrderWindow);
               end
               else OrderWindow^.MakeFirst;
               OrderWindow^.SetData(OrderInfo);
               EnableCommands([cmOrderNew, cmOrderSave, cmOrderCancel]);
                                                                { всегда }
               if CurrentOrder < OrderColl^.Count - 1 then
                                                    { если это последний }
               EnableCommands([cmOrderNext]);
                              { ... не допускать дальнейшего перемещения }
             end;

                            Добавление новых записей
        ─────────────────────────────────────────────────────────────────

             Добавить новые  записи  в базу данных достаточно просто,  но
        вам нужно создать временный объект данных  для  размещения  новых
        данных, которые  вы сможете включить в базу данных.  Для этого вы
        можете добавить глобальную переменную TempOrder  типа  POrderObj.
        Чтобы добавить новую запись,  загрузите вашу пустую запись в окно
        заказов и позвольте пользователю заполнить и сохранить ее:

         B.Pascal 7 & Objects/TV#1   - 100 -


             procedure TTutorApp.EnterNewOrder;
             begin
               OpenOrderWindow;              { убедиться в наличии окна }
               CurrentOrder := OrderColl^.Count;  { указывает после
                                                    последней записи }
               TempOrder := New(POrderObj, Init); { создать пустой
                                                    заказ }
               OrderInfo := TempOrder^.TransferRecord; { копирование
                                                    данных }
               OrderWindow^.SetData(OrderInfo); { установить значения
                                                  управляющих элементов }
               DisableCommands([cmOrderNext, cmOrderPrev, cmOrderNew]);
             end;

             Сохранение новой записи не будет сильно отличаться,  так как
        вы просто копируете данные в существующий элемент набора.  В сле-
        дующем примере показан модифицированный метод SaveOrderData,  ко-
        торый обрабатывает новые записи:

             procedure TTutorApp.SaveOrderData;
             begin
               if OrderWindow^.Valid(cmClose) then
               begin
                 OrderWindow^.GetData(OrderInfo);
                 if CurrentOrder = OrderColl^.Count then
                                 { True только в случае нового элемента }
                 begin
                   TempOrder^.TransferRecord := OrderInfo;
                                                   { копирование данных }
                   OrderColl^.Insert(TempOrder); { включить новый заказ }
                 end
                 else
                 POrderObj(OrderColl^.At(CurrentOrder))^.TransferRecord
                     := OrderInfo;
                 SaveOrders;
                 EnableCommands([cmOrderNew, cmOrderPrev]);
               end;
             end;

             Заметим, что вам не нужно уничтожать TempOrder.  Этот указа-
        тель все еще используется набором, поэтому вам нежелательно осво-
        бождать память.

                         Отмена изменений редактирования
        ─────────────────────────────────────────────────────────────────

             Одним из последних легко реализуемых средств является отмена
        изменений, которые  вы внесли в запись при модификации существую-
        щей записи  или  при  добавлении  новой.   Отвечая   на   команду
        отмены cmOrderCancel, вы можете вызвать CancelOrder:

             procedure TTutorApp.CancelOrder;

         B.Pascal 7 & Objects/TV#1   - 101 -

             begin
               if CurrentOrder < OrderColl^.Count then
                                              { если заказ существует ...
                  ShowOrder(CurrentOrder)     { ... просто перезагрузить
                                                значения }
               else
               begin
                 Dispose(TempOrder, Done);    { уничтожить временную
                                                запись }
                 ShowOrder(CurrentOrder - 1); { загрузка последней
                                                записи }
               end;
             end;



         B.Pascal 7 & Objects/TV#1   - 102 -

           Шаг 12: Создание специализированного отображаемого элемента
        ─────────────────────────────────────────────────────────────────

             Одним из моментов, который вы могли заметить при использова-
        нии этой простой базы данных, является то, что вы не можете опре-
        делить, какую запись просматриваете (если это не первая и не пос-
        ледняя запись),  или сколько всего записей содержится в базе дан-
        ных. Значительно лучше выводить пользователю номер содержащейся в
        окне записи и общее число содержащихся в базе  записей.  Так  как
        Turbo Vision не обеспечивает для вас такого отображаемого элемен-
        та, вам придется создать его самостоятельно.

             Чтобы создать свой отображаемый элемент, сделайте следующее:

             - создайте внутренний механизм подсчета;
             - постройте отображаемый элемент;
             - задайте внешний вид элемента;
             - добавьте отображаемый элемент в окно заказов.

             Эти четыре шага универсальны для всех  отображаемых  элемен-
        тов. Фактически,  существует  только четыре вещи,  которые должен
        уметь делать отображаемый элемент.  Если говорить кратко,  то это
        следующее:

             - полное покрытие своей прямоугольной областью;

             - реакция на любые события в этой области;

             - отображение себя на экране, когда это требуется;

             - выполнение каких-либо внутренних функций.

                   Примечание: Все  это  подробно  описывается  в Главе 8
              "Отображаемые элементы".

                           Создание механизма подсчета
        ─────────────────────────────────────────────────────────────────

             Внутренние данные для счетчика очень просты.  Он должен отс-
        леживать только два числа: номер текущей записи и общее число за-
        писей. Для  этого  в  объекте  задается  два  числовых  поля типа
        Longint. Затем нужно предусмотреть методы для установки, увеличе-
        ния и уменьшения значения каждого поля:

             type
               PCountView = ^TCountView;
               TCountView = object(TView)
                  Current: Longint;
                  Count: Longint;
                  procedure SetCount(NewCount: Longint);

         B.Pascal 7 & Objects/TV#1   - 103 -

                  procedure IncCount;
                  procedure DecCount;
                  procedure SetCurrent(NewCurrent: Longint);
                  procedure IncCurrent;
                  procedure DecCurrant;
             end;

             procedure TCountView.SetCount(NewCount: Longint);
             begin
               Count := NewCount;
               DrawView;
             end;

             procedure TCountView.IntCount;
             begin
               SetCount(Count + 1);
             end;

             procedure TCountView.DecCount;
             begin
               SetCount(Count - 1);
             end;

             procedure TCountView.SetCurrent(NewCurrent: Longint);
             begin
               Current := NewCurrent;
               DrawView;
             end;

             procedure TCountView.IncCurrant;
             begin
               SetCurrent(Current + 1);
             end;

             procedure TCountView.DecCurrent;
             begin
               SetCurrent(Current - 1);
             end;

             Большинство из методов говорят сами за себя. После изменения
        или установки значения поля SetCount и SetCurrent вызывают насле-
        дуемый метод DrawView,  который сообщает отображаемому элементу о
        необходимости его вывода на экран в случае,  если его внешний вид
        должен быть обновлен.  На данном шаге вы придадите такому отобра-
        жению реальный смысл.

                        Построение отображаемого элемента
        ─────────────────────────────────────────────────────────────────

             При создании нового производного отображаемого элемента  вам
        нужно убедиться, что его конструктор выполняет инициализацию всех
        полей, наследуемых из родительского типа,  а также  инициализацию
        новых полей.  Обычно  это означает,  что вы переопределяете конс-

         B.Pascal 7 & Objects/TV#1   - 104 -

        труктор, но вызываете сначала наследуемый конструктор:

             constructor TCountView.Init(var Bounds: TRecrt);
             begin
               inherited Init(Bounds);
               SetCount(0);
               SetCurrent(1);
             end;

             Bounds в данном случае - это параметр,  общий для всех отоб-
        ражаемых элементов, определяющий прямоугольную область, покрывае-
        мую отображаемым элементом.  Так как возможность работы с прямоу-
        гольной областью (и обработки большинства простых событий) насле-
        дуется из TView, ваш объект TCountView может основываться на нас-
        ледуемом поведении.

                      Вывод отображаемого элемента на экран
        ─────────────────────────────────────────────────────────────────

             Каждый отображаемый  элемент  должен  иметь свой собственный
        метод Draw,  который знает,  как представлять в каждый конкретный
        момент содержимое отображаемого элемента. Метод Draw почти никог-
        да не вызывает своих наследуемых методов,  поскольку  обычно  это
        приводит к изображению поверх областей, которые уже нарисованы на
        экране, приводя к раздражающему мерцанию.

             При выводе на экран используются преимущества  цветовой  па-
        литры отображаемого  элемента.  Палитра  отображает цвета на вла-
        дельца отображаемого элемента. В следующем примере показаны мето-
        ды Draw и GetPalette для TCountView.

             procedure TCountView.Draw;
             var
             B: TDrawBuffer;
             C: Word;
             Params: array[0..1] of Longint;
             Start: Word;
             First: String[10];
             Display: String[20];
             begin
               C := GetColor(2);      { использовать цвет, совпадающий
                                        с цветом рамки }
               MoveChar(B, '~', C, Size.X);
               Params[0] := Current;
               Params[1] := Count;
               FormatStr(Display, ' ~%d~ of %d ', Params);
              { если Current больше Count, вывести Current c подсветкой }
               if Current > Current then C := GetColor($0504)
               else C := GetColor($0202);
               MoveCStr(B, Display, C);
               WriteLine(0, 0, Size.X, Length(Display), B);
             end;


         B.Pascal 7 & Objects/TV#1   - 105 -

             function TCountView.GetPalette: PPalette;
             const P: string[Length(CCountView)] = CCountView;
             begin
               GetPalette := @P;
             end;

             При добавлении методов Load и Store и записи регистрации по-
        тока RCountView вы получите  программу,  которую  можно  найти  в
        COUNT.PAS.

                             Использование счетчика
        ─────────────────────────────────────────────────────────────────

             Чтобы добавить в окно заказов отображаемый элемент счетчика,
        вам нужно добавить Count в оператор uses прикладной программы,  а
        затем выполнить следующие задачи:

             - добавить отображаемый элемент к окну;
             - управление счетчиком.

                           Добавление счетчика к окну
        ─────────────────────────────────────────────────────────────────

             Чтобы облегчить  работу  с  отображаемым элементом счетчика,
        добавьте в объект окна заказов поле,  которое указывает на  счет-
        чик,  и  постройте отображаемый элемент в конструкторе окна зака-
        зов. Не забудьте добавить в конструктор приложения RegisterCount,
        так что вы сможете сохранять отображаемые элементы счетчика в по-
        токах.
             type
               TOrderWindow = object(TDialog)
                  Count: PCountView;         { добавить к счетчику поле }
               constructor Init;
               procedure HandleEvent(var Event: TEvent); virtual;
             end;

             conatructor TOrderWindow.Init;
             begin
               .
               .
               R.Assign(5, 16, 20, 17);   { расположить счетчик в рамке }
               Counter := New(PCountView, Init(R));  { построить
                                                   отображаемый элемент }
               Counter^.SetCount(OrderColl^.Count); { задать число
                                                   заказов }
               Insert(Counter);                       { включить в окно }
               SelectNext(False);
             end;
                               Работа со счетчиком
        ─────────────────────────────────────────────────────────────────

             Настраивать счетчик нужно только в определенные моменты. Те-

         B.Pascal 7 & Objects/TV#1   - 106 -

        кущий элемент требуется обновлять  при  выводе  новой  записи,  а
        счетчик элемента может потребовать изменения, когда вы добавляете
        новую запись.  В следующем примере  показаны  обновленные  методы
        TTutorApp:

             procedure TTutorApp.EnterNewOrder;
             begin
               OpenOrderWindow;
               CurrentOrder := OrderColl^.Count;
               TempOrder := New(POrderObj, Init);
               OrderInfo := TempOrder^.TranserRecord;
               with OrderWindow^ do
               begin
                 SetData(OrderInfo);
                 Counter^.SetCurrent(CurrentOrder + 1);
             end;
               .
               .
               .
             end;

             procedure TTutorApp.SaveOrderData;
             begin
               if OrderWindow^.Valid(cmClose) then
               begin
                 OrderWindow^.GetData(OrderInfo);
                 if CurrentOrder = OrderColl^.Count then
                 begin
                   TempOrder^.TransferRecord := OrderInfo;
                   OrderWindow^.Counter.IncCount;
                 end;
                 .
                 .
                 .
               end;
             end;

             procedure TTutorApp.ShowOrder(AOrderNum: Integer);
             begin
               CurrentOrder := AOrderNum;
               OrderInfo :=
                POrderObj(OrderColl^.At(CurrentOrder))^.TransferRecord;
                 with OrderWindow^ do
                 begin
                   SetData(OrderInfo);
                   Counter^.SetCurrentOrder + 1);
                 end;
                 .
                 .
             end.

         B.Pascal 7 & Objects/TV#1   - 107 -

                                   Что дальше?
        ─────────────────────────────────────────────────────────────────

             Существует множество  дополнений и изменений,  которые можно
        ввести в  программу  Tutorial,  чтобы  сделать ее более полезной.
        Данный раздел предлагает некоторые подходы, которые вы можете ис-
        пользовать для их реализации.  Версию программы, объединяющую эти
        изменения, вы можете найти в файле TUTOR.PAS.

             Программа Tutorial содержит следующие шаги:

             * Элементы диалогового окна,  касающиеся поставщика и налич-
               ных единиц.

             * Проверку допустимости с помощью просмотра.

                         Дополнительные диалоговые окна
        ─────────────────────────────────────────────────────────────────

             Программа TUTOR.PAS  реализует диалоговое окна для элементов
        базы данных,  касающихся поставщика и наличных единиц.  Эти  окна
        аналогичны диалоговому окну ввода заказа. Основное отличие в том,
        что новые диалоговые окна являются режимными  и,  таким  образом,
        реагируют на команды, подобные cmStockNext, а не возлагают их об-
        работку на прикладную программу.

             Проверка допустимости элементов данных  в  новых  диалоговых
        окнах также  показывает некоторые дополнительные примеры проверки
        допустимости по шаблону.

                     Проверка допустимости методом просмотра
        ─────────────────────────────────────────────────────────────────

             Так как  TUTOR.PAS  имеет базу данных наличных единиц и пос-
        тавщиков, эта  программа  может  реализовать  для таких элементов
        проверку допустимости полей ввода данных методом просмотра.  Нап-
        ример, на Шаге 10 вы проверяли допустимость поля артикула в экра-
        не ввода заказа,  что обеспечивало правильный  формат.  Используя
        средство  проверки допустимости путем просмотра,  TUTOR.PAS может
        обеспечить,  что введенные элементы не только будут иметь  нужный
        формат, но совпадать с фактическими инвентарными единицами.



         B.Pascal 7 & Objects/TV#1   - 108 -

─────────────────────────────────────────────────────────────────────────
                       ЧАСТЬ 2. Использование Turbo Vision
        ─────────────────────────────────────────────────────────────────

                           ГЛАВА 7. Обзор Turbo Vision
        ─────────────────────────────────────────────────────────────────

             Материал данной главы подразумевает,  что читатель уже имеет
        большой опыт работы с языком Паскаль,  и,  в частности, с объект-
        но-ориентированными расширениями этого языка, хотя здесь и содер-
        жится некоторая информация о типах объектов.  Имеется в виду так-
        же, что читатель ознакомился с первой частью данной книги и полу-
        чил представление о философских концепциях, возможностях и терми-
        нологии Turbo Vision.

             В Главе 19 ("Справочник по Turbo Vision") методы и поля каж-
        дого стандартного объектного типа описываются  более  углубленно,
        но пока вы не познакомитесь со структурой иерархии,  можете легко
        увязнуть в деталях.  Данная глава даст вам общее представление об
        иерархии до  того,  как вы познакомитесь с детальной информацией.
        Остальные главы данной части посвящены более подробному  описанию
        компонентов Turbo Vision и их использованию.  В Главе 19 справоч-
        ный материал упорядочен по алфавиту.

             На рисунке 3.1 показано полное иерархическое дерево.  Внима-
        тельное  его изучение вам будет чрезвычайно полезно.  Вы узнаете,
        что объект TDialog является производным от объекта TWindow, кото-
        рый,  в свою очередь,  является производным от объекта TGroup,  а
        последний - от объекта TView.  Т.о.  вам потребуется  значительно
        меньше  времени  на изучение свойств всех объектов.  Каждый новый
        производный тип объекта будет обладать известными унаследованными
        свойствами, и вам останется лишь узнать, какие дополнительные по-
        ля и свойства предыдущего объекта он будет иметь.


         B.Pascal 7 & Objects/TV#1   - 109 -


                         ┌────────────────┐
                         │    TObject     │
                         └───────┬────────┘
                         ┌───────┴────────┐
                         │     TView      │
                         └───────┬────────┘
          ┌────────────┬─────────┼─────────────────────┬────────────────┐
          │            │ ┌───────┴────────┐    ┌───────┴────────┐       │
          │            │ │     TFrame     │    │  TListViewer   │       │
          │            │ └────────────────┘    └───────┬────────┘       │
          │            └───┐                   ┌───────┴───┐            │
          │        ┌───────┴────────┐  ┌───────┴────────┐  │            │
          │        │     TCluster   │  │ THistoryViewer │  │            │
          │        └───────┬────────┘  └────────────────┘  │            │
          │      ┌─────────┼────────────┐          ┌───────┴────────┐   │
          │      │         │            │          │    TListBox    │   │
          │      │ ┌───────┴────────┐   │          └───────┬────────┘   │
          │      │ │   TCheckBoxes  │   │                  │            │
          │      │ └────────────────┘   │                  │            │
          │      │                      │          ┌───────┴────────┐   │
          │      └───┐                  │          │ TSortedListBox │   │
          │          │                  │          └────────────────┘   │
          │  ┌───────┴────────┐ ┌───────┴────────┐                      │
          │  │  TRadioButtons │ │TMultiCheckBoxes│         ┌────────────┤
          │  └────────────────┘ └────────────────┘         │            │
          │                                        ┌───────┴────────┐   │
          ├──────────┬──────────┐                  │    TScroller   │   │
          │          │          │                  └────────────────┘   │
          │          │  ┌───────┴────────┐                 ┌────────────┤
          │          │  │    THistory    │                 │            │
          │          │  └────────────────┘         ┌───────┴────────┐   │
          │          │                             │  TBackGround   │   │
          │  ┌───────┴────────┐                    └────────────────┘   │
          │  │  TInputLine    │                                         │
          │  └────────────────┘                                         │

          │                                                             │


         B.Pascal 7 & Objects/TV#1   - 110 -


          │                                                ┌────────────┤
          ├──────────────┐                         ┌───────┴────────┐   │
          │              │                         │    TGroup      │   │
          │      ┌───────┴────────┐                └───────┬────────┘   │
          │      │  TStaticText   │                        ├──────────┐ │
          │      └───────┬────────┘                        │          │ │
          │              │                         ┌───────┴────────┐ │ │
          │              ├───────────────────┐     │    TScroller   │ │ │
          │              │                   │     └───────┬────────┘ │ │
          │      ┌───────┴────────┐  ┌───────┴────────┐    │          │ │
          │      │    TLabel      │  │   TParamText   │    │          │ │
          │      └────────────────┘  └────────────────┘    │          │ │
          ├──────────┐                                     │          │ │
          │  ┌───────┴────────┐         ┌──────────────────┤          │ │
          │  │   TScrollBar   │         │                  │          │ │
          │  └────────────────┘ ┌───────┴────────┐ ┌───────┴────────┐ │ │
          ├──────────┐          │    TDeskTop    │ │    TProgram    │ │ │
          │  ┌───────┴────────┐ └────────────────┘ └───────┬────────┘ │ │
          │  │    TMenuView   │                            │          │ │
          │  └───────┬────────┘                    ┌───────┴────────┐ │ │
          │          │                             │  TApplication  │ │ │
          │          ├───────────────────┐         └────────────────┘ │ │
          │  ┌───────┴────────┐  ┌───────┴────────┐                   │ │
          │  │    TMenuBox    │  │   TMenuBar     │        ┌──────────┘ │
          │  └───────┬────────┘  └────────────────┘        │            │
          │  ┌───────┴────────┐                    ┌───────┴────────┐   │
          │  │   TMenuPopup   │                    │     TWindow    │   │
          │  └────────────────┘                    └───────┬────────┘   │
          └──────────┐                   ┌─────────────────┼──────────┐ │
             ┌───────┴────────┐  ┌───────┴────────┐ ┌──────┴─────────┐│ │
             │   TStatusLine  │  │ THistoryWindow │ │   TDialog      ││ │
             └────────────────┘  └────────────────┘ └──────┬─────────┘│ │
                                         ┌─────────────────┤          │ │
                                 ┌───────┴────────┐ ┌──────┴─────────┐│ │
                                 │   TFileDialog  │ │  TChDirDialog  ││ │
                                 └────────────────┘ └────────────────┘│ │
                                         ┌────────────────────────────┘ │
                                 ┌───────┴────────┐                     │
                                 │   TEditWindow  │                     │
                                 └────────────────┘                     │
                   ┌────────────────────────────────────────────────────┘
           ┌───────┴────────┐
           │   TEditor      │
           └───────┬────────┘
                   ├───────────────────┐
           ┌───────┴────────┐  ┌───────┴────────┐
           │    TMemo       │  │   TFileEditor  │
           └────────────────┘  └────────────────┘


         B.Pascal 7 & Objects/TV#1   - 111 -


                             ┌────────────────┐
                             │     TObject    │
                             └───────┬────────┘
                 ┌───────────────────┼───────────────────┬───────────────┐
         ┌───────┴────────┐  ┌───────┴────────┐  ┌───────┴────────┐      │
         │  TValidator    │  │   TCollection  │  │  TResourceFile │      │
         └───────┬────────┘  └───────┬────────┘  └────────────────┘      │
                 │           ┌───────┴─────────┐           ┌─────────────┤
                 │           │TSortedCollection│           │             │
                 │           └───────┬─────────┘   ┌───────┴────────┐    │
                 │                   │             │    TStream     │    │
                 ├─────────────┐     └────┐        └───────┬────────┘    │
         ┌───────┴───────────┐ │          │                │             │
         │TPXPictureValidator│ │  ┌───────┴─────────┐      │             │
         └───────────────────┘ │  │TSortedCollection│      │             │
                               │  └───────┬─────────┘      │             │
                  ┌────────────│          │                │             │
                  │            │          ├─────────────┐  │             │
          ┌───────┴────────┐   │          │             │  │             │
          │TFilterValidator│   │  ┌───────┴─────────┐   │  │             │
          └───────┬────────┘   │  │ TStrCollection  │   │  │             │
                  │            │  └─────────────────┘   │  │             │
          ┌───────┴────────┐   │                        │  │             │
          │ TRangeValidator│   │            ┌───────────┘  │             │
          └────────────────┘   │    ┌───────┴───────────┐  │             │
                  ┌────────────┘    │ TStringCollection │  │             │
                  │                 └───────┬───────────┘  │             │
          ┌───────┴──────────────┐          │              │             │
          │   TLookupValidator   │  ┌───────┴───────────┐  │             │
          └───────┬──────────────┘  │TResourceCollection│  │             │
                  │                 └───────────────────┘  │             │
          ┌───────┴──────────────┐                         │             │
          │TStringLookupValidator│           ┌─────────────┤             │
          └───────┬──────────────┘   ┌───────┴────────┐    │             │
                  │                  │  TMemoryStream │    │             │
          ┌───────┴────────┐         └────────────────┘    │             │
          │ TRangeValidator│                               │             │
          └────────────────┘           ┌───────────────────┤             │
                               ┌───────┴────────┐  ┌───────┴────────┐    │
                               │    TDosSrtream │  │    TEmsSrtream │    │
                               └───────┬────────┘  └────────────────┘    │
                               ┌───────┴────────┐          ┌─────────────┤
                               │    TBufSrtream │          │             │
                               └────────────────┘  ┌───────┴────────┐    │
                                                   │  TStringList   │    │
                                                   └────────────────┘    │
                                                           ┌─────────────┘
                                                   ┌───────┴────────┐
                                                   │  TStrListMaker │
                                                   └────────────────┘
             Рис. 3.1 Иерархия объектов Turbo Vision.


         B.Pascal 7 & Objects/TV#1   - 112 -


             Модуль Dialogs:       Модуль Stddlg:       Модуль Menus:

             TScrollbar            TSortedListBox       TMenuView
             TInputLine            TDialog              TStatusLine
             TCluster              TFileDialog          TMEnuBox
             TStaticText           TChDirDialog         TMenuBar
             THistory                                   TMenuPopup
             TLabel
             TParamTest
             TCheckBoxes
             TRAdioButtons
             TMulticheckBoxes
             THistoryViever
             TListBox

             Модуль Views:         Модуль App:          Модуль Editors:

             TView                 TBackground          TEditor
             TFrame                TDesktop             TMemo
             TScroller             TProgram             TFileEditor
             TGroup                TApplication         TEditWindow
             TListViewer
             TGroup
             TWindow

             Модуль Objects:       Модуль Validate:

             TObject               TValidator
             TCollection           TPXPictureValidator
             TResourceFile         TRangeValidator
             TStream               TLookupValidator
             TStringList           TStringLookupValidator
             TStrListMaker
             TMemoryStream
             SEmsStream
             TDosStream
             TBufStream
             TSortedCollection
             TStrCollection
             TStringCollection
             TResourceCollection

             В процессе  разработки  программ  с  помощью Turbo Vision вы
        убедитесь,  насколько полезным окажется знание стандартных  типов
        объектов и их взаимоотношений. Позднее вы вникните во все детали,
        но исходные знания о планировании новых  объектов  будут  залогом
        успешного создания ваших программ (что характерно для всех объек-
        тно-ориентированных проектов).

             Каждая группа описывается в отдельном разделе данной  главы.
        Внутри каждой  из этих групп существуют также различные виды объ-
        ектов. Некоторые из них представляют собой полезные объекты -  вы

         B.Pascal 7 & Objects/TV#1   - 113 -

        можете создавать экземпляры этих объектов и использовать их. Дру-
        гие же являются абстрактными объектами,  которые  служат  основой
        для образования родственных,  полезных объектов.  Перед тем,  как
        рассматривать объекты в иерархии Turbo Vision, будет полезным оз-
        накомиться с этими абстрактными объектами.

                           Работа с объектами иерархии
        ─────────────────────────────────────────────────────────────────

             В данном разделе описываются основные свойства объектов, от-
        носящихся и  иерархии Turbo Vision.  Здесь освещаются такие темы,
        как

             - основные операции с объектами;

             - наследование полей;

             - типы методов.

                          Основные операции с объектами
        ─────────────────────────────────────────────────────────────────

             Имея объектный  тип,  вы можете выполнять с ним две основные
        операции:

             - создавать наследующий (производный) объектный тип;

             - создавать экземпляр данного типа.

             При создании производного типа вы получите  новый  объектный
        тип, к  которому снова можно применить две указанные операции.  В
        следующем разделе рассматриваются обе эти операции,  а затем исс-
        ледуются абстрактные объекты.

                          Создание производных объектов
        ─────────────────────────────────────────────────────────────────

             Вы можете легко породить новый тип объектов из уже существу-
        ющего, когда  захотите расширить или изменить имеющийся объектный
        тип:

             PNewScrollBar = ^TNewScrollBar;     { определить указатель
                                                   нового типа }
             TNewScrollBar = object(TScrollBar)  { создать из
                                         существующего типа производный }
               constructor Init(...);
             end;

             При определении  нового  объектного  типа  вы можете сделать
        следующее:

             * Добавить новые поля.


         B.Pascal 7 & Objects/TV#1   - 114 -

             * Определить новые методы.

             * Переопределить существующие методы.

             Если вы не сделаете хотя бы что-то  из  указанного,  то  нет
        причин создавать новый объектный тип.  Например,  перед тем,  как
        объявить объект TNewScrollBar, вам следует определить новые мето-
        ды  или переопределить некоторые из методов объекта TScrollBar и,
        возможно,  добавить ряд новых полей; в противном случае создавать
        новый тип объекта полосы прокрутки будет лишено смысла. Определя-
        емые вами новые или пересмотренные методы и поля составляют  про-
        цесс  добавления  функциональных возможностей объекту TScrollBar.
        Ваш новый метод Init будет определять значения,  используемые  по
        умолчанию для ваших новых объектов полосы прокрутки.

                           Создание экземпляра объекта
        ─────────────────────────────────────────────────────────────────

             Создание экземпляра  объекта  обычно  выполняется  с помощью
        объявления переменной, статического или динамического типа:

             MyScrollBar: TScrollBar;              { описать статический
                                                     экземпляр }
             SomeButton: PButton;                  { описать динамический
                                                     экземпляр }

             MyScrollBar будет инициализирован  посредством  конструктора
        TScrollBar.Init с  определенными  значениями полей,  заданными по
        умолчанию.  Они приведены в разделе TScrollBar.Init  в  Главе  19
        "Справочник по Turbo Vision". Поскольку объект TBufStream являет-
        ся  производным  от  объекта  TStream,  TBufStream.Init   вызовет
        TStream.Init,  для  установки  полей,  унаследованных  от объекта
        TStream.  Таким  же  образом  TStream.Init  порожден  из  объекта
        TObject, поэтому он вызовет конструктор TObject для выделения па-
        мяти.  TObject не имеет объекта-родителя,  следовательно  процесс
        останавливается на этом объекте.

             Диаграмма наследование  в  начале описания каждого объекта в
        Главе 19 показывает вам,  какие поля и методы каждого  объектного
        типа описываются или переопределяются: эти переопределенные мето-
        ды в типах предков отмечены линиями.

             У объекта MeStream имеются теперь заданные по умолчанию зна-
        чения полей,  которые вам может потребоваться изменить.  Он имеет
        все методы объекта TBufStream,  а также методы (возможно, переоп-
        ределенные) объектов TStream и TObject.  Для того, чтобы восполь-
        зоваться методом MyStream, вам необходимо знать функции его мето-
        дов.  Если  в  объекте TBufSteam не определены требуемые функцио-
        нальные возможности, то вам следует породить из него новый тип.

             Удачное создание  полезного экземпляра объектного типа зави-
        сит от того, какие виды виртуальных методов содержит объект. Мно-
        гие абстрактные  типы  Turbo Vision имеют методы,  которые должны

         B.Pascal 7 & Objects/TV#1   - 115 -

        определяться в наследующих типах.

                               Абстрактные объекты
        ─────────────────────────────────────────────────────────────────

             Многие типы объектов существуют в виде "абстрактной" основы,
        на базе которой могут быть получены  более  специализированные  и
        непосредственно используемые типы объектов. Причина существования
        абстрактных типов носит отчасти  концептуальный  характер,  но  в
        большей степени служит практической цели уменьшения объемов прог-
        раммирования.

             Можно рассмотреть,  например,  типы объектов TRadioButtons и
        TCheckBoxes. Каждый из них может быть непосредственно порожден из
        объекта TView без особых затруднений. Тем не менее они имеют мно-
        го  общего:  оба эти типа представляют собой наборы элементов уп-
        равления с одинаковыми характеристиками. Набор "кнопок" с незави-
        симой  фиксацией  во многом сходен с набором "кнопок" с зависимой
        фиксацией, в котором может быть "нажата" только одна кнопка. Кро-
        ме того, здесь имеется и ряд других технических отличий. Подобная
        общность делает возможным выделение абстрактного класса TCluster.
        Далее  из  него порождаются объекты TRadioButtons и TCheckBoxes и
        ряд специальных методов, обеспечивающих их индивидуальные функци-
        ональные возможности.

                   Примечание: В  общем  случае,  когда вы спускаетесь по
              иерархии,  объекты становятся более  специализированными  и
              менее абстрактными.

             Из абстрактных типов не имеет  смысла  создавать  экземпляры
        объектов. Например, экземпляр класса TCluster, MyCluster не будет
        иметь полезного метода Draw:  он унаследует объект TView.Draw без
        переопределения, т.о. объект MyCluster.Draw будет выдавать на эк-
        ране изображение пустого прямоугольника в цвете, установленном по
        умолчанию.

             Если вы хотите получить усовершенствованный кластер  элемен-
        тов управления, имеющий свойства, отличные от  кнопок с независи-
        мой и зависимой фиксацией,  вы можете попытаться породить  объект
        TMyCluster из TCluster,  либо вам будет проще породить ваш специ-
        альный кластер из объектов TRadioButtons или TCheckBoxеs в  зави-
        симости от ваших потребностей.  Во всех случаях вы сможете добав-
        лять сколько угодно полей и методов. Если вы планируете использо-
        вать  целый  ряд  сложных кластеров,  то вам удобно будет создать
        промежуточный абстрактный тип объектов.



         B.Pascal 7 & Objects/TV#1   - 116 -

                               Наследование полей
        ─────────────────────────────────────────────────────────────────

             Если взять на рассмотрение три важных объекта TView,  TGroup
        и TWindow,  то  на  примере  их  полей  можно проследить механизм
        наследования и увеличение  функциональных  возможностей  по  мере
        продвижения  вниз по иерархии (не забывайте, что рост дерева объ-
        ектов идет в направлении вниз от корня).

             TObject     TView
             ┌───────┐   ┌───────────────────────────────────────┐
             ├───────┤   │ Cursor             Options            │
             │─Init──│   │ DragMode           Origin             │
             │ Free  │   │ EventMask          Owner              │
             │─Done──│   │ GrowMode           Size               │
             └───────┘   │ HelpCtk            State              │
                         │ Next                                  │
                         ├───────────────────────────────────────┤
                         │─Init─────────────  HideCursor         │
                         │─Load─────────────  KeyEvent           │
                         │─Done─────────────  Locate             │
                         │─Awaken───────────  MakeFirst          │
                         │ BlockCursor        MakeGlobal         │
                         │ CalcBounds         MakeLocal          │
                         │─ChangeBounds─────  MouseEvent         │
                         │ ClearEvent         MouseInView        │
                         │ CommandEnable      MoveTo             │
                         │─DataSize─────────  NextView           │
                         │ DisableCommands    NormalCursor       │
                         │ DragView           Prev               │
                         │─Draw─────────────  PrevView           │
                         │ DragView           PutEvent           │
                         │ EnableCommands     PutInFrontOf       │
                         │─EndModal─────────  PutPeerViewPtr     │
                         │ EventAvail         Select             │
                         │─Execute──────────  SetBounds          │
                         │ Exposed            SetCommands        │
                         │ Focus              SetCmdState        │
                         │ GetBounds          SetCursor          │
                         │ GetClipRect       ─SetDate────────────│
                         │ GetColor          ─SetState───────────│
                         │ GetCommands        Show               │
                         │─GetData──────────  ShowCursor         │
                         │ GetEvent          ─SizeLimits─────────│
                         │ GetExtent         ─Store──────────────│
                         │─GetHelpCtx───────  TopView            │
                         │─GetPalette─────── ─Valid──────────────│
                         │ GetPeerViewPtr     WriteBuf           │
                         │ GetState           WriteChar          │
                         │ GrowTo             WriteLine          │
                         │─HandleEvent──────  WriteStr           │
                         │ Hide                                  │
                         └───────────────────────────────────────┘

         B.Pascal 7 & Objects/TV#1   - 117 -


             TGroup               TWindow
             ┌────────────────┐   ┌─────────────────────┐
             │ Buffer         │   │ Flags               │
             │ Current        │   │ Frame               │
             │ Last           │   │ Number              │
             │ Phase          │   │ Palette             │
             ├────────────────┤   │ Title               │
             │─Init───────────│   │ ZoomRect            │
             │─Load───────────│   ├─────────────────────┤
             │─Done───────────│   │ Init                │
             │ Awaken         │   │ Load                │
             │ ChangeBounds   │   │ Done                │
             │ DataSize       │   │ Close               │
             │ Delete         │   │ GetPalette          │
             │ Draw           │   │ GetTitle            │
             │ EndModal       │   │ HandleEvent         │
             │ EventError     │   │ InitFrame           │
             │ ExecView       │   │ SetState            │
             │ Execute        │   │ SizeLimits          │
             │ First          │   │ StandScrollBar      │
             │ FirstThat      │   │ Store               │
             │ FocusNext      │   │ Zoom                │
             │ ForEach        │   └─────────────────────┘
             │ GetData        │
             │ GetHelpCtx     │
             │ GetSubViewPtr  │
             │─HandleEvent────│
             │ Insert         │
             │ InsertBefore   │
             │ Lock           │
             │ PutSubViewPtr  │
             │ Redraw         │
             │ SelectNext     │
             │ SetData        │
             │─SetState───────│
             │─Store──────────│
             │ Unlock         │
             │ Valid          │
             └────────────────┘



         B.Pascal 7 & Objects/TV#1   - 118 -

                    Наследование полей отображаемых элементов
                                                      Таблица 3.1
               ┌───────────────┬───────────────┬────────────────┐
               │   Поля TView  │ Поля TGroup   │ Поля TWindow   │
               ├───────────────┼───────────────┼────────────────┤
               │   Owner       │  Owner        │  Owner         │
               │   Next        │  Next         │  Next          │
               │   Origin      │  Origin       │  Origin        │
               │   Size        │  Size         │  Size          │
               │   Cursor      │  Cursor       │  Cursor        │
               │   GrowMode    │  GrowMode     │  GrowMode      │
               │   DragMode    │  DragMode     │  DragMode      │
               │   HelpCtx     │  HelpCtx      │  HelpCtx       │
               │   State       │  State        │  State         │
               │   Options     │  Options      │  Options       │
               │   EventMask   │  EventMask    │  EventMask     │
               │               │  Buffer       │  Buffer        │
               │               │  Phase        │  Phase         │
               │               │  Current      │  Current       │
               │               │  Last         │  Last          │
               │               │               │  Flags         │
               │               │               │  Title         │
               │               │               │  Number        │
               │               │               │  ZoomRect      │
               │               │               │  Palette       │
               │               │               │  Frame         │
               └───────────────┴───────────────┴────────────────┘

             Обратите внимание, что объект TGroup наследует все поля объ-
        екта TView и к нему добавляется еще  ряд  полей,  подходящих  для
        действия группы,  таких как указатели текущего и последнего отоб-
        ражаемых элементов в группе.  В свою очередь, объект TWindow нас-
        ледует все поля объекта TGroup и добавляет еще поля,  необходимые
        для функционирования окна, такие как заголовок и номер окна.

             Для того,  чтобы  полностью  разобраться с объектом TWindow,
        следует иметь в виду,  что окно является одновременно  группой  и
        отображаемым элементом.

                                  Виды методов
        ─────────────────────────────────────────────────────────────────

             Методы Turbo Vision можно характеризовать четырьмя  возможно
        перекрывающимися способами:

             - абстрактные методы;

             - псевдо-абстрактные методы;

             - виртуальные методы;

             - статические методы.


         B.Pascal 7 & Objects/TV#1   - 119 -

                               Статические методы
        ─────────────────────────────────────────────────────────────────

             Статический метод сам по себе не может переопределяться. По-
        рожденный (из него) тип объекта может определять метод с  тем  же
        именем, используя по необходимости полностью отличные аргументы и
        типы возврата,  однако, статические методы не функционируют в по-
        лиморфическом режиме.  Это имеет особенное значение при обращении
        к методам динамических объектов.

             Если, например, PGeneric является переменной-указателем типа
        PView,  вы можете присвоить ей указатели любого типа из иерархии.
        Однако, когда вы разыменовываете переменную и вызываете статичес-
        кий метод, то вызванный метод будет всегда методом объекта TView,
        т.к. это тип указателя, определенный при компиляции. Другими сло-
        вами,      PGeneric^.StaticMethod       всегда       эквивалентен
        TView.StaticMethod,  даже  если  вы присвоили переменной PGeneric
        указатель другого типа.  Примером статического метода может  слу-
        жить TView.Init.

                               Виртуальные методы
        ─────────────────────────────────────────────────────────────────

             Виртуальные методы используют в  объявлениях  их  прототипов
        виртуальную директиву.  Виртуальный  метод можно переопределить в
        производных объектах,  но переопределенный метод  должен  быть  в
        свою  очередь виртуальным и полностью совпадать с заголовком пер-
        воначального метода.  Виртуальные методы переопределять не требу-
        ется, однако  обычно имеется тенденция к их переопределению (рано
        или поздно). Примером такого метода может служить TView.DataSize.

                               Абстрактные методы
        ─────────────────────────────────────────────────────────────────

             В базовом типе объектов абстрактный метод не имеет определя-
        ющего тела (или тела, содержащего оператор Abstract для перехвата
        ошибочных вызовов). Абстрактные методы должны определяться порож-
        денным объектом  перед  тем,  как  их  можно  будет использовать.
        Абстрактные методы всегда являются виртуальными методами.  Приме-
        ром такого метода может служить метод TStream.Read.

                            Псевдо-абстрактные методы
        ─────────────────────────────────────────────────────────────────

             В отличие от действительно абстрактных методов, генерирующих
        ошибку на этапе выполнение,  для псевдо-абстрактного метода опре-
        делен  минимальный объем действий или вовсе не определены никакие
        действия.  Они служат местом для размещения исходного кода в про-
        изводных объектах.

             Например, в типе TView вводится виртуальный метод Awaken. Он
        не содержит кода:


         B.Pascal 7 & Objects/TV#1   - 120 -

             procedure TView.Awaken;
             begin
             end;

             По умолчанию Awaken, таким образом, ничего не делает. Он вы-
        зывается, когда групповой объект заканчивает свою загрузку из по-
        тока.  После загрузки всех отображаемых подэлементов группа вызы-
        вает метод Awaken каждого подэлемента.  Поэтому, если вы создаете
        объект отображаемого подэлемента,  который при загрузке из потока
        требуется инициализировать, вы можете переопределить метод Awaken
        для выполнения такой инициализации.

                               Типология объектов
        ─────────────────────────────────────────────────────────────────

             В Turbo  Vision  не все типы объектов создаются одинаковыми.
        По выполняемым функциям их можно разделить на четыре группы:

             - примитивные объекты;
             - объекты отображаемых элементов;
             - групповые отображаемые элементы;
             - механизмы и средства.

                            Примитивные типы объектов
        ─────────────────────────────────────────────────────────────────

             В Turbo  Vision  имеется три простых типа объектов,  которые
        существуют в первую очередь для использования  другими  объектами
        или служат основой иерархии более сложных объектов. Это объекты:

             - TPoint;

             - TRect;

             - TObject.

             Объекты TPoint и TRect используются всеми видимыми объектами
        в иерархии Turbo Vision.  Объект TОbjеct является основой  иерар-
        хии. Имейте в виду,  что объекты этих типов не могут изображаться
        непосредственно. Объект TPoint является просто объектом-положени-
        ем  экрана (в координатах X и Y).  Объект TRect звучит как объект
        вида,  однако он лишь представляет верхнюю левую,  нижнюю  правую
        границы прямоугольника и ряд неизображаемых методов-утилит.

                                  Объект TPoint
        ─────────────────────────────────────────────────────────────────

             Данный объект представляет точку.  Его поля X и Y определяют
        декартовы  координаты (X,  Y) позиции  экрана.  Точка с координа-
        тами (0,0) является крайней левой верхней точкой экрана.  X  воз-
        растает в  горизонтальном направлении вправо;  Y - в вертикальном
        направлении вниз.  Объект TPoint не имеет методов, но другие типы
        имеют методы,  в  которых  выполняются  преобразования глобальных

         B.Pascal 7 & Objects/TV#1   - 121 -

        (весь экран) в локальные (по отношению к месту  нахождения  вида)
        координаты и наоборот.

                                  Объект TRect
        ─────────────────────────────────────────────────────────────────

             Данный объект представляет прямоугольник. Его поля A и B яв-
        ляются объектами TPoint,  определяющими верхнюю  левую  и  нижнюю
        правую точки прямоугольника.  Объект TRect имеет методы:  Assign,
        Copy,  Move,  Grow,  Intersect,  Union, Contains, Equals и Empty.
        Объекты TRect не являются отображаемыми видимыми элементами и  не
        способны себя изображать.  Однако все отображаемые элементы имеют
        форму прямоугольников:  все их конструкторы Init  имеют  параметр
        Bounds типа TRect для определения охватываемой ими области.

                                 Объект TObject
        ─────────────────────────────────────────────────────────────────

             TObject представляет  собой  абстрактный базовый тип без по-
        лей.  Он является прародителем всех объектов Turbo Vision за иск-
        лючением TPoint и TRect.  Объект TObject имеет три метода:  Init,
        Free  и  Done.  Конструктор,  Init,  образует  основу  для   всех
        конструкторов Turbo Vision, выделяя для них некоторый объем памя-
        ти.  Метод Free освобождает память. Метод Done является абстракт-
        ным деструктором,  который должен переопределяться в  порожденных
        объектах.  Все объекты, которые вы собираетесь использовать в по-
        токах Turbo Vision, должны в конечном итоге порождаться из объек-
        та TObject.

             Объекты, порожденные из объекта TObject,  разделяются на два
        семейства: отображаемые элементы и неотображаемые элементы. Отоб-
        ражаемые элементы являются производными от объекта TView, который
        обеспечивает им специальные свойства, отсутствующие у неотобража-
        емых элементов.  Отображаемые элементы могут создавать свое изоб-
        ражение и обрабатывать передаваемые им события. Объекты неотобра-
        жаемых  элементов представляют набор утилит для обработки потоков
        и совокупностей других объектов,  включая отображаемые  элементы,
        однако они не могут быть "видимыми" непосредственно.

                              Отображаемые элементы
        ─────────────────────────────────────────────────────────────────

             Объекты, производные от объекта TObject и изображение  кото-
        рых  на  экране представляется возможным,  являются отображаемыми
        элементами и порождаются от объекта TView,  который  является,  в
        свою  очередь,  непосредственным  производным от объекта TObject.
        Следует различать понятия "видимый" и "изображаемый",  т.к. могут
        быть ситуации,  когда отображаемый элемент полностью или частично
        скрыт другими отображаемыми элементами.

             Отображаемым элементом является любой объект,  который может
        быть изображен в прямоугольной зоне на экране.  Тип объекта отоб-
        ражаемого элемента  должен  быть  порожден от объекта TView.  Сам

         B.Pascal 7 & Objects/TV#1   - 122 -

        объект TView - это абстрактный объект,  представляющий собой пус-
        тую  прямоугольную зону на экране.  Использование объекта TView в
        качестве предшественника (предка) гарантирует, что каждому порож-
        денному отображаемому элементу будет,  по крайней мере, принадле-
        жать прямоугольная зона на экране и минимальный виртуальный метод
        Draw (это вынуждает все непосредственно порождаемые объекты иметь
        специфический метод Draw).

             Turbo Vision включает в себя следующие стандартные отобража-
        емые элементы:

             - рамки;
             - строки ввода;
             - статический текст;
             - командные кнопки;
             - области просмотра списков;
             - метки;
             - кластеры;
             - элементы прокрутки;
             - строки состояния;
             - меню;
             - полосы прокрутки;
             - протоколы;
             - текстовые устройства.

                                      Рамки
        ─────────────────────────────────────────────────────────────────

             Объект TFrame предоставляет выводимую на экран рамку (грани-
        цу) для изображения объекта TWindow,  вместе с пиктограммами  для
        перемещения и закрытия окна.  Объекты TFrame никогда не использу-
        ются сами по себе, а только вместе с объектом TWindow.

                                Командные кнопки
        ─────────────────────────────────────────────────────────────────

             Объект TButton представляет собой окно с заголовком;  он ис-
        пользуется для генерации при "нажатии" кнопки  специфической  ко-
        манды.  Такие  объекты обычно помещаются в окна диалога и предос-
        тавляют выбор между "OK" (Подтверждение) и "Cancel" (Отмена). Ок-
        но  диалога  при  появлении обычно является режимным отображаемым
        элементом,  поэтому оно перехватывает и обрабатывает все события,
        включая  "нажатия"  кнопки.  Обработчик событий располагает рядом
        способов "нажатия" кнопки: щелчок кнопкой "мыши" в прямоугольнике
        командной кнопки,  набор на клавиатуре сокращенной буквы, или вы-
        бор кнопки, заданной по умолчанию, с помощью клавиши Enter.

                                    Кластеры
        ─────────────────────────────────────────────────────────────────

             Объект TCluster является абстрактным типом,  который исполь-
        зуется для реализации кнопок с зависимой и независимой фиксацией.
        Кластер - это группа элементов управления, которые одинаково реа-

         B.Pascal 7 & Objects/TV#1   - 123 -

        гируют на события. Элементы управления кластера бывают часто свя-
        заны с объектами TLabel,  что позволяет выбирать управляющий эле-
        мент посредством выбора соседней  пояснительной  метки.  Дополни-
        тельными  полями  являются  поле  Value,  представляющее заданное
        пользователем значение,  и  Sel,  указывающее  выбранный  элемент
        кластера. Имеются также методы изображения текстовых пиктограмм и
        символов отметки. Для отметки элементов управления в кластере мо-
        гут быть использованы клавиши курсора и кнопки "мыши".

             Кнопки с  зависимой фиксацией - это специальные кластеры,  в
        которых может быть выбран лишь один  элемент  управления.  Каждый
        последующий  выбор  отменяет  текущий (как и в случае с кнопочным
        переключателем диапазона автомобильного приемника).  Кнопки с не-
        зависимой  фиксацией  - это кластеры,  в которых может включаться
        (выбираться) любое число элементов управления.

                                      Меню
        ─────────────────────────────────────────────────────────────────

             Объект TMenuView  и  два его порождения - объекты TMenuBar и
        TMenuBox, предоставляют основные объекты для создания спускающих-
        ся  меню  и вложенных до любого уровня подменю.  Вы представляете
        строки текста для пунктов меню (с произвольными выделенными  бук-
        вами-сокращениями) вместе с командами,  связанными с каждым пунк-
        том.  Методы  HandleEvent  управляют механизмом выбора меню с по-
        мощью "мыши" и/или клавиатуры (включая букву-сокращение и  опера-
        тивную клавишу).

             По умолчанию в приложениях Turbo Vision для полосы меню  ре-
        зервируется верхняя строка экрана,  из которой выводятся спускаю-
        щиеся меню. Вы можете также создать блоки всплывающих меню, выво-
        димых в ответ на щелчки "мышью".  Подробнее о меню рассказывается
        в Главе 10 "Объекты приложения".

                                    Протоколы
        ─────────────────────────────────────────────────────────────────

             Абстрактный тип  объекта THistory реализует механизм подбора
        списков по родовому принципу. Два его дополнительных поля, Link и
        HistoryId, предоставляют каждому объекту THistory связанный с ним
        объект TInputLine и имя (идентификатор) списка предыдущих элемен-
        тов в  строке ввода.  Объект THistory функционирует в сочетании с
        объектами THistoryWindow и THistoryViewer. О протоколах подробнее
        рассказывается в Главе 12 "Объекты управляющих элементов".

                                  Строки ввода
        ─────────────────────────────────────────────────────────────────

             Объект TInputLine - это специализированный отображаемый эле-
        мент,  который  предоставляет  базовый  строковый редактор строки
        ввода. Он обрабатывает весь обычный ввод с клавиатуры и перемеще-
        ния курсора (включая команды Home и End), выполняет операции уда-
        ления и вставки в режимах вставки/замены, а также выполняет авто-

         B.Pascal 7 & Objects/TV#1   - 124 -

        матическое управление формой курсора.  Для выделения в окне отме-
        ченного текста может быть использована "мышь".  О  строках  ввода
        рассказывается в Главе 12 "Объекты управляющих элементов".

                            Области просмотра списков
        ─────────────────────────────────────────────────────────────────

             Тип объекта TListViewer - это абстрактный  базовый  тип,  от
        которого порождаются различного рода средства для просмотра спис-
        ков, такие как TListBox. Поля и методы объекта TListViewer позво-
        ляют  вам  получить изображение связанных списков строк с возмож-
        ностью управления одной  или  двумя  полосами  прокрутки.  Объект
        TListBox,  порожденный от объекта TListViewer, реализует наиболее
        распространенные окна списка,  т.е.  окна для вывода  изображения
        таких  списков  строк,  как  имена файлов.  Подробнее об областях
        просмотра списка и блоках списка рассказывается в Главе 12  "Объ-
        екты управляющих элементов".

                      Прокручиваемые отображаемые элементы
        ─────────────────────────────────────────────────────────────────

             Объект TScroller - это прокручиваемый отображаемый  элемент,
        который  служит "воротами" в другой более крупный "фоновый" види-
        мый элемент.  Прокрутка осуществляется при вводе с клавиатуры или
        действиях  с  объектами,  ассоциированными с TScrollBar.  Объекты
        прокрутки поясняются в Главе 8 "Отображаемые элементы"

                                Полосы прокрутки
        ─────────────────────────────────────────────────────────────────

             Объекты TScrollBar допускают управление  либо  вертикальной,
        либо горизонтальной  прокруткой.  Ключевыми  полями этих объектов
        являются Value (положение индикатора  полосы  прокрутки),  PgStep
        (величина прокрутки в соответствии с нажатием кнопки  "мыши"  или
        клавиш PgUp и PgDn) и ArStep (величина прокрутки в соответствии с
        нажатием кнопки "мыши" или клавиш со стрелками).  О полосах прок-
        рутки  подробнее  рассказывается  в Главе 12 "Объекты управляющих
        элементов".

                              Текстовые устройства
        ─────────────────────────────────────────────────────────────────

             Объект TTextDevice  -  это средство просмотра текста/драйвер
        устройства с прокруткой типа TTY. Кроме полей и методов, наследу-
        емых от  объекта TScroller,  объект TTеxtDevice определяет вирту-
        альные методы чтения и записи строк с устройства и в  устройство.
        Объект TTextDevice  является  лишь  базовым  типом для порождения
        действительных терминальных драйверов. Объект TTextDevice исполь-
        зует конструктор и деструктор объекта TScroller. Объект TTerminal
        реализует терминал ввода-вывода с буферными устройствами чтения и
        записи строк. Размер буфера определяется при инициализации. Текс-
        товые устройства поясняются в Главе 15 "Редактируемые и текстовые
        отображаемые элементы".

         B.Pascal 7 & Objects/TV#1   - 125 -


                                Статический текст
        ─────────────────────────────────────────────────────────────────

             Объекты TStaticText - это простые отображаемые элементы, ис-
        пользуемые  для изображения фиксированных строк,  предоставляемых
        полем Text.  Они игнорируют все передаваемые в них  события.  Тип
        объекта TLabel добавляет данному объекту такое свойство,  что ви-
        димый элемент, содержащий текст и имеющий метку, может выполнять-
        ся путем нажатия кнопки "мыши",  клавиши курсора или клавиш Alt с
        сокращенными названиями. Дополнительное поле Link связывает метку
        с другим обычно управляющим видом, который обрабатывает все собы-
        тия,  связанные с метками. Выбор метки влечет за собой выбор свя-
        занного  с  ней элемента управления,  а выбор связанного элемента
        управления вызывает выделение метки так же как и элемента  управ-
        ления. Статический текст и метки поясняются подробнее рассказыва-
        ется в Главе 12 "Объекты управляющих элементов".

                                Строки состояния
        ─────────────────────────────────────────────────────────────────

             Объект TStatusLine предназначен для вывода различной  инфор-
        мации о состоянии и подсказок (помощи).  Вывод обычно выполняется
        в нижней строке экрана. Строка состояния - это полоса с высотой в
        один символ и с любой длиной вплоть до ширины экрана. Объект реа-
        лизует динамический вывод на экран "отражения" различных событий,
        происходящих в выполняемой прикладной программе. О строках состо-
        яния рассказывается в Главе 10 "Объекты приложения".



         B.Pascal 7 & Objects/TV#1   - 126 -

                         Групповые отображаемые элементы
        ─────────────────────────────────────────────────────────────────

             Значимость объекта TView наглядно представлена в иерархичес-
        кой схеме,  изображенной на Рис.  3.1.  Все объекты,  имеющиеся в
        программе Turbo Vision, являются тем или иным образом порожденны-
        ми от объекта TView. Однако ряд этих видимых объектов имеют еще и
        другое значение: они обеспечивают согласованность действий разных
        объектов.

             Turbo Vision включает в себя следующие стандартные групповые
        отображаемые элементы:

             - абстрактную группу;

             - окна;

             - приложения;

             - диалоговые окна;

             - оперативные области.

                               Абстрактная группа
        ─────────────────────────────────────────────────────────────────

             Объект TGroup  позволяет  обрабатывать динамически созданные
        списки взаимодействующих  отображаемых  подэлементов  посредством
        отображаемого элемента-владельца группы. Каждый отображаемый эле-
        мент имеет поле,  которое указывает на его предка TGroup.  Пустой
        указатель nil означает, что у отображаемого элемента нет владель-
        ца. Другое обеспечивает связь со следующим отображаемым элементом
        в цепочке.  Т.к. группа является отображаемым элементом, то в ней
        могут быть другие отображаемые элементы,  которые, в свою очередь
        являются группами,  имеющими собственные отображаемые элементы  и
        т.д.  Могут  быть  созданы новые группы и добавлены (вставлены) к
        ним или удалены из них отображаемые элементы. Группы и отображае-
        мые подэлементы поясняются в Главе 8 "Отображаемые элементы".

                                   Приложения
        ─────────────────────────────────────────────────────────────────

             TProgram - это абстрактный тип,  обеспечивающий набор вирту-
        альных методов для своих потомков. Объект TApplication предостав-
        ляет вам объект шаблона программы для вашей прикладной  программы
        Turbo  Vision.  Он  является  порождением  объекта  TGroup (через
        TProgram).  Обычно он  владеет  подвидами  TMenuBar,  TDeskTop  и
        TStatusLine.  Объект TApplication располагает методами для созда-
        ния и вставки этих трех отображаемых элементов.  Ключевым методом
        объекта TApplication является метод TApplication.Run, который за-
        пускает на исполнение фрагмент прикладной программы (приложения).
        Объекты приложения поясняются в Главе 10 "Объекты приложения".


         B.Pascal 7 & Objects/TV#1   - 127 -

                               Оперативные области
        ─────────────────────────────────────────────────────────────────

             Объект TDeskTop - это обычный исходный отображаемый  элемент
        фона,  представляющий привычную для пользователя оперативную (ра-
        бочую) область,  вокруг которой обычно расположены строка меню  и
        строка состояния. Обычно объект TApplication будет являться собс-
        твенником  группы,  содержащей  объекты  TDeskTop,   TMenuBar   и
        TStatusLine. Другие отображаемые элементы (такие как окна и рамки
        диалога) создаются, изображаются и управляются (обрабатываются) в
        оперативной области в соответствии с действиями пользователя (на-
        жатия кнопок "мыши" или клавиш на клавиатуре). Основная часть ра-
        боты с программой выполняется в оперативной области.  Оперативные
        области поясняются в Главе 10 "Объекты приложения".

                                      Окна
        ─────────────────────────────────────────────────────────────────

             Объекты TWindow,  с  помощью ассоциированных с ними объектов
        TFrame являются обычными изображениями, ограниченными прямоуголь-
        ной  рамкой,  которые  вы можете сдвигать по экрану,  изменять их
        размеры и делать невидимыми с  помощью  методов,  наследуемых  от
        объекта  TView.  Поле  по  имени  Frame  указывает на объект окна
        TFrame.  Объект ТWindow может также изменять масштаб своего изоб-
        ражения  ("распахиваться")  и закрываться.  Выбор пронумерованных
        окон осуществляется с помощью оперативных клавиш Alt+n.  Об окон-
        ных объектах рассказывается в Главе 11 "Объекты окон и диалоговых
        окон".

                                  Окна диалога
        ─────────────────────────────────────────────────────────────────

             Объект TDialog  является порождением из объекта TWindow.  Он
        используется для  создания  окон  диалога для обеспечения взаимо-
        действия с пользователями.  Окна диалога обычно содержат элементы
        управления, такие как командные кнопки  и  кнопки  с  независимой
        фиксацией. Основным  отличием окон и диалоговых окон является то,
        что диалоговые окна специализированы для режимных операций. О ди-
        алоговых окнах рассказывается в Главе 11 "Объекты окон и диалого-
        вых окон".

                              Механизмы и средства
        ─────────────────────────────────────────────────────────────────

             Turbo Vision включает в себя пять групп не отображаемых объ-
        ектов, производных из TObject:

             - потоки;

             - файлы ресурсов;

             - наборы;


         B.Pascal 7 & Objects/TV#1   - 128 -

             - строковые списки;

             - средства проверки допустимости.

                                     Потоки
        ─────────────────────────────────────────────────────────────────

             Потоком является обобщенный объект для реализации  ввода-вы-
        вода. При  традиционной организации операции ввода-вывода в файлы
        и устройства для реализации преобразований различных типов данных
        разрабатываются различные наборы функций. С помощью потоков, пре-
        доставляемых Turbo Vision,  вы можете  создавать  полиморфические
        методы ввода-вывода, такие как Read, Write, для которых будет из-
        вестно как обрабатывать содержимое их собственных конкретных  по-
        токов.

             TStream является базовым абстрактным  объектом,  реализующим
        полиморфический ввод-вывод  для различных запоминающих устройств.
        Turbo Vision включает в себя также ряд  специализированных  пото-
        ков, включая потоки DOS, буферизированные потоки, потоки памяти и
        потоки EMS. О потоках рассказывается в Главе 17 "Потоки".

                                     Ресурсы
        ─────────────────────────────────────────────────────────────────

             Файл ресурсов является особым видом потока,  в котором родс-
        твенные объекты ("элементы") могут быть индексированы через стро-
        ковые  ключи.  Чтобы  не  порождать  файлы  ресурсов  из  объекта
        TStream,  TResourceFile имеет поле Stream,  ассоциирующее поток с
        файлом ресурсов. О ресурсах рассказывается в Главе 18 "Ресурсы".

                                     Наборы
        ─────────────────────────────────────────────────────────────────

             Объект TCollection реализует обобщенное множество элементов,
        включая произвольные объекты различных типов. В отличие от масси-
        вов, множеств  и списков не объектно-ориентированных языков набор
        Turbo Vision  допускает  динамическое  задание  размеров.  Объект
        Collection  - это абстрактная основа для более специализированных
        наборов, таких как TSortedCollection. Turbo Vision включает в се-
        бя несколько специализированных типов наборов,  включая абстракт-
        ные отсортированные наборы и наборы строк.  Подробнее  о  наборах
        рассказывается в Главе 16 "Наборы".

                                Строковые списки
        ─────────────────────────────────────────────────────────────────

             Объект TStringList  реализует специальный вид строкового ре-
        сурса, в котором доступ к строкам осуществляется  через  числовой
        индекс.  Применение объекта TStringList упрощает процесс интерна-
        ционализации  и  разработку  многоязычных   текстовых   программ.
        TStringList  предлагает  доступ  только  к существующим строковым
        спискам с числовыми индексами.  Для создания строкового списка  и

         B.Pascal 7 & Objects/TV#1   - 129 -

        выполнения  добавлений  к нему используется объект TStrListMaker.
        TStrListMaker предусматривает метод Put для добавления  строки  к
        строковому  списку  и  метод Store для сохранения списков строк в
        потоке.

                         Средства проверки допустимости
        ─────────────────────────────────────────────────────────────────

             TValidator представляет  собой  абстрактный  объект проверки
        допустимости, используемый в качестве основы для семейства объек-
        тов, применяемых для проверки допустимости строк ввода. Полезными
        объектами проверки   допустимости   являются    TFilterValidator,
        TRangeValidator, TlookupValidator,    TStringLookupValidator    и
        TPXPictureValidator, которые наследуют свое основное поведение от
        TValidator, но  обеспечивают различные формы проверки допустимос-
        ти. Все объекты проверки допустимости и их использование  поясня-
        ются в Главе 13 "Объекты проверки допустимости данных".

                             Координаты Turbo Vision
        ─────────────────────────────────────────────────────────────────

             Метод присваивания координат, принятый в Turbo Vision, может
        отличаться от известных вам методов.  Разница заключается в  том,
        что в отличие от большинства систем координат, в которых на экра-
        не задается местоположение символов,  в Turbo Vision координатами
        задается сетка между символами. Это выглядит странным, но, как вы
        увидите, такая система прекрасно работает при задании границ объ-
        ектов отображаемых элементов.

             Точка в  системе  координат задается своими координатами (X,
        Y) позиции экрана.  Объект TPoint инкапсулирует координаты в свои
        поля  X и Y.  Объект TPoint не имеет методов,  но позволяет легко
        работать с координатами как с одним элементом.



         B.Pascal 7 & Objects/TV#1   - 130 -

                                 Задание границ
        ─────────────────────────────────────────────────────────────────

             Каждый элемент в Turbo Vision - это  прямоугольник,  опреде-
        ленный  объектом прямоугольника типа TRect.  Данный объект предс-
        тавляет прямоугольник.  Его поля A и B являются объектами TPoint,
        определяющими верхнюю левую и нижнюю правую точки прямоугольника.
        При задании границ объекта отображаемого  элемента  вы  передаете
        эти границы конструктору отображаемого элемента в объекте TRect.

             Например, если  R  является  объектом  TRect,  то  выражение
        R.Assign(0, 0,  0, 0) определяет прямоугольник, не имеющий разме-
        ров - это всего лишь точка. Наименьший прямоугольник, который мо-
        жет содержать какую-либо информацию, может быть определен выраже-
        нием:

             R.Assign(0, 0, 1, 1).

             На Рис. 7.1 показан объект TRect, определенный выражением:

             R.Assign(2, 2, 5, 4).

                          0   1   2   3   4   5   6   7
                         0┌───┬───┬───┬───┬───┬───┬───┐
                          │   │   │   │   │   │   │   │
                         1├───┼───┼───┼───┼───┼───┼───┤
                          │   │   │   │   │   │   │   │
                         2├───┼───┼───┴───┴───┼───┼───┤
                          │   │   │███████████│   │   │
                         3├───┼───┤███████████├───┼───┤
                          │   │   │███████████│   │   │
                         4├───┼───┼───┬───┬───┼───┼───┤
                          │   │   │   │   │   │   │   │
                         5└───┴───┴───┴───┴───┴───┴───┘

             Рис. 7.1. Система координат Turbo Vision.

             Т.о., выражение R.Assign(2,  2, 5, 4) определяет прямоуголь-
        ник, содержащий 6  знакомест.  Хотя  подобная  система  координат
        несколько необычна, она существенно упрощает определение размеров
        прямоугольников, координат смежных прямоугольников,  а также дру-
        гих объектов.



         B.Pascal 7 & Objects/TV#1   - 131 -

                        Локальные и глобальные координаты
        ─────────────────────────────────────────────────────────────────

             В некоторых случаях вам нужно знать о том,  с какой  коорди-
        натной системой вы работаете.  В большинстве случаев отображаемый
        элемент имеет дело только со своей собственной координатной  сис-
        темой, началом  которой является верхний левый угол отображаемого
        элемента. Когда вы помещаете в диалоговое окно,  например, управ-
        ляющий элемент,  то  задаете его расположение относительно начала
        диалогового окна. Таким образом, при перемещении диалогового окна
        управляющий элемент перемещается вместе с диалоговым окном.

             Единственный момент,  когда вас должна беспокоить другая ко-
        ординатная система,  это момент обработки  позиционного  события,
        такого как  щелчок кнопкой "мыши".  Щелчки "мышью" обрабатываются
        приложением, а позиция щелчка записывается в  приложении  в  гло-
        бальной координатной системе.  Началом глобальной системы коорди-
        нат является верхний левый угол экрана.  Определив, где на экране
        пользователь щелкнув кнопкой "мыши", приложение может какой отоб-
        ражаемый элемент на экране должен реагировать на событие.

                   Примечание: О  событиях   позиционирования   подробнее
              рассказывается в Главе 9 "Программирование, управляемое со-
              бытиями".

             Когда отображаемому элементу требуется ответить на такое со-
        бытие, он должен преобразовать глобальные координаты в локальные.
        Каждый отображаемый элемент наследует метод с  именем  MakeLocal,
        который преобразует  глобальные координаты точки экрана в локаль-
        ные координаты.  Если   необходимо,   используя   другой   метод,
        MakeGlobal, он  может преобразовывать локальные координаты в гло-
        бальные.



         B.Pascal 7 & Objects/TV#1   - 132 -

                           Использование битовых полей
        ─────────────────────────────────────────────────────────────────

             Отображаемые элементы  Turbo Vision используют несколько по-
        лей, которые называются битовыми полями.  То есть, они используют
        отдельные биты  байта  или  слова для указания отдельных свойств.
        Отдельные биты обычно называются флагами,  поскольку их можно ус-
        танавливать (присваивать  им значение 1) или сбрасывать (присваи-
        вать нулевое значение),  а состояние их указывает на  активизацию
        указанного свойства.

             Например, каждый отображаемый элемент имеет битовое поле ти-
        па Word с именем Options.  Каждый отдельный бит этого слова имеет
        для Turbo  Vision различный смысл.  На следующем рисунке показаны
        определения бит в слове Options:

               ┌──────── TView.Options ────────┐
               msb                           lsb
                    ┌─┬─────────────────────────── ofVersion
                    │ │     ┌─┬─────────────────── ofCentered
               ╔═╤═╤╧╤╧╤═╤═╤╧╤╧╤═╤═╤═╤═╤═╤═╤═╤═╗
               ╚╤╧╤╧═╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╝
                └─┤   │ │ │ │ │ │ │ │ │ │ │ │ └─── ofSelectable
                  │   │ │ │ │ │ │ │ │ │ │ │ └───── ofTopSelect
        не определены─│─┘ │ │ │ │ │ │ │ │ └─────── ofFirstClick
                      │   │ │ │ │ │ │ │ └───────── ofFramed
                      │   │ │ │ │ │ │ └─────────── ofPreProcess
                      │   │ │ │ │ │ └───────────── ofPostProcess
                      │   │ │ │ │ └─────────────── ofBuffered
                      │   │ │ │ └───────────────── ofTileable
                      │   │ │ └─────────────────── ofCenterX
                      │   │ └───────────────────── ofCenterY
                      │   └─────────────────────── ofValidate
                      └─────────────────────────── ofVersion20

             Рис. 7.4 Битовые флаги Options



         B.Pascal 7 & Objects/TV#1   - 133 -

                                 Значения флага
        ─────────────────────────────────────────────────────────────────

             На Рис.  7.4 msb указывает "наиболее значащий бит",  который
        называется также старшим битом, поскольку при построении двоично-
        го числа бит имеет наивысшее значение (2^15).  Бит в нижней части
        двоичного числа отмечен как lsb - "наименее значащий бит",  кото-
        рый называется также "младшим битом".

             Так, например,  четвертый бит называется ofFramed.  Если  он
        установлен в 1,  то это означает,  что отображаемый элемент будет
        иметь рамку.  Если бит установлен в 0, то отображаемый элемент не
        имеет рамки.

             Обычно вам  не нужно беспокоиться о том,  какие значения со-
        держатся в битовых флагах,  если вы не планируете определить свои
        собственные. Даже  в последнем случае вам нужно только обеспечить
        уникальность своих определений.  Старшие биты в слове  Options  в
        настоящее время в Turbo Vision не определены.

                                  Битовые маски
        ─────────────────────────────────────────────────────────────────

             Маска - это удобный способ работы с группами битовых флагов.
        Например, Turbo Vision определяет маски для различного вида собы-
        тий. Маска evMouse просто содержит все четыре бита, которые обоз-
        начают различные виды событий "мыши", так что когда отображаемому
        элементу требуется проверять события "мыши",  он  может  сравнить
        тип события и увидеть, присутствует ли он в маске, а не проверять
        каждый отдельный бит события "мыши".

                              Поразрядные операции
        ─────────────────────────────────────────────────────────────────

             Паскаль обеспечивает достаточное число полезных операций для
        работы с отдельными битами.  Вместо того,  чтобы давать детальные
        пояснения по тому,  как работает каждая из них, мы просто сообщим
        вам, что каждая из них делает.



         B.Pascal 7 & Objects/TV#1   - 134 -

                                  Установка бит
        ─────────────────────────────────────────────────────────────────

             Чтобы установить  бит,  используйте  операцию or.  Например,
        чтобы установить бит ofPostProcess в поле Options командной кноп-
        ки MyButton, можно использовать оператор:

             MyButton.Options := MyButton.Options or ofPostProcess;

             Если вы не уверены абсолютно в том, что делаете, вам не сле-
        дует для установки бит использовать  сложение.  Например,  вместо
        приведенного выше кода вы можете записать:

             MyButton.Options := MyButton.Options + ofPostProcess;

        и ваша  операция  будет работать тогда и только тогда,  когда бит
        ofProcess еще не установлен.  Поэтому пользоваться этим не следу-
        ет. Если бит уже был установлен,  когда вы складываете его с дру-
        гим битом,  то при двоичном сложении произойдет перенос в  другой
        бит (ofBuffered),  устанавливая  или сбрасывая его (в зависимости
        от первоначального состояния).

             Другими словами, поразрядное сложение дает нежелательные по-
        бочные эффекты. Для установки бит используйте операцию or.

             Перед завершением  темы  установки бит заметим,  что в одной
        операции or вы можете установить несколько бит  сразу.  Следующий
        код в  отображаемом  элементе прокрутки с именем MyScroller уста-
        навливает сразу два различных флага:

             MyScroller.GrowMode := MyScroller.GrowMode or gfGrowHiX
                                                or gfGrowHiY;

                                   Очистка бит
        ─────────────────────────────────────────────────────────────────

             Очистка бита выполняется также легко, как его установка. Ис-
        пользуется просто  другая операция.  Наилучший способ сделать это
        состоит в комбинации двух поразрядных операций and и not.  Напри-
        мер, чтобы  очистить бит dmLimitLoX в поле DragMode метки ALabel,
        можно использовать следующее:

             ALabel.DragMode := ALabel and not dmLimitLoX;

             Как и в случае установки бит,  в одной операции можно  очис-
        тить несколько бит сразу.



         B.Pascal 7 & Objects/TV#1   - 135 -

                                Переключение бит
        ─────────────────────────────────────────────────────────────────

             Иногда желательно переключить бит.  Это означает,  что нужно
        установить его, если бит сброшен (очищен), или сбросить,  если он
        установлен. Для этого используется операция xor.  Например, чтобы
        переключить горизонтальное центрирование диалогового окна ADialog
        в оперативной области, переключите флаг ofCenterX следующим обра-
        зом:

             ADialog.Options := Adialog.Options xor ofCenterX;

                                  Проверка бит
        ─────────────────────────────────────────────────────────────────

             Достаточно часто отображаемому  элементу  желательно  прове-
        рить, установлен ли отдельный битовый флаг. При этом используется
        операция and.  Например,  чтобы увидеть,  можно ли  вывести  окно
        AWindow в оперативной области без перекрытия, вам нужно проверить
        бит ofTileable:

             if AWindow.Options and ofTileable = ofTileable then ...

                               Использование масок
        ─────────────────────────────────────────────────────────────────

             Аналогично проверке  отдельных  бит,  вы можете использовать
        операцию and для проверки установки одного или более  маскирован-
        ных бит.  Например,  чтобы определить, содержит ли запись события
        некоторый вид событий "мыши", можно записать:

             if Event.What and evMouse <> 0 then ...

                                      Итоги
        ─────────────────────────────────────────────────────────────────

             Поразрядные операции перечислены в следующей таблице.

                            Работа с битовыми полями          Таблица 7.2
        ┌─────────────────────────────┬─────────────────────────────────┐
        │   Чтобы сделать следующее:  │       Используйте код:          │
        ├─────────────────────────────┼─────────────────────────────────┤
        │   Установить бит            │ field := field or flag;         │
        │   Очистить бит              │ field := field and not flag;    │
        │   Переключить бит           │ field := field xor flag;        │
        │   Проверить установку флага │ if fiald and flag = flag then...│
        │   Проверить флаг в маске    │ if flag and mask <> 0 then...   │
        └─────────────────────────────┴─────────────────────────────────┘



         B.Pascal 7 & Objects/TV#1   - 136 -

─────────────────────────────────────────────────────────────────────────
                         ГЛАВА 8. Отображаемые элементы
        ─────────────────────────────────────────────────────────────────

             Одним из ключевых вопросов в Turbo Vision является  система,
        используемая для  представления  информации на экране,  в которой
        применяются отображаемые элементы.  Отображаемые элементы  -  это
        объекты, представляющие  прямоугольную  область  на  экране.  Это
        единственный способ, с помощью которого Turbo Vision может вывес-
        ти информацию пользователю.

             В данной главе вы изучите следующее:

             - что такое отображаемый элемент?

             - что такое группа?

             - как использовать отображаемые элементы;

             - как использовать группы.

             Поскольку отображаемые элементы являются объектами, они нас-
        ледуют свои основные  свойства  от  общего  предка  TView.  Turbo
        Vision определяет  также специализированные объекты,  наследующие
        от TView,  такие как окна, диалоговые окна, приложения, оператив-
        ные области, меню и т.д.

             В других  главах  данной части руководства описывается,  как
        использовать эти специальные  отображаемые  элементы,  но  данная
        глава сосредоточена  на  принципах,  общих  для всех отображаемых
        элементов.

                         Что такое отображаемый элемент?
        ─────────────────────────────────────────────────────────────────

             В отличие от программ Паскаля,  с которыми вы, возможно, ра-
        ботали, приложения Turbo Vision в общем случае для вывода  инфор-
        мации на  экран  не  используют операции Write и Writeln.  Вместо
        этого в приложениях Turbo Vision используются  отображаемые  эле-
        менты - объекты, которые знают, как представлять себя на экране.

                       Определение отображаемого элемента
        ─────────────────────────────────────────────────────────────────

             Основным кирпичиком в построении прикладных  программ  Turbo
        Vision является отображаемый элемент.  Отображаемый элемент - это
        объект в языке Паскаль, который управляет прямоугольной зоной эк-
        рана. Например, строка меню в верхней части экрана является отоб-
        ражаемым элементом.  Любое действие программы, выполняемое в дан-
        ной области экрана (например, нажатие кнопки "мыши" на строке ме-
        ню),  будет реализовано через отображаемый  элемент,  управляющий
        этой областью.

             В общем случае все,  что выводится на экран программой Turbo

         B.Pascal 7 & Objects/TV#1   - 137 -

        Vision должно быть отображаемым элементом,  то есть являться  по-
        томком объектного  типа  TView.  Все отображаемые элементы должны
        делать следующее:

             - управлять прямоугольной областью экрана;

             - отображаться на экране по запросу;

             - обрабатывать события в своих границах.

             В стандартных отображаемых элементах Turbo  Vision  все  это
        выполняется автоматически,  и отображаемые элемента,  создаваемые
        вами для приложений,  будут наследовать эти способности (либо вам
        придется добавить  их в свои объекты).  Давайте рассмотрим каждое
        из этих свойств более подробно.

                        Определение прямоугольной области
        ─────────────────────────────────────────────────────────────────

             При построении объекта отображаемого элемента вы присваивае-
        те его границы, обычно в форме объекта прямоугольной области типа
        TRect. О  прямоугольных границах и системе координат Turbo Vision
        подробнее рассказывается в Главе 11,  но важно, чтобы вы помнили,
        что отображаемый элемент ограничен прямоугольной областью,  опре-
        деляемой его границами.

                             Отображение по запросу
        ─────────────────────────────────────────────────────────────────

             Наиболее важным  свойством  отображаемого  элемента является
        то, что он знает,  как изображать себя на экране. Например, когда
        вы хотите разместить в верхней части экране приложения полосу ме-
        ню, то строите отображаемый элемент полосы меню, задавая ему гра-
        ницы верхней строки экрана и определяя список пунктов меню. Отоб-
        ражаемый элемент строки меню знает,  как представить эти пункты в
        нужном месте.

             Вам не  нужно  заботиться  о  том,  когда появится на экране
        отображаемый элемент.  Вы определяете для отображаемого  элемента
        метод с именем Draw, заполняющий всю область в рамках ограничива-
        ющего прямоугольника. Turbo Vision вызывает метод Draw, когда она
        знает, что  нужно вывести отображаемый элемент,  например,  когда
        закрывается окно, перекрывающее на экране данное окно.

             При работе с методом Draw следует помнить два важных  момен-
        та:
             - отображаемый  элемент  должен  заполнять всю прямоугольную
               область;
             - отображаемый элемент должен иметь  возможность  вывода  на
               экран в любое время.

             Подробнее о методах Draw рассказывается ниже.

         B.Pascal 7 & Objects/TV#1   - 138 -

                                Обработка событий
        ─────────────────────────────────────────────────────────────────

             Третьим свойством любого объекта отображаемого элемента  яв-
        ляется то,  что он должен иметь возможность обрабатывать происхо-
        дящие в его границах события,  такие как щелчок кнопкой "мыши"  и
        нажатия клавиши.  Обработка событий подробно поясняется в Главе 9
        "Программирование, управляемое событиями".  Нужно просто помнить,
        что отображаемый элемент отвечает за любое событие в своих грани-
        цах.

                                Что такое группа?
        ─────────────────────────────────────────────────────────────────

             Иногда простейшим способом управления отображаемым элементом
        своей областью является делегирование определенных частей  работы
        другим отображаемым  элементам,  которые называются отображаемыми
        подэлементами. Отображаемый элемент,  который имеет  подэлементы,
        называется группой. Любой отображаемый элемент может быть подэле-
        ментом, но группа должна быть потомком TGroup,  который,  в  свою
        очередь, является потомком TView.  О группе с подэлементами гово-
        рят, что она является владельцем отображаемых  подэлементов  (так
        как она  ими управляет).  Каждый подэлемент называют отображаемым
        подэлементом владельца, то есть группы, которой он принадлежит.

             Наглядным примером,  который вы обычно не  рассматриваете  в
        качестве  отображаемого  элемента,  здесь  может  служить  объект
        TApplication - само приложение.  TApplication - это  отображаемый
        элемент, который управляет областью экрана, фактически всем экра-
        ном. TApplication является также группой, которой принадлежат три
        ее отображаемых элемента:  строка меню,  рабочая область и строка
        состояния, которые предназначены для взаимодействия с пользовате-
        лем.  Как  вы увидите,  то что выглядит для пользователя как один
        объект (типа окна),  часто представляет  собой  группу  связанных
        отображаемых элементов.

                          Передача функций подэлементам
        ─────────────────────────────────────────────────────────────────

             Поскольку группа является отображаемым элементом, к ней при-
        менимы все правила, действующие для отображаемых элементов. Груп-
        па покрывает прямоугольную область, отображается по запросу и уп-
        равляет событиями в своих границах. Основной разницей здесь явля-
        ется то, что группы обрабатывают большинство этих операций, деле-
        гируя их своим отображаемым подэлементам.

             Например, метод Draw группы в общем случае ничего не рисует.
        Вместо этого он вызывает поочередно соответствующий метод каждого
        подэлемента группы для их отображения. Таким образом, в результа-
        те выполнения методов Draw всех отображаемых подэлементов  покры-
        вается вся прямоугольная область.

         B.Pascal 7 & Objects/TV#1   - 139 -


                  Использование объектов отображаемых элементов
        ─────────────────────────────────────────────────────────────────

             Предком всех отображаемых элементов  Turbo  Vision  является
        TObject.  Он даже нечто большее,  чем общий предок всех объектов,
        обеспечивающий, например, полиморфические операции объектов с по-
        токами. Само программное средство Turbo Vision в действительности
        начинается с объекта TView.

             Объект TView - это абстрактный объектный тип, используемый в
        качестве общего  предка  всех отображаемых элементов.  Пока вы не
        захотите создать в целях прототипизации пустой  прямоугольник  на
        экране, нет особых причин создавать экземпляры TView. Хотя объект
        TView визуально прост, он содержит все основные методы и поля уп-
        равления экраном Turbo Vision.  В данном разделе описываются сле-
        дующие задачи, необходимые вам для работы с отображаемыми элемен-
        тами:

             - построение объектов отображаемых элементов;

             - управление границами отображаемых элементов;

             - вывод отображаемого элемента на экран;

             - управление курсором;

             - установка флагов состояния;

             - проверка допустимости отображаемого элемента.

                   Построение объектов отображаемых элементов
        ─────────────────────────────────────────────────────────────────

             Хотя вам,  возможно,  не  придется строить экземпляры TView,
        все производные из TView объекты отображаемых элементов  вызывают
        в своих конструкторах конструктор TView.  Поэтому важно понимать,
        что этот конструктор делает.

             По соглашению все конструкторы объектов Turbo Vision вызыва-
        ют Init.  Конструктор  TView.Init воспринимает единственный пара-
        метр - ограничивающий прямоугольник отображаемого элемента:

             constructor TView(var Bounds: TRect);

                         Вызов наследуемого конструктора
        ─────────────────────────────────────────────────────────────────

             Перед тем  как делать что-то еще,  TView.Init вызывает конс-
        труктор Init,  наследуемый из TObject, который заполняет все поля
        отображаемого элемента нулями.  Поскольку все другие конструкторы
        отображаемых элементов вызывают в результате TObject.Init, убеди-
        тесь, что  вы  не инициализируете поля перед вызовом наследуемого

         B.Pascal 7 & Objects/TV#1   - 140 -

        конструктора.

             Конструктор Init   воспринимает  передаваемый  ему  параметр
        Bounds и устанавливает на его основе два важных поля -  Origin  и
        Size. Origin - это верхний левый угол ограничивающего прямоуголь-
        ника. Параметр Size содержит ширину и высоту прямоугольника.

                   Управление границами отображаемого элемента
        ─────────────────────────────────────────────────────────────────

             Расположение отображаемого элемента определяется двумя  точ-
        ками: его  верхним  левым  углом (началом) и нижним правым углом.
        Каждая из этих точек представляется в объекте полем типа  TPoint.
        Origin указывает на верхний левый угол отображаемого элемента,  а
        Size представляет  позицию  нижнего  правого  угла   относительно
        Origin.

             Origin -  это точка в координатной системе владельца отобра-
        жаемого элемента.  Если вы открываете окно в оперативной области,
        его поле  Origin указывает координаты x и y окна относительно на-
        чала оперативной области.  Поле Size, с другой стороны, это точка
        относительно начала собственного объекта.  Оно сообщает вам, нас-
        колько отстоит правый нижний угол от начальной точки,  но пока вы
        не знаете,  где находится начало  отображаемого  элемента  внутри
        другого отображаемого элемента, вы не сможете определить, где ре-
        ально находится этот угол.

             После построения отображаемого элемента существует ряд мето-
        дов управления границами этого отображаемого элемента. В частнос-
        ти, вы можете сделать следующее:

             - получить координаты отображаемого элемента;
             - переместить отображаемый элемент;
             - изменить размер отображаемого элемента.

                   Получение координат отображаемого элемента
        ─────────────────────────────────────────────────────────────────

             Как вы потоми поймете, существует много моментов, когда тре-
        буется получить границы  отображаемого элемента - когда требуется
        изменить эти границы,  либо вы хотите построить другой отображае-
        мый элемент на основе этих границ.  Объект TView содержит метод с
        именем GetExtent, воспринимающий единственный параметр-переменную
        типа TRect, который устанавливает границы отображаемого элемента.

             Например, следующий фрагмент программы показывает метод, ко-
        торый строит и включает окно,  покрывающее левую половину  опера-
        тивной области.

             procedure TYourApplication.AddLeftWindow;
             var
               R: TRect;
               LeftWindow: PWindow;

         B.Pascal 7 & Objects/TV#1   - 141 -

             begin
               Desktop^.GetExtent(R);       { получить координаты
                                              оперативной области }
               R.B.X := R.B.X div 2;        { переместить правую
                                              границу наполовину влево }
               LeftWindow := New(PWindow, Init(R,  { использовать R как
                                              размер окна }
                    'Левое окно', wmNoNumber)); { задать заголовок и
                                              номер окна }
               InsertWindow(LeftWindow);    { включить левое окно
                                              в оперативную область }
             end;

             У прямоугольника, заданного GetExtent,  его левое поле A ус-
        танавливается в точку (0,0), а B устанавливается в размер отобра-
        жаемого элемента. Другими словами, GetExtent возвращает координа-
        ты отображаемого элемента в своей локальной системе координат.

             Чтобы получить координаты отображаемого элемента относитель-
        но его отображаемого элемента-владельца,  используйте  вместо ме-
        тода GetExtent метод GetBound.  GetBound возвращает координаты  в
        координатной системе отображаемого элемента-владельца, устанавли-
        вая поле A его параметра в поле Origin отображаемого элемента,  а
        поле B - в размер смещения отображаемого элемента от начала.



         B.Pascal 7 & Objects/TV#1   - 142 -

                       Перемещение отображаемого элемента
        ─────────────────────────────────────────────────────────────────

             Чтобы изменить позицию отображаемого элемента, не затрагивая
        его размер,  вызовите метод MoveTo отображаемого элемента.  Метод
        MoveTo воспринимает два параметра - координаты x и y нового нача-
        ла отображаемого элемента. Например, следующий оператор перемеща-
        ет отображаемый  элемент  на  два  пробела влево и на один пробел
        вниз:

             MoveTo(Origin.X - 2, Origin.Y + 1);

                    Изменение размера отображаемого элемента
        ─────────────────────────────────────────────────────────────────

             Чтобы изменить  размер отображаемого элемента,  не перемещая
        его (то есть без изменения позиции его верхнего левого угла), вы-
        зовите метод GrowTo отображаемого элемента.  Метод GrowTo воспри-
        нимает два параметра,  определяющие координаты x и y нижнего пра-
        вого угла отображаемого элемента относительно начала.

             Например, следующий оператор приводит к тому, что отображае-
        мый элемент удваивает свою высоту и ширину:

             GrowTo(Size.X, Size.Y);

                  Одновременное перемещение и изменение размера
        ─────────────────────────────────────────────────────────────────

             Чтобы за  один шаг установить новый размер и позицию отобра-
        жаемого элемента,  вы можете вызвать метод  Locate  отображаемого
        элемента. Locate  воспринимает в качестве единственного параметра
        прямоугольник, устанавливая этот прямоугольник в качестве границы
        отображаемого элемента.

             Например, следующие  строки устанавливают границы отображае-
        мого элемента  в заданный прямоугольник,  независимо от  его  на-
        чального размера и позиции отображаемого элемента:

             R.Assign(1, 3, 27, 4);
             Locate(R);

              Размещение отображаемых элементов в своих владельцах
        ─────────────────────────────────────────────────────────────────

             Одна из наиболее общих операций с координатами отображаемого
        элемента состоит в размещении  одного  отображаемого  элемента  в
        другом. Например, создание внутренней области окна предусматрива-
        ет, что внутренняя область нигде не перекрывает рамки  окна.  Для
        этого нужно присвоить границы внутренней области относительно ок-
        на, не беспокоясь о фактическом размере и позиции окна.

             Grow -  это метод TRect,  который увеличивает (или уменьшает

         B.Pascal 7 & Objects/TV#1   - 143 -

        при отрицательных параметрах) горизонтальные и вертикальные  раз-
        меры прямоугольника. Используемый, в сочетании с GetExtent, метод
        Grow облегчает размещение одного отображаемого элемента в  другом
        (как   показано   в   следующем  примере).  Типы  TTthisWindow  и
        PIOnsideWindow введены просто для данного примера.

             procedure ThisWindow.MakeInside;
             var
               R: TRect;
               Inside: PInsideView;
             begin
               GetExtent(R);             { установить R в размер
                                           ThisWindow }
               R.Grow(-1, -1);           { сократить прямоугольник на 1 }
               Inside :=  New(PInsideView, Init(R)); { создать внутренний
                                           отображаемый элемент }
               Insert(Inside);           { вставить новый отображаемый
                                           элемент в окно }
             end;

                      Вывод отображаемого элемента на экран
        ─────────────────────────────────────────────────────────────────

             Внешний вид объекта типа отображаемого элемента определяется
        его методом Draw. Практически все новые типы отображаемых элемен-
        тов должны иметь свои методы Draw,  т.к.  этот метод определяет в
        целом внешний вид отображаемого элемента, который отличает его от
        других отображаемых элементов.

             Имеются два правила, которые применимы ко всем видам в соот-
        ветствии с их внешним видом. Отображаемый элемент должен:

             - охватывать  всю  область,  на которую распространяется его
               действие;

             - иметь способность к самоизображению в любой момент  време-
               ни.

             Оба этих свойства имеют большое значение и заслуживают того,
        чтобы их рассмотреть.  О фактической разработке методов  Draw  вы
        можете прочитать в разделе "Написание методов Draw".

                             Отображение по запросу
        ─────────────────────────────────────────────────────────────────

             Кроме того, отображаемый элемент должен быть всегда способен
        к самоизображению на экране.  Это связано с тем, что другие отоб-
        ражаемые элементы могут закрыть его часть,  а затем быть  убраны,
        или же сам отображаемый элемент может переместиться. В любом слу-
        чае при необходимости выполнить эту операцию отображаемый элемент
        должен всегда иметь о себе полное представление  для  адекватного
        самоизображения.


         B.Pascal 7 & Objects/TV#1   - 144 -

             Имейте в виду, что это может означать, что отображаемый эле-
        мент  не выполняет никаких функций:  он может быть полностью зак-
        рыт, или же может не появиться на экране,  или окно, в котором он
        находится,  сместилось  в  такую точку,  откуда этот отображаемый
        элемент не виден.  Большинство подобных  ситуаций  обрабатывается
        автоматически,  но  важно  помнить,  что ваш отображаемый элемент
        должен быть всегда способен к самоизображению.

             Такой подход существенно отличается от  многих  других  схем
        организации окон,  в которых постоянно выполняется запись в окна:
        Вы выполняете запись в окне, и она в нем остается даже в том слу-
        чае,  если будет закрыта другим отображаемым элементом и он затем
        будет убран.  В Turbo Vision вы не можете быть уверенными в  том,
        что  открываемый  вами  отображаемый элемент будет правильным - в
        нем могли произойти изменения в то время, когда он был закрыт.

               Изменение флагов параметров отображаемого элемента
        ─────────────────────────────────────────────────────────────────

             Все отображаемые элементы,  порожденные от TView,  наследуют
        четыре поля, содержащие битовую информацию. То есть, каждый бит в
        каждом поле  имеет  специальный смысл,  устанавливая определенные
        параметры отображаемого элемента.  Вы можете рассматривать каждый
        бит как булевское значение, но записанное в более компактной фор-
        ме.

             Значения этих  параметров  устанавливаются  сразу при первом
        построении отображаемого элемента и обычно остаются установленны-
        ми,  хотя  вы  в любое время можете изменить их значения.  Полное
        описание каждого флага вы можете найти в Главе 19 (см.  константы
        ofXXXX, dmXXXX и gfXXXX).

                   Примечание: О том,  как работать с битовыми параметра-
              ми, рассказывается в Главе 7 "Обзор Turbo Vision".

             Флаги Options - это битовое слово в каждом отображаемом эле-
        менте. Различные потомки TView имеют по умолчанию различные уста-
        новленные значения Options.  Хотя флаги GrowMode и DragMode  при-
        сутствуют в каждом отображаемом элементе,  они не действуют, пока
        отображаемые элементы не включаются в группу, поэтому о них расс-
        казывается в разделе данной главы, посвященном группам. Четвертое
        поле,  EventMask, описывается в Главе 9 "Программирование, управ-
        ляемое событиями".

                                Настройка выбора
        ─────────────────────────────────────────────────────────────────

             Слово Options имеет три бита, управляющих выбором отображае-
        мого элемента   пользователем:   ofSelectable,   ofTopSelect    и
        ofFirstClick.

             Для большинства отображаемых элементов по умолчанию устанав-
        ливается бит ofSelectable.  Это означает,  что пользователь может

         B.Pascal 7 & Objects/TV#1   - 145 -

        выбирать отображаемый элемент с помощью "мыши". Если отображаемый
        элемент содержится в группе, то пользователь также может выбирать
        его по клавише Tab. Иногда нежелательно, чтобы пользователь выби-
        рал чисто информационные отображаемые элементы, поэтому вы можете
        очистить их биты ofSelectable.  Например,  статические  текстовые
        объекты и рамки окон по умолчанию не выбираются.

             Бит ofTopSelect в случае его установки вызывает  перемещение
        отображаемого элемента  при его выборе к вершине отображаемых по-
        дэлементов владельца.  Этот параметр предназначен в основном  для
        окон в оперативной области,  поэтому не используйте его для отоб-
        ражаемых элементов в группе.

             Бит ofFirstClick управляет тем, будет ли щелчок кнопкой "мы-
        ши",  который выделяет отображаемый элемент,  также  передаваться
        отображаемому элементу для обработки. Например, если пользователь
        щелкнул "мышью" на командной кнопке,  вы хотите и выбрать кнопку,
        и "нажать" ее одним щелчком "мыши",  поэтому для командных кнопок
        бит ofFirstClick устанавливается по умолчанию.  Но если пользова-
        тель щелкает "мышью" в неактивном окне, желательно просто выбрать
        окно и не обрабатывать щелчок "мышью" как действие по активизации
        окна.  Это уменьшает вероятность того,  что пользователь случайно
        закроет или распахнет окно, когда просто пытается его активизиро-
        вать.

                    Изображение рамки отображаемого элемента
        ─────────────────────────────────────────────────────────────────

             Если вы установите бит ofFramed, то отображаемый элемент бу-
        дет заключен в видимую рамку. Это полезно использовать при созда-
        нии в  окне  нескольких  "областей",  или если вы хотите выделить
        конкретный отображаемый элемент. ofFramed не влияет на рамку объ-
        ектов окна и диалогового окна. Это отдельные отображаемые элемен-
        ты, управляемые полем оконного объекта. Бит ofFramed влияет толь-
        ко на включенные в окно или диалоговое окно отображаемые  элемен-
        ты.

                          Специальная обработка событий
        ─────────────────────────────────────────────────────────────────

             Биты ofPreProcess и ofPostOProcess  позволяют  отображаемому
        элементу обработать  события перемещения фокуса перед и после то-
        го, как отображаемый элемент,  на который переместился фокус,  их
        обнаруживает. Использование  данных бит поясняется в разделе "Фа-
        за" в Главе 9 "Программирование, управляемое событиями".

         B.Pascal 7 & Objects/TV#1   - 146 -


                      Центрирование отображаемого элемента
        ─────────────────────────────────────────────────────────────────

             Отображаемые элементы  имеют  два  бита,  которые  управляют
        центрированием отображаемого  элемента  внутри  своего владельца.
        Бит ofCenterX центрирует отображаемый  элемент  горизонтально,  а
        ofCenterY -  вертикально.  Если  вы хотите выполнить как горизон-
        тальное, так и вертикальное центрирование, то можете использовать
        маску ofCentered, содержащую оба бита центрирования.



         B.Pascal 7 & Objects/TV#1   - 147 -

                   Установка состояния отображаемого элемента
        ─────────────────────────────────────────────────────────────────

             Каждый отображаемый элемент поддерживает битовое  поле  типа
        Word с именем State, которое содержит информацию о каждом состоя-
        нии отображаемого элемента.  В отличие от флагов параметров и би-
        тов режима,  которые вы можете устанавливать при построении отоб-
        ражаемого элемента (например,  если окно имеет изменяемый размер,
        то он всегда изменяемый), флаги состояния часто изменяются в про-
        цессе функционирования  отображаемого  элемента при изменении его
        состояния. Информация о состоянии определяет, будет ли отображае-
        мый элемент видимым, имеет ли курсор тень, буксируется ли отобра-
        жаемый элемент и имеет ли фокус ввода.

               ┌────── Флаги TView.State ──────┐
               msb                           lsb
               ╔═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╗
               ╚═╧═╧═╧═╧╤╧═╧╤╧═╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╝
                        │   │   │ │ │ │ │ │ │ └─── sfVisible   = $0001
                        │   │   │ │ │ │ │ │ └───── sfCursorVis = $0002
                        │   │   │ │ │ │ │ └─────── sfCursorIns = $0004
                        │   │   │ │ │ │ └───────── sfShadow    = $0008
                        │   │   │ │ │ └─────────── sfActive    = $0010
                        │   │   │ │ └───────────── sfSelected  = $0020
                        │   │   │ └─────────────── sfFocused   = $0040
                        │   │   └───────────────── sfDragging  = $0080
                        │   └───────────────────── sfModal     = $0200
                        └───────────────────────── sfExposed   = $0800

             Назначение каждого  из флагов состояния приведены в Главе 19
        "Справочник по Turbo Vision" под рубрикой "Константы флагов  сос-
        тояния sfXXXX".  В данном разделе рассматривается механизм опери-
        рования полем State.

             Вместо того,  чтобы работать с флагами состояния  непосредс-
        твенно, вы можете использовать метод SetState, который предусмат-
        ривает два вида деятельности:

             - установку или очистку флагов состояния;

             - реакцию на изменения состояния.



         B.Pascal 7 & Objects/TV#1   - 148 -

                      Установка и очистка флагов состояния
        ─────────────────────────────────────────────────────────────────

             В основном  вам не потребуется изменять биты состояния вруч-
        ную, поскольку большинство изменений общих состояний  обрабатыва-
        ется другими методами.  Например,  бит stCursorVis управляет тем,
        будет ли отображаемый элемент  иметь  видимый  текстовый  курсор.
        Вместо непосредственного  управления этим битом вы можете вызвать
        методы ShowCursor  или  HideCursor,   которые   переключают   бит
        sfCursofVis. В следующей таблице показаны флаги состояния и мето-
        ды, которые ими управляют:

                       Методы, изменяющие флаги состояния     Таблица 8.1
        ┌───────────────────────────────────┬───────────────────────────┐
        │         Флаг состояния            │        Методы             │
        ├───────────────────────────────────┼───────────────────────────┤
        │  sfVisible                        │ Show, Hide                │
        │  sfCursorVis                      │ ShowCursor, HideCursor    │
        │  sfCursorIns                      │ BlockCursor, NormalCursor │
        │  sfShadow                         │ нет                       │
        │  sfActive, sfSelected, sfFocused, │ Select                    │
        │  sfDragging                       │ DragView                  │
        │  sfModal                          │ Execute                   │
        │  sfExposed                        │ TGroup.Insert             │
        └───────────────────────────────────┴───────────────────────────┘

             Чтобы изменить флаг состояния, который не имеет специального
        предназначенного для  этого  метода,  вам  нужно  вызвать   метод
        SetState отображаемого  элемента  и  передать  ему два параметра:
        бит, который требуется изменить,  и булевский флаг,  указывающий,
        нужно ли  устанавливать  бит.  Например,  чтобы  установить  флаг
        sfShadow, нужно сделать следующее:

             SetState(sfShadow, True);

                   Примечание: SetState работает каждый раз только с  од-
              ним битом.



         B.Pascal 7 & Objects/TV#1   - 149 -

                         Реакция на изменение состояния
        ─────────────────────────────────────────────────────────────────

             Всякий раз когда отображаемый элемент получает фокус, теряет
        фокус или становится выбранным,  Turbo Vision для изменения соот-
        ветствующих флагов состояния вызывает метод SetState.  Однако из-
        менение флагов состояния часто требует,  чтобы отображаемый  эле-
        мент, в ответ на новое состояния,  выполнил какие-то другие изме-
        нения,  например,  заново отобразился на экране.  Если вы хотите,
        чтобы  отображаемый элемент реагировал на изменение состояния ка-
        ким-то  особым  способом,  то  вам  нужно  переопределить   метод
        SetState,  вызывая наследуемый метод SetState для обеспечения из-
        менения, а затем реагируя на новое состояние.

             Например, командная  кнопка просматривает поле State и изме-
        няет цвет на синий,  когда она становится выделенной. Ниже приве-
        ден  типичный  пример  реализации  метода SetState для порождения
        TView TButton.

             procedure TButton.SetState(AState: Word; Enable: Boolean);
             begin
               TView.SetState(AState, Enable);
               if AState and (sfSelected + sfActive) <> 0 then DrawView;
               if AState and sfFocused <> 0 then MakeDefault(Enable);
             end;

             Обратите внимание,  что  вы должны всегда вызывать из нового
        метода SetState наследуемый метод SetState.  Метод TView.SetState
        выполняет фактическую установку или очистку флагов состояния. За-
        тем  вы можете определить любые специальные действия,  основанные
        на состоянии отображаемого элемента. TButton проверяет, находится
        ли  отображаемый элемент в активном окне,  чтобы определить,  где
        помещать свое изображение.  Он также определяет, имеет ли отобра-
        жаемый   элемент  фокус,  и  в  этом  случае  он  вызывает  метод
        MakeDefault, который устанавливает или сбрасывает фокус отобража-
        емого элемента, в зависимости от параметра Enable.

             Программист и Turbo Vision часто сотрудничают при  изменении
        состояния. Предположим, например, что в вашей прикладной програм-
        ме имеется текстовый редактор TEditor,  и вы хотите разрешить или
        запретить  изменить состояния курсора в ответ на изменение режима
        вставки/замены - нажатие пользователем клавиши Ins.  В  ответ  на
        Ins редактор вызывает локальный метод ToggleInsMode,  который,  в
        свою очередь вызывает метод SetState:

             procedure TEditor.ToggleInsMode;
             begin
               OvberWrite := not Overwrite;  { переключить режим замены }
               SetState(sfCursorIns, not GetState(sfCursorIns));
                                             { переключить курсор }
             end;


         B.Pascal 7 & Objects/TV#1   - 150 -

                        Буксировка отображаемого элемента
        ─────────────────────────────────────────────────────────────────

             Один из способов перемещения отображаемого элемента  состоит
        в том, чтобы позволить пользователю его позиционировать или изме-
        нять его размер с помощью "мыши".  Перемещение отображаемого эле-
        мента с помощью "мыши" называется буксировкой.  Каждый отображае-
        мый элемент содержит битовое поле DragMode,  которое обеспечивает
        используемые по умолчанию предельные значения буксировки  отобра-
        жаемого  элемента.  Чтобы  буксировать отображаемые элементы,  вы
        должны понимать выполнение двух задач:

             - установка предельных значений буксировки;
             - вызов метода DragView.

                    Установка предельных значений буксировки
        ─────────────────────────────────────────────────────────────────

             Биты в DragMode определяют,  могут  ли  части  отображаемого
        элемента перемещаться  вне своего владельца.  Когда вы буксируете
        некоторые отображаемые элементы, такие как окна в оперативной об-
        ласти, перемещение  отображаемого  элемента  вне границ владельца
        просто вызывает усечение подэлемента на  границе  его  владельца.
        Другими словами,  отображаемый  элемент  может туда перемещаться,
        даже если вы не будете его видеть.  Биты с именами, начинающимися
        с dmLimit,  ограничивают  перемещение  отображаемого элемента об-
        ластью внутри его владельца.

             Маска dmLimitAll содержит все биты  ограничений  буксировки.
        Установка dmLimitAll в отображаемом элементе означает,  что поль-
        зователь не сможет  буксировать  какую-либо  часть  отображаемого
        элемента вне  его  владельца.  Отдельными  битами  являются  биты
        dmLimitLoX, dmLimitLoY,  dmLimitHiX и dmLimitHiY, которые ограни-
        чивают буксировку соответственно  влево,  вверх,  вправо  и  вниз
        внутри границ владельца.  По умолчанию для отображаемых элементов
        установлен бит dmLimitLoY.  Это означает, что пользователь не мо-
        жет  буксировать отображаемый элемент за верхнюю границу его вла-
        дельца.

                              Вызов метода DragView
        ─────────────────────────────────────────────────────────────────

             Фактическая буксировка отображаемого элемента обрабатывается
        методом DragView.  Обычно отображаемые  элементы  вызывают  метод
        DragView в ответ на щелчок "мышью".  Например,  когда вы щелкаете
        кнопкой "мыши" в верхней части рамки окна,  окно  вызывает  метод
        DragMove  для  перемещения  окна.  Аналогично,  когда вы щелкаете
        кнопкой "мыши" в правом нижнем углу окна,  оно вызывает также ме-
        тод DragView, но на это раз для изменения размера окна.

             Метод DragView воспринимает  пять параметров.  Первый из них
        - это  запись события,  которая инициализирует буксировку (обычно
        это событие нажатия кнопки "мыши").  Второй - это режим буксиров-

         B.Pascal 7 & Objects/TV#1   - 151 -

        ки, являющийся  комбинацией  dmDragMove  или dmDragGrow с флагами
        ограничений в поле DragMode. Три оставшихся параметра задают пря-
        моугольник, в котором может перемещаться отображаемый элемент,  и
        минимальный/максимальный размер отображаемого элемента.

             Пример, приводимый ниже,  вы можете найти также в  программе
        DRAGS.PAS. Он показывает типичное использование метода DragView:

             procedure TDragBlock.HandleEvent(var Event: TEvent);
             var
               R: TRect;
               Min, Max: TPoint;
             begin
               inherited HandleEvent(Event);
               if Event.What and evMouseDown = evMouseDown then
               begin
                 if Event.Double then ChangeFlags
                 else
                 begin
                   Owner^.GetExtent(R);
                   R.Grow(-1, -1);
                   SizeLimits(Min, Max);
                   case Event.Buttons of
                     mbLeftButton;
                       begin
                         DragView(Event, dmDragMove or DragMode, R,
                            Min, Max);
                         ClearEvent(Event);
                       end;
                     mbRightButton;
                       begin
                         DragView(Event, dmDragGrow or DragMode, R,
                            Min, Max);
                         ClearEvent(Event);
                       end;
                     end;
                 end;
               end;
             end;

                               Управление курсором
        ─────────────────────────────────────────────────────────────────

             Любой отображаемый элемент имеет курсор,  хотя курсор  виден
        только тогда,  когда отображаемый элемент получает  фокус  ввода.
        Курсор обеспечивает для пользователя визуальное указание, где бу-
        дет происходить ввод с клавиатуры,  но  соответствие  фактической
        позиции курсора позиции ввода должен обеспечивать программист.

             Объект TView имеет поле Cursor типа TPoint, которое указыва-
        ет позицию  курсора  в  отображаемом элементе относительно начала
        отображаемого элемента. Отображаемые элементы имеют несколько ме-
        тодов, предназначенных  для обработки курсора,  которые позволяют

         B.Pascal 7 & Objects/TV#1   - 152 -

        вам делать следующее:

             - выводить или скрывать курсор;

             - изменять стиль курсора;

             - перемещать курсор.

                            Вывод и сокрытие курсора
        ─────────────────────────────────────────────────────────────────

             Отображаемые элементы  содержат  два  метода,  ShowCursor  и
        HideCursor, которые управляют, соответственно, выводом на экран и
        сокрытием курсора.  По умолчанию курсор будет скрытым, хотя неко-
        торые потомки TView (в частности, строки ввода и редакторы) пере-
        определяют это свойство и по умолчанию выводят курсор.

             Один из  битовых  разрядов  в  поле  State  каждого элемента
        (sfCursorVis) управляет наличием у отображаемого элемента видимо-
        го курсора.  ShowCursor  и  HideCursor устанавливает и сбрасывает
        бит sfCursor.  Когда отображаемый элемент получает  фокус  ввода,
        то, если  бит sfCursor установлен,  Turbo Vision выводит курсор в
        позиции, указанной Cursor.

                             Изменение стиля курсора
        ─────────────────────────────────────────────────────────────────

             Turbo Vision  поддерживает  два стиля текстового курсора - в
        виде подчеркивания  (_) и в виде закрашенного прямоугольника (█).
        Методы TView NormalCursor и  BlockCursor  устанавливают  один  из
        двух стилей курсора (подчеркивание и прямоугольный курсор,  соот-
        ветственно). Один стиль обычно указывает на режим вставки, а дру-
        гой - на режим замены.

             По умолчанию  курсор имеет нормальный стиль - подчеркивание.
        Бит sfCursor в слове State отображаемого элемента управляет  сти-
        лем используемого    отображаемым   элементом   курсора.   Методы
        BlockCursor и NormalCursor устанавливают и очищают бит sfCursor.

                               Перемещение курсора
        ─────────────────────────────────────────────────────────────────

             Чтобы изменить позицию  текстового  курсора  в  отображаемом
        элементе, вы можете вызвать метод SetCursor отображаемого элемен-
        та. Метод SetCursor воспринимает  два  параметра,  представляющих
        координаты x  и y новой позиции курсора относительно начала види-
        мого элемента.

             Избегайте прямой модификации поля Cursor.  Вместо этого  ис-
        пользуйте SetCursor,  которое  изменяет адрес курсора и обновляет
        вывод на экран.


         B.Pascal 7 & Objects/TV#1   - 153 -

                  Проверка допустимости отображаемого элемента
        ─────────────────────────────────────────────────────────────────

             Каждый виртуальный  элемент имеет виртуальный метод с именем
        Valid, который в качестве одного из параметров  воспринимает  ко-
        мандную константу  и  возвращает  значение типа Boolean.  В общем
        случае вызов метода Valid аналогичен вопросу:  "Если я пошлю  вам
        эту команду,  будет  ли  она  допустимой?"  Если Valid возвращает
        True, то это свидетельствует о допустимости команды.

             Метод Valid используется для трех различных  типов  проверки
        допустимости, хотя  вы  можете  переопределить  их для выполнения
        других типов операций. В данном разделе освещаются следующие спо-
        собы использования метода Valid:

             - проверка правильности построения;
             - проверка надежного закрытия;
             - проверка допустимости данных.

                        Проверка правильности построения
        ─────────────────────────────────────────────────────────────────

             Turbo Vision резервирует специальную команду cmValid,  кото-
        рая используется для обеспечения корректного самопостроения отоб-
        ражаемого элемента.  Метод ValidView объекта приложения  вызывает
        метод Valid отображаемого элемента, передавая в качестве парамет-
        ра cmValid.  Отображаемому элементу следует отвечать на такие вы-
        зовы обеспечением при построении успешного выполнения всех  необ-
        ходимых операций, таких как распределение памяти.

             Например, конструктор отображаемого  элемента  строки  ввода
        воспринимает в  качестве  одного из параметров максимальную длину
        строки и пытается выделить для строки с таким количеством  симво-
        лов память в динамически распределяемой области.  Сам конструктор
        не проверяет успешность выделения памяти,  а полагается в этом на
        метод Valid.

             Метод Valid  строки ввода проверяет,  передано ли в качестве
        параметра cmValid,  и возвращает значение True, только если выде-
        ление памяти для данного буфера данных было успешным.

                          Проверка возможности закрытия
        ─────────────────────────────────────────────────────────────────

             Одной из наиболее общих проверок с помощью метода Valid, от-
        личных от  начальной  проверки,  является проверка на возможность
        закрытия отображаемого элемента. Например, когда вы вызываете ме-
        тод Close оконного объекта, то для обеспечения корректного закры-
        тия окна он вызывает метод Valid,  передавая cmClose. По существу
        вызов Valid(cmClose) аналогичен заданию вопроса:  "Все ли будет в
        порядке, если сейчас будет дана  команда  закрытия?"  Если  метод
        Valid возвращает  значение False,  то отображаемый элемент закры-

         B.Pascal 7 & Objects/TV#1   - 154 -

        вать нельзя.

             Таким образом,  при  передаче  cmClose  методы  Valid должны
        обеспечить сохранение информации,  очистку буферов и т.д.  Напри-
        мер, отображаемый элемент файлового редактора должен обеспечивать
        перед возвратом методом Valid значения True сохранение  изменений
        на диске.

             При написании методов Valid у  вас есть при обнаружении  не-
        допустимости отображаемого элемента две возможности: возвратить в
        методе Valid значение False или выполнить некоторое действие, де-
        лающее отображаемый элемент допустимым,  и затем возвратить True.
        Например,  когда редактор файлов при закрытии не сохранил измене-
        ния на диске,  он выводит диалоговое окно с запросом пользователю
        на сохранение изменений. Пользователь имеет три возможности: сох-
        ранить изменения и выполнить закрытие,  отменить закрытие или  не
        закрывать отображаемый элемент. В первых двух случаях метод Valid
        возвращает значение True, а третьем - False.

                          Проверка допустимости данных
        ─────────────────────────────────────────────────────────────────

             Выполняя проверки с помощью объекта  проверки  допустимости,
        строки  ввода  отображаемых  элементов  могут  использовать метод
        Valid для определения допустимости значений, содержащихся в стро-
        ках текста. Подробно этот механизм поясняется в Главе 13 "Объекты
        проверки допустимости данных".  Здесь же важно отметить, что про-
        верка допустимости  данных может выполняться,  когда пользователь
        закрывает окно, но вы можете использовать в точности такой же ме-
        ханизм в любой другой момент.

             Например, объекты  строк ввода проверяют допустимость своего
        содержимого, когда  метод  Valid  вызывается  с  помощью  команды
        cmClose. Но  вы  можете  просто проверять вводимые данные по мере
        набора их пользователем,  вызывая после каждого  нажатия  клавиши
        метод Valid(cmClose). По существую это эквивалентно заданию стро-
        ке ввода вопроса:  "Будет ли содержимое допустимым, если я сейчас
        дам команду  закрытия?" Во многих объектах проверки допустимости,
        описанных в Главе 13, используется именно этот метод.

                             Написание методов Draw
        ─────────────────────────────────────────────────────────────────

             Внешний вид любого отображаемого элемента  определяется  его
        методом  Draw.  Когда  вы пишете методы Draw,  нужно иметь в виду
        принципы, описанные выше в разделе "Вывод отображаемого  элемента
        на экран". Turbo Vision и ее отображаемые элементы предусматрива-
        ют несколько инструментальных средств,  которые вы можете исполь-
        зовать для записи на экран информации отображаемого элемента.

             Написание метода Draw включает в себя следующие задачи:

             - выбор цветов;

         B.Pascal 7 & Objects/TV#1   - 155 -


             - запись непосредственно в отображаемый элемент;

             - запись через буферы.

                                  Выбор цветов
        ─────────────────────────────────────────────────────────────────

             Когда вы  в Turbo Vision записываете данные на экран,  то не
        задаете непосредственно цвет элемента,  а полагаетесь на записи в
        палитре цветов отображаемого элемента.  Подробно палитры цветов и
        выбор цвета описываются в Главе 14 "Палитры и выбор цветов",  а в
        данном разделе мы коснемся лишь некоторых основных моментов.

             Когда вы  задаете  цвет для функции,  выполняющей запись не-
        посредственно в отображаемый элемент, то передаете индекс его па-
        литры цветов.

             Поэтому, например,  если  отображаемый  элемент содержит два
        вида текста,  обычный и подсвеченный,  то его палитра,  вероятно,
        будет содержать две записи - одну для обычного и одну для подсве-
        ченного текста.  В методе Draw вы передаете в GetColor  соответс-
        твующий индекс, который зависит от нужного вам атрибута. В следу-
        ющем примере приведен простой метод,  записывающий в отображаемый
        элемент две строки различного цвета:

             procedure TColorView.Draw;
             begin
               WriteStr(0, 0, 'Normal',  1);  { запись 'Normal' обычным
                                                цветом }
               WriteStr(1, 0,  'Hilite', 2);  { запись 'Hilite'
                                                подсвеченным цветом }
             end;

                             Непосредственная запись
        ─────────────────────────────────────────────────────────────────

             Отображаемые элементы содержат два похожих метода,  предназ-
        наченных для записи в них символов и строк. В любом случае вы за-
        даете координаты начала текста в отображаемом элементе, выводяще-
        го текст и индекс палитры цвета текста.

                                 Запись символов

             Метод WriteChar воспринимает пять параметров: координаты x и
        y первого записываемого символа,  символ,  индекс палитры нужного
        цвета и  число последовательных записываемых символов.  Например,
        следующий код будет заполнять третью строку отображаемого элемен-
        та буквой W в цвете, заданном второй записью палитры:

             WriteChar(0, 2, 'W', 2, Size.X);

                                  Запись строк

         B.Pascal 7 & Objects/TV#1   - 156 -


             Метод WriteStr воспринимает четыре параметра: координаты x и
        y первого символа, строку для записи и индекс палитры для палитры
        цветов. Например,  следующий код записывает строку 'Turbo Vision'
        в левый верхний угол отображаемого  элемента  в  цвете,  заданном
        третьей записью палитры:

             WriteStr(0, Size.Y - 1, 'Turbo Vision', 3);

                               Запись через буферы
        ─────────────────────────────────────────────────────────────────

             Наиболее эффективный способ управления большими или сложными
        отображаемыми элементами состоит в записи текста в буфер, а затем
        вывод на экран сразу всего буфера. Использование буферов повышает
        скорость отображения и уменьшает мерцание, вызванное большим чис-
        лом отдельных операций записи на экран. Обычно буферы используют-
        ся для записи сразу целых строки или отображаемых элементов.

             Буфер для  отображения представляет собой массив строк,  где
        каждое слово представляет символ и его цветовой  атрибут,  анало-
        гично тому,   как  видеоэкран  представляет  каждый  символ.  Тип
        TDrawBuffer, определенный в модуле View,  предоставляет вам удоб-
        ный массив слов, которые можно использовать для записи буферов.

             Отображение с  помощью  буфера предусматривает следующие три
        шага:

             - установку цвета текста;

             - перемещение текста в буфер;

             - запись буфера на экран.

                             Установка цвета текста
        ─────────────────────────────────────────────────────────────────

             При записи  в буфер вам нужно передать для помещаемого в бу-
        фер текста атрибут цвета.  Чтобы получить атрибут цвета, вы вызы-
        ваете метод GetColor. GetColor возвращает при передаче ему номера
        записи  палитры атрибут цвета.  Например,  чтобы получить атрибут
        цвета для третьей записи в палитре отображаемого  элемента,  сде-
        лайте следующее:

             ColorAttribute := GetColor(3);

             GetColor и  отображение  цвета  более  подробно поясняется в
        Главе 14 "Палитры и выбор цвета".

                           Перемещение текста в буферы
        ─────────────────────────────────────────────────────────────────

             В модуле Driver существует четыре процедуры,  которые вы мо-

         B.Pascal 7 & Objects/TV#1   - 157 -

        жете использовать   для  перемещения  текста  в  буфер:  MoveBuf,
        MoveChar, MoveCStr и MoveStr. Все они работают аналогично, но пе-
        ремещают в буфер различные виды текста.

             В общем  случае желательно заполнить буфер пробелами,  затем
        поместить в нужные места текст.  Это обеспечивает, что вы не про-
        пустите ничего  в буфере.  Использование процедур для перемещения
        текста в буфер иллюстрируется следующим примером:

             procedure TCountView.Draw;
             var
               B: TDrawBuffer;
               C, Start: Word;
               Params: array[0..1] of Longint;
               First: String[10];
               Display: String[20];
             begin
               C := GetColor(2);     { использовать цвет, совпадающий с
                                       цветом рамки }
               MoveChar(D, '"', C, Size.X);  { заполнить буфер = }
               Params(0) := Current;
               Params(1) := Count;
               FormatStr(Display, ' ~%d~ of %d ',  Params);
                                     { сформатировать строку }
               { если Current больше чем Count, вывести Current с
                 подсветкой }
               else C := GetColor($0202);
               MoveCStr(B, Display, C);   { переместить строку в буфер }
               WriteLn(0, 0, Size.X, Lwngth(Display), B);
                                     { записать строку }
             end;

                             Запись буфера на экран
        ─────────────────────────────────────────────────────────────────

             Отображаемые элементы  содержат  два  метода,   WriteBuf   и
        WriteLine, которые копируют на экран буфер отображения. Оба мето-
        да воспринимают одни и те же пять параметров:  координаты x  и  y
        верхнего левого угла области для записи,  ширину области,  высоту
        области и буфер, содержащий текст для записи.

             Отличие WriteBuf от WriteLine состоит в том,  что  WriteLine
        подразумевает, что текст в буфере представляет собой одну строку,
        а WriteBuf при превышении  буфером длины области для записи запи-
        сывает буфер на нескольких строках. Если высота области для запи-
        си превышает 1, то WriteLine копирует на каждой строке начало од-
        ного и того же текста, а WriteBuf выполняет непрерывную запись из
        буфера.

             Например, если  буфер  с  именем  Buffer  содержит   символы
        'ABCDEFGHIJ', то оператор:

             WriteLine(0, 0, 5, 2, Buffer);

         B.Pascal 7 & Objects/TV#1   - 158 -


        дает текст:

             ABCDE
             ABCDE

             С другой стороны,  при использовании WriteBuf, эквивалентный
        оператор:

             WriteLine(0, 0, 5, 2, Buffer);

        дает вывод:

             ABCDE
             FGHIJ

                        Использование групповых объектов
        ─────────────────────────────────────────────────────────────────

             Вы уже  получили  некоторое  представление о наиболее важном
        непосредственном порождении  объекта  TView  - об объекте TGroup.
        Объект TGroup и его порождения имеют  общее  название  -  группы.
        Отображаемые элементы,  которые не порождаются от объекта TGroup,
        называются терминальными (конечными) отображаемыми элементами.

             В основе своей группа представляет собой пустое окно,  кото-
        рый содержит другие отображаемые элементы и управляет ими. В тех-
        ническом  плане  она  является отображаемым элементом,  и поэтому
        должна выполнять те же функции,  что и отображаемый элемент:  уп-
        равлять  прямоугольной зоной экрана,  визуально изображать себя в
        любой момент времени и обрабатывать события в своей области экра-
        на.  Различие  между  ними заключается в способах выполнения этих
        функций:  большинство из них выполняются группами в  отображаемых
        подэлементах.

             В данном  разделе охватываются следующие относящиеся к груп-
        повым отображаемым элементам темы:

             - группы, отображаемые подэлементы и владельцы;
             - включение отображаемых подэлементов;
             - принципы отображаемых подэлементов;
             - выбор отображаемых подэлементов и перемещение на них фоку-
               са;
             - группы и флаги параметров;
             - отображение групп;
             - выполнение модальных групп;
             - управление отображаемыми подэлементами.

         B.Pascal 7 & Objects/TV#1   - 159 -


             Хотя вы  должны  иметь  о них представление,  вам никогда не
        требуется изменять основы поведения групп,  такие  как включение,
        отображение и  выполнение.  В  основном  это поведение достаточно
        простое. Вы наверняка столкнетесь с изменением некоторых характе-
        ристик определенных   потомков   TGroup,   таких  как  TWindow  и
        TApplication, но вам не требуется изменять основные методы  груп-
        пы.

             Например, хотя  это может быть не очевидным,  но процесс до-
        бавление в приложение полосы меню и управляющего элемента к  диа-
        логовому окну в точности совпадают.  В каждом случае вы включаете
        в группу отображаемый подэлемент, выполняя один и тот же наследу-
        емый из TGroup код.



         B.Pascal 7 & Objects/TV#1   - 160 -

                          Группы, подгруппы и владельцы
        ─────────────────────────────────────────────────────────────────

             Группа - это то, что содержит другие отображаемые подэлемен-
        ты. Вы  можете рассматривать группу как составной (сложный) отоб-
        ражаемый элемент. Вместо того, чтобы брать всю ответственность на
        себя, он распределяет свои обязанности среди различных отображае-
        мых подэлементов. Отображаемый подэлемент - это отображаемый эле-
        мент, которым владеет другой отображаемый элемент,  а группа, ко-
        торой он принадлежит, называется элементом-владельцем.

             Превосходным примером является TApplication.  TApplication -
        это отображаемый элемент, управляющий областью экрана - фактичес-
        ки всем экраном. TApplication - это также группа, владеющая тремя
        отображаемыми подэлементами: полосой меню, оперативной областью и
        строкой состояния.  Приложение выделяет каждому отображаемому по-
        дэлементу области экрана. Каждому из этих отображаемых подэлемен-
        тов выделяется область экрана. Полоса меню получает верхнюю часть
        экрана, строка  состояния - нижнюю строку,  а оперативная область
        получает все строки между ними. Типичный экран TApplication пока-
        зан на Рис. 8.1:

              ┌────────────────────────────────────────────────────────┐
              │██Строка█меню███████████████████████████████████████████│
              ├────────────────────────────────────────────────────────┤
              │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
              │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
              │░░ Оперативная область ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
              │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
              │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
              │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
              ├────────────────────────────────────────────────────────┤
              │██Строка█состояния██████████████████████████████████████│
              └────────────────────────────────────────────────────────┘

             Рис. 8.1 Схема экрана TApplication.

             Заметим, что  само приложение не имеет экранного представле-
        ния - вы его не видите. Его внешнее представление полностью опре-
        деляется отображаемыми элементами, которыми владеет приложение.

                       Включение отображаемых подэлементов
        ─────────────────────────────────────────────────────────────────

             Чтобы присоединить  в владельцу отображаемый подэлемент,  вы
        включаете подэлемент в своего владельца с помощью метода  Insert.
        Любая группа  может содержать любое число отображаемых подэлемен-
        тов, и любой отображаемый элемент может быть отображаемым подэле-
        ментом. Владелец интерпретирует свои отображаемые подэлементы как
        связанный список отображаемых элементов,  используя для  указания
        на следующий отображаемый подэлемент поле Next каждого отображае-
        мого подэлемента.


         B.Pascal 7 & Objects/TV#1   - 161 -

             Как минимум,  отображаемые подэлементы группы охватывают всю
        область в границах группы. Управлять этим можно двумя способами:

             - разделяя группу;

             - обеспечивая фон.

             Первых подход  используется  в общем случае в тех ситуациях,
        когда отображаемые подэлементы не перекрываются, например, прило-
        жение или  окно  разделяются на отдельные области.  Фоновый метод
        используется в тех случаях, когда отображаемые подэлементы требу-
        ется перекрывать и перемещать (оперативная область), или в случа-
        ях, когда важные отображаемые подэлементы разделены  (управляющие
        элементы диалогового окна).

             Каждый из этих случаев поясняется в следующих разделах.

                          Разделение групповой области
        ─────────────────────────────────────────────────────────────────

             Некоторые группы, такие как объект приложения, просто разде-
        ляют прямоугольную область экрана на части и выполняют постоянное
        присваивание каждой части отображаемых элементов.

             Чтобы создать область экране,  представленную на  Рис.  8.1,
        конструктор TApplication.Init создает три объекта и включает их в
        приложение:

             InitDeskTop;
             InitStatusLine;
             InitMenuBar;
             if DeskTop <> nil then Insert(DeskTop);
             if StatusLine <> nil  then Insert(StatusLine);
             if MenuBar <> nil then Insert(MenuBar);

             Вновь созданные   отображаемые  элементы  становятся  частью
        группы только после включения в нее.  В данном конкретном  случае
        отображаемый элемент TApplication разделил свою область экрана на
        три отдельных участка и выделил их для каждого из своих отобража-
        емых элементов. Таким образом, визуальное представление отобража-
        емых элементов станет совсем простым т.к. их отображаемые подэле-
        менты совершенно не будут переопределяться.

                   Примечание: Объекты приложения и их отображаемые подэ-
              лементы поясняются в Главе 10 "Объекты приложения".

                                Обеспечение фона
        ─────────────────────────────────────────────────────────────────

             Однако это  не значит что отображаемые элементы не могут пе-
        реопределяться.  В действительности одним из  важных  преимуществ
        среды с оконной структурой является способность иметь множествен-
        ные перекрывающиеся окна в оперативной области. К счастью,  груп-

         B.Pascal 7 & Objects/TV#1   - 162 -

        пы, включая оперативную область, умеют обрабатывать перекрывающи-
        еся отображаемые подэлементы.

             Основная идея фона состоит в том, что что-то изображается по
        всей области  группы,  позволяя  другим отображаемым подэлементам
        покрывать только конкретную нужную им область. Очевидным примером
        здесь является оперативная область,  обеспечивающая за каждым ок-
        ном полутоновый фон. Если окно или группа окон покрывают всю опе-
        ративную область,  то фон будет скрытым, но перемещение или  зак-
        рытие окон открывают некоторые части оперативной области,  и  фон
        обеспечивает, что здесь что-то отображается.

                   Примечание: Оперативная  область и ее фон поясняются в
              Главе 10 "Объекты приложения".

             Менее очевидными примером являются объекты окна и диалогово-
        го окна,  которые  в качестве фона используют свои объекты рамок.
        Так как объект рамки покрывает все края окна или диалогового  ок-
        на, он  заполняет  также  все области,  не покрываемые каким-либо
        другим отображаемым подэлементом. Это особенно полезно при проек-
        тировании диалоговых окон,  где вы обычно хотите вставлять управ-
        ляющие элементы, не беспокоясь о пространстве между ними.

             Каждый раз,  когда вы имеете дело с фоном или другими перек-
        рывающимися отображаемыми элементами,  вы должны понимать, почему
        Turbo Vision решает,  что одни  отображаемые  элементы  находятся
        "перед" или  "за"  другими.  Позиционирование объектов от первого
        отображаемого элемента  до  последнего  определяется Z-последова-
        тельностью объектов,  о которой рассказывается в следующем разде-
        ле.

                       Принципы отображаемых подэлементов
        ─────────────────────────────────────────────────────────────────

             Взаимоотношения между владельцем и его отображаемыми подэле-
        ментами имеют два важных аспекта: фактические связи между отобра-
        жаемыми элементами и порядок отображаемых элементов.  Данный раз-
        дел посвящен двум важным вопросам:

             * Что такое дерево отображаемых элементов?

             * Что такое Z-последовательность?



         B.Pascal 7 & Objects/TV#1   - 163 -

                    Что такое дерево отображаемых элементов?
        ─────────────────────────────────────────────────────────────────

             Когда вы включаете отображаемые подэлементы в группу,  отоб-
        ражаемые элементы создают некоторое дерево элементов с владельцем
        в качестве "ствола"  и  отображаемыми  подэлементами  в  качестве
        "ветвей". Связи  принадлежности  всех  отображаемых  элементов  в
        сложном приложении могут быть достаточно сложными,  но вы  можете
        визуально представить  их  как  одно  дерево переходов и охватить
        сразу всю структуру.

             Например, объект приложения является владельцем трех отобра-
        жаемых подэлементов,  которые показаны на Рис. 8.1. Видимая часть
        оперативной области - это ее фоновый отображаемый подэлемент, по-
        этому он также является владельцем с ветвями подэлементов.  Соот-
        ветствующее дерево подэлементов выглядит примерно следующим обра-
        зом:

                                ┌─────────────┐
                                │ Application │
                                └──┬──┬───┬───┘
                          ┌────────┘  │   └───────┐
                      ┌───┴─────┐┌────┴────┐┌─────┴──────┐
                      │ MenuBar ││ DeskTop ││ StatusLine │
                      └─────────┘└────┬────┘└────────────┘
                                      │
                               ┌──────┴─────┐
                               │ BackGround │
                               └────────────┘

             Рис. 8.2 Базовое дерево отображаемых элементов Turbo Vision.

             В типичном  приложении  программе  пользователь  при нажатии
        кнопки "мыши" или клавиши на клавиатуре создает новые  отображае-
        мые элементы.  Эти отображаемые элементы обычно появляются в опе-
        ративной области и образуют новые  ветви  дерева.  Например,  при
        щелчке "мышью" на пункте меню открывается окно средства просмотра
        файла. Приложение строит окно и включает его  в  оперативную  об-
        ласть, что  делает  окно еще одним отображаемым подэлементом опе-
        ративной области и еще одной ветвью дерева  отображаемых  элемен-
        тов.

             Само окно также является владельцем отображаемых  подэлемен-
        тов: рамки,  прокрутки (внутреннего отображаемого элемента, кото-
        рый содержит прокручиваемый массив текста) и пары полос  прокрут-
        ки. Примерный вид приложения в этом случае показан на Рис. 8.3, а
        соответствующее дерево - на Рис. 8.4.


         B.Pascal 7 & Objects/TV#1   - 164 -


                   Примечание: На Рис.  8.7 описывается тот же вид объек-
              тов, но несколько по-другому.

              ┌────────────────────────────────────────────────────────┐
              │██Строка█меню███████████████████████████████████████████│
              ├────────────────────────────────────────────────────────┤
              │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
              │░░╔═[]═══ File Viewer Window ══1═[]═╗ ░░░░░░░░░░░░░░░░│
              │░░║                                    ░░░░░░░░░░░░░░░░│
              │░░║  File text                        ▒ ░░░░░░░░░░░░░░░░│
              │░░║                                    ░░░░░░░░░░░░░░░░│
              │░░║                                   ▒ ░░░░░░░░░░░░░░░░│
              │░░║                                    ░░░░░░░░░░░░░░░░│
              │░░╚══════════▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒══════┘ ░░░░░░░░░░░░░░░░│
              │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
              │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
              ├────────────────────────────────────────────────────────┤
              │██Строка█состояния██████████████████████████████████████│
              └────────────────────────────────────────────────────────┘

             Рис. 8.3 Оперативная область с добавленным в  нее  средством
        просмотра.

                                  ┌─────────────┐
                                  │ Application │
                                  └──┬──┬───┬───┘
                            ┌────────┘  │   └───────┐
                        ┌───┴─────┐┌────┴────┐┌─────┴──────┐
                        │ MenuBar ││ DeskTop ││ StatusLine │
                        └─────────┘└────┬────┘└────────────┘
                                   ┌────┴───┐
                                   │ Window │
                                   └┬─┬──┬─┬┘
                              ┌─────┘ │  │ └──────┐
                         ┌────┴──┐    │  │    ┌───┴──────┐
                         │ Frame │    │  │    │ Scroller │
                         └───────┘    │  │    └──────────┘
                                   ┌──┘  └──┐
                         ┌─────────┴──┐  ┌──┴─────────┐
                         │ Scroll Bar │  │ Scroll Bar │
                         └────────────┘  └────────────┘

             Рис. 8.4  Дерево  отображаемых  подэлементов  с  добавленным
        средством просмотра файла.


         B.Pascal 7 & Objects/TV#1   - 165 -


             Предположим далее,  что  пользователь выберет тот же элемент
        меню и создаст другое окно просмотра файлов. Turbo Vision создаст
        второе окно и присоединит его к рабочей области,  как показано на
        Рис. 8.5.

              ┌────────────────────────────────────────────────────────┐
              │██Строка█меню███████████████████████████████████████████│
              ├────────────────────────────────────────────────────────┤
              │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
              │░░╔═══════ File Viewer Window ══1═════╗░░░░░░░░░░░░░░░░░│
              │░░║                                   ░░░░░░░░░░░░░░░░░│
              │░░║         ╔═[]═══ File Viewer Window ══2═[]═╗░░░░░░░│
              │░░║  File te║                                   ░░░░░░░│
              │░░║         ║                                   ▒░░░░░░░│
              │░░║         ║  File text                        ▒░░░░░░░│
              │░░║         ║                                   ▒░░░░░░░│
              │░░║         ║                                   ░░░░░░░│
              │░░╚═════════║                                   ▒░░░░░░░│
              │░░░░░░░░░░░░║                                   ░░░░░░░│
              │░░░░░░░░░░░░╚══════════▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒══════┘░░░░░░░│
              │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
              │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
              ├────────────────────────────────────────────────────────┤
              │██Строка█состояния██████████████████████████████████████│
              └────────────────────────────────────────────────────────┘

             Рис. 8.5 Оперативная область с добавленным в  нее  средством
        просмотра.


         B.Pascal 7 & Objects/TV#1   - 166 -


                                ┌─────────────┐
                                │ Application │
                                └──┬──┬───┬───┘
                          ┌────────┘  │   └───────┐
                      ┌───┴─────┐┌────┴────┐┌─────┴──────┐
                      │ MenuBar ││ DeskTop ││ StatusLine │
                      └─────────┘└──┬───┬──┘└────────────┘
                        ┌───────────┘   └─────────────────┐
                   ┌────┴───┐                        ┌────┴───┐
                   │ Window │                        │ Window │
                   └┬─┬──┬─┬┘                        └┬─┬──┬─┬┘
              ┌─────┘ │  │ └─────┐              ┌─────┘ │  │ └───┐
         ┌────┴──┐    │  │   ┌───┴──────┐  ┌────┴──┐    │  │ ┌───┴──────┐
         │ Frame │    │  │   │ Scroller │  │ Frame │    │  │ │ Scroller │
         └───────┘    │  │   └──────────┘  └───────┘    │  │ └──────────┘
                   ┌──┘  └──┐                        ┌──┘  └──┐
         ┌─────────┴──┐  ┌──┴─────────┐    ┌─────────┴──┐  ┌──┴─────────┐
         │ Scroll Bar │  │ Scroll Bar │    │ Scroll Bar │  │ Scroll Bar │
         └────────────┘  └────────────┘    └────────────┘  └────────────┘

             Рис. 4.1. Дерево отображаемых элементов с добавленными к не-
        му двумя окнами просмотра отображаемых элементов.

             Как вы увидите далее, порядок включения определяет тот поря-
        док,  в котором изображаются отображаемые подэлементы, и порядок,
        в котором им передаются события.

             Если пользователь   щелкает  "мышью  на  второй  пиктограмме
        средства просмотра файла или на пункте меню Close Window, то вто-
        рое средство просмотра файлов закрывается.  При этом Turbo Vision
        удаляет его из дерева меню и уничтожает.  Окно  будет  уничтожать
        все свои отображаемые подэлементы, а затем уничтожаться само.

             В итоге пользователь  сводит  число  отображаемых  элементов
        снова до четырех и указывает программе путем нажатия клавиш Alt+X
        или выбором из меню команды Exit,  что она должна завершить рабо-
        ту.  TApplication уничтожает свои три отображаемых подэлемента, а
        затем отображает само себя.

                         Что такое Z-последовательность?
        ─────────────────────────────────────────────────────────────────

             Группы отслеживают порядок,  в котором включаются отображае-
        мые подэлементы.  Этот  порядок называется Z-последовательностью.
        Термин Z-последовательность (или Z-упорядочивание) связан с  тем,
        что отображаемые элементы имеют трехмерное пространственное соот-
        ношение. Как вы уже видели, каждый отображаемый элемент имеет по-
        ложение и размер в той плоскости,  в которой вы его видите (коор-
        динаты X и Y) определяемые его полями Origin и Size. Однако отоб-
        ражаемые  элементы могут перекрываться,  и для того,  чтобы Turbo
        Vision могла определить, какой отображаемый элемент находится пе-
        ред другими, мы должны добавить третью координату - Z.

         B.Pascal 7 & Objects/TV#1   - 167 -


             Таким образом, понятие Z-последовательности относится к пос-
        ледовательности,  в которой вы будете встречать отображаемые эле-
        менты, начиная от ближайшего по расположению к вам и по направле-
        нию от вас по оси Z "внутрь" экрана. Последним включенным отобра-
        жаемым элементом будет "передний" отображаемый элемент.

                   Примечание: Порядок Z-последовательность  обратен  по-
              рядку включения.

             Вместо представления экрана в  виде  плоскости  с  записями,
        рассматривайте его как стеклянную пластину, являющуюся "воротами"
        в трехмерный мир отображаемых  элементов.  Действительно,  каждая
        группа  может быть представлена в виде "сэндвича" из отображаемых
        элементов как показано на Рис. 8.7.

                           ┌──────────────────────┐
                           │                      │
                           │   ┌──────────────────┼───┐
                           │   │                  │   │ 
                           │   │                  │   ╞═▒═[]═╗
                           │   │                  │   │ ▒     ║
               TWindow ───Ў└───┼──────────────────┘   │ ▒     ║
                               │  Некоторый текст     │ ▒     ║
                 TScroller ───Ў└───╥──────────────────┘      ║
                                   ║                    ▒     ║
                  TScrollbar ───Ў  ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒       ║
                        TFrame ───Ў╚══════════════════════════┘

             Рис. 8.7 Окно просмотра текстов.

             Само окно является лишь "стеклянной пластиной",  покрывающей
        группу отображаемых элементов.  Т.к. все, что вы видите, является
        проекцией отображаемых элементов за стекло экрана,  вы не сможете
        определить, какие  отображаемые элементы находятся перед другими,
        если они не перекрываются.

             Окно по умолчанию имеет рамку, которая вставляется перед лю-
        быми другими отображаемыми элементами. Следовательно, она являет-
        ся "фоновым" отображаемым элементом.  При создании прокручиваемой
        внутренней области две полосы прокрутки накладываются  на  рамку.
        Если  смотреть спереди, они будут выглядеть частью рамки,  однако
        при виде сбоку вы можете увидеть что  они  на  самом  деле  парят
        "над" рамкой, закрывая часть рамки.

             Наконец, вставляется  прокручиваемый  отображаемый  элемент,
        охватывающий всю область внутри рамки.  Текст записывается в нем,
        а не в окне, но при просмотре окна вы сможете увидеть этот текст.

             В более  крупном масштабе вы сможете увидеть оперативную об-
        ласть как стеклянную пластину большего размера,  охватывающую бо-
        лее крупный сэндвич, большая часть содержимого которого представ-
        ляет собой сэндвичи помельче, как показано на Рис. 8.8.

         B.Pascal 7 & Objects/TV#1   - 168 -


                         ┌────────────────────────────────────┐
                         │                                    │
                         │   ┌────────────────────────────────┼───────┐
                         │   │                                │       │
                         │   │                                │       │
                         │   │         ┌───────┐              │       │
                         │   │  ┌──────┴┐      │              │       │
                         │   │  │▒▒▒▒▒▒▒│      │              │       │
            TDesktop ───Ў└───┼──┼───────┼──────┼──────────────┘       │
             TWindow ───Ў    │  │▒▒▒▒▒▒▒├──────┘                      │
             активная и      │  └───────┘▒                            │
             неактивная      │     ▒▒▒▒▒▒▒                            │
             TBackground ───Ў└────────────────────────────────────────┘

             Рис. 8.8 Оперативная область.

             Группа (в нашем примере оперативная область) также представ-
        ляет собой "стеклянную пластину".  Первым ее отображаемым элемен-
        тов является область TBackGround.  Таким образом, этот отображае-
        мый элемент будет расположен "за" всеми остальными.  Данный отоб-
        ражаемый элемент показывает также два окна в прокручиваемых внут-
        ренних отображаемых элементах в оперативной области (рабочем поле
        экрана).



         B.Pascal 7 & Objects/TV#1   - 169 -

                               Выбор отображаемых
                    подэлементов и перемещение на них фокуса
        ─────────────────────────────────────────────────────────────────

             В каждой группе отображаемых элементов только один отобража-
        емый элемент является выбранным.  Например, когда ваша прикладная
        программа устанавливает свою строку меню, рабочую область и стро-
        ку состояния,  то рабочая область  будет  выбранным  отображаемым
        элементом, так как в ней будет выполняться дальнейшая работа.

             Когда в вашей оперативной области открыто несколько окон, то
        выбранным окном будет то, в котором вы в данный момент работаете.
        Это окно называется также активным окном  (обычно  самое  верхнее
        окно).

             Выбранный отображаемый  элемент  в  активном окне называется
        выделенным отображаемым элементом  (или  отображаемым  элементом,
        имеющим  фокус).  Выделенным элементом можно считать отображаемый
        элемент,  который находится перед вами, или отображаемый элемент,
        в котором будут выполняться операции. В окне редактора выделенным
        отображаемым элементом будет внутренний  отображаемый  элемент  с
        находящимся в нем текстом. В окне диалога выделенный отображаемый
        элемент - это выделенный элемент управления (тот управляющий эле-
        мент, который получает фокус).

                   Примечание: Выделенный отображаемый элемент  завершает
              цепочку  выбранных  отображаемых элементов,  начало которой
              находится в прикладной программе.

             В программе,  диаграмма  которой  приведена  на  Рис.   8.6,
        Application - это режимный отображаемый элемент,  а DeskTop - это
        его выбранный отображаемый элемент.  В рабочей области  выбранным
        является второе окно (вставленное позднее),  поэтому оно является
        активным.  В этом окне прокручиваемая внутренняя  часть  является
        выбранной,  и т.к. этот отображаемый элемент - терминальный (т.е.
        это не группа),  он является заключительным звеном цепочки, выде-
        ленным  отображаемым элементом.  На Рис.  8.9 представлено это же
        дерево отображаемых элементом с цепочкой выделенных  отображаемых
        элементов, указанных двойными рамками.


         B.Pascal 7 & Objects/TV#1   - 170 -


                                ┌─────────────┐
                                │ Application │
                                └──┬──┬───┬───┘
                          ┌────────┘  │   └───────┐
                      ┌───┴─────┐╔════╧════╗┌─────┴──────┐
                      │ MenuBar │║ DeskTop ║│ StatusLine │
                      └─────────┘╚══╤═══╤══╝└────────────┘
                        ┌───────────┘   └────────────────┐
                   ┌────┴───┐                       ╔════╧═══╗
                   │ Window │                       ║ Window ║
                   └┬─┬──┬─┬┘                       ╚╤═╤══╤═╤╝
              ┌─────┘ │  │ └─────┐             ┌─────┘ │  │ └───┐
         ┌────┴──┐    │  │   ┌───┴──────┐ ┌────┴──┐    │  │ ╔═══╧══════╗
         │ Frame │    │  │   │ Scroller │ │ Frame │    │  │ ║ Scroller ║
         └───────┘    │  │   └──────────┘ └───────┘    │  │ ╚══════════╝
                   ┌──┘  └──┐                       ┌──┘  └──┐
         ┌─────────┴──┐  ┌──┴─────────┐   ┌─────────┴──┐  ┌──┴─────────┐
         │ Scroll Bar │  │ Scroll Bar │   │ Scroll Bar │  │ Scroll Bar │
         └────────────┘  └────────────┘   └────────────┘  └────────────┘

             Рис. 8.9 Цепочка выделенных отображаемых элементов.

             Кроме всего прочего, данные о выделение отображаемых элемен-
        тов позволят вам узнать, какой из отображаемых элементов получает
        информацию с клавиатуры. Более подробно об этом см. в разделе вы-
        деленных событий в Главе 9,  "Программирование, управляемое собы-
        тиями".

                    Поиск выделенного отображаемого элемента
        ─────────────────────────────────────────────────────────────────

             Отображаемый элемент, который является в данный момент выде-
        ленным,  обычно выделяется каким-либо образом и на экране. Напри-
        мер,  если в вашей оперативной области открыто несколько окон, то
        активным является с двойной рамкой;  рамки других окон -  одинар-
        ные.  В  окне диалога изображение выделенного элемента управления
        (элементы управления - это тоже отображаемые элементы!) более яр-
        кое, чем других элементов управления, что означает, что этот эле-
        мент будет действовать после нажатия  клавиши  Enter.  Выделенный
        элемент  управления  (на который перемещается фокус) одновременно
        является и элементом, заданным по умолчанию.

                   Примечание: В  монохромных дисплеях для выделения эле-
              ментов Turbo Vision добавляет символы стрелок.

                Как происходит выделение отображаемого элемента?
        ─────────────────────────────────────────────────────────────────

             Отображаемый элемент  может  быть  выделен двумя способами -
        либо по умолчанию, либо с помощью действия пользователя.

             После создания группы отображаемых элементов  элемент-владе-

         B.Pascal 7 & Objects/TV#1   - 171 -

        лец определяет, какой из его отображаемых элементов будет выделен
        (получит фокус),  с помощью вызова метода Select этого отображае-
        мого элемента. Этот метод устанавливает выделение по умолчанию.

             Пользователю может потребоваться изменить выделенный отобра-
        жаемый элемент.  Обычным способом сделать это служит щелчок кноп-
        кой "мыши" на другом отображаемом элементе.  Например, если в ва-
        шей рабочей памяти открыто несколько окон, вы можете выбрать раз-
        ные окна "нажатием" на них с помощью кнопки "мыши".  В  окне диа-
        лога вы можете перемещать выделение между отображаемыми элемента-
        ми  с помощью нажатия клавиши Tab,  посредством которой можно вы-
        полнить циклическое перемещение по  всем  имеющимся  отображаемым
        элементам, или нажать на отдельный отображаемый элемент с помощью
        кнопки "мыши", или нажать оперативную клавишу.

             Имейте в виду,  что некоторые отображаемые элементы не могут
        быть выбранными,  в том числе фон оперативной области, рамки окон
        и  полосы прокрутки.  Когда вы создаете отображаемый элемент,  то
        можете указать,  является ли он выбираемым, а после этого отобра-
        жаемый  элемент  сам определит,  может ли он выбираться.  Если вы
        щелкните, например,  на рамке окна с помощью  кнопки  "мыши",  то
        рамка не будет выделена,  т.к. она не может быть выделенным отоб-
        ражаемым элементом.



         B.Pascal 7 & Objects/TV#1   - 172 -

                           Изменение режима увеличения
        ─────────────────────────────────────────────────────────────────

             Поле GrowMode отображаемого элемента определяет,  как  изме-
        нится  отображаемый  элемент,  когда  будут  изменены размеры его
        группы-владельца. Отдельные биты в GrowMode позволяют вам "привя-
        зать" сторону отображаемого элемента к его владельцу, так что при
        изменении размера владельца на основе этого размера также изменя-
        ется и/или перемещается отображаемый подэлемент.

             Разряды GrowMode определяются следующим образом:

                       ┌─── GrowMode ──┐
                       msb           lsb
                                ┌─┬─┬─┬─── gfGrowAll
                       ╔═╤═╤═╤═╤╧╤╧╤╧╤╧╗
                       ╚╤╧═╧╤╧╤╧╤╧╤╧╤╧╤╝
                        └─┬─┘ │ │ │ │ └─── gfGrowLoX
                          │   │ │ │ └───── gfGrowLoY
                 Не определены│ │ └─────── gfGrowHiX
                              │ └───────── gfGrowHiY
                              └─────────── gfGrowRel

             Если установлен бит gfGrowLoX, то будет сохраняться постоян-
        ное  расстояние между левой границей отображаемого элемента и ле-
        вой границей его владельца. Биты gfGrowLoY, gfGrowHiX и gfGrowHiY
        привязывают верхнюю,  правую сторону и низ отображаемого элемента
        к соответствующим частям владельца.  Маска gfGrowAll  привязывает
        все четыре стороны владельца. Маска gfGrowAll привязывает все че-
        тыре стороны, изменяя размер отображаемого элемента при перемеще-
        нии нижнего правого угла владельца. Внутренние области окон часто
        используют GrowAll для обеспечения правильного размера внутри ра-
        мок.

             Флаг gfGrowRel  является  специальным  и предназначен только
        для использования  в  окнах  в  оперативной  области.   Установка
        gfGrawRel приводит к тому,  что окна сохраняют свои относительные
        размеры, когда пользователь переключается между различными видео-
        режимами приложения.

             Пример программы  DRAGS.PAS  на  ваших дистрибутивных дисках
        показывает, как различные флаги GrowMode влияют на объект в окне.

                                Изображение групп
        ─────────────────────────────────────────────────────────────────

             Группы являются  исключением  из правила,  согласно которому
        отображаемые элементы должны быть способны изображать себя,  т.к.
        группа  как таковая не изображает себя.  Напротив,  объект TGroup
        требует чтобы его отображаемые элементы могли сами изображать се-
        бя. Кумулятивный  эффект  изображения подэлементов должен охваты-
        вать всю назначенную группе область.


         B.Pascal 7 & Objects/TV#1   - 173 -

             Диалоговое окно,  например, представляет собой группу, а все
        его отображаемые подэлементы - рамка,  внутренняя область, управ-
        ляющие элементы и статический текст - должны комбинироваться  та-
        ким образом,  чтобы  "покрыть" всю область отображаемого элемента
        диалогового окна.  В противном случае в диалоговом окне возникают
        "дыры", которые могут дать непредсказуемые эффекты.

             Способ отображения  группой самой себя вам редко потребуется
        изменять, но вы должны  понимать  следующие  аспекты  отображения
        группы:

             - отображение в Z-последовательности;
             - использование кеш-буферов;
             - блокировка и разблокировка отображения;
             - отсечение отображаемых подэлементов.

                       Отображение в Z-последовательности
        ─────────────────────────────────────────────────────────────────

             Отображаемые элементы в группе призваны  изображать  себя  в
        Z-последовательности что означает, что первый вставленный в груп-
        пу отображаемый элемент изображается также первым. В таком случае
        при перекрытии отображаемых элементов последний вставленный отоб-
        ражаемый элемент будет находиться впереди других.



         B.Pascal 7 & Objects/TV#1   - 174 -

                            Использование кеш-буферов
        ─────────────────────────────────────────────────────────────────

             Все отображаемые  элементы  имеют  в своем слове Options бит
        ofBuffered, но используют его только группы. Когда этот бит уста-
        новлен, группы  могут увеличивать скорость своего вывода на экран
        путем записи  в  кеш-буфер.  По  умолчанию  для  всех  групп  бит
        ofBuffered установлен,  и используется буферизированное отображе-
        ние.

             Подсистема управления  памятью  Turbo  Vision  выделяет  для
        групп кеш-буферы  в  нераспределенной  части динамической области
        памяти, поэтому,  если ваше приложение также использует нераспре-
        деленную память, это может привести к конфликту с буферами групп.
        Самой  надежной практикой является использование только той памя-
        ти, которая распределена в динамически распределяемой области.

             При отображении  буферизированной группы и наличии достаточ-
        ного объема доступной памяти она  автоматически  сохраняет  образ
        экрана в буфере.  При следующем запросе на отображение группы она
        вместо запроса на отображение ко всем своим подэлементам копирует
        этот сохраненный образ на экран. Очевидно, копирование существую-
        щего образа выполняется значительно быстрее, чем его регенерация.

             Администратор памяти  Turbo  Vision  уничтожают  эти  буфера
        групп, когда  память  требуется в других операциях распределения.
        То есть,  если другая операция распределения памяти будет в  про-
        тивном случае  завершаться неудачно,  Turbo Vision будет пытаться
        освободить достаточный объем памяти путем отмены кеш-буферов. При
        уничтожении буфера потери информации не происходит,  просто груп-
        пам придется в следующий раз отображаться путем запросов на отоб-
        ражение ко всем своим подэлементам.

             Вы можете также,  вызвав метод группы Redraw,  принудительно
        полностью отобразить ее.

                     Блокировка и разблокировка отображений
        ─────────────────────────────────────────────────────────────────

             Сложные групповые отображаемые элементы иногда при отображе-
        нии могут вызывать мерцание,  особенно когда несколько отображае-
        мых элементов перекрываются.  Чтобы избежать мерцания,  вы можете
        заблокировать группы на время отображения подэлементов,  а затем,
        когда будет  содержать полный экранный образ группы,  разблокиро-
        вать отображаемый элемент. В этот момент группа копирует буфер на
        экран.

             Вызов метода  Lock  группы  прекращает  все  операции записи
        группы на экран,  пока  не  будет  вызван  соответствующий  метод
        Unlock. Когда вызывается метод Unlock,  буфер группы записывается
        на экран.  Блокировка может существенно  уменьшить  мерцание  при
        сложных обновлениях экрана. Например, при выводе своих отображае-
        мых подэлементов с перекрытием или без перекрытия оперативная об-

         B.Pascal 7 & Objects/TV#1   - 175 -

        ласть блокируется.

                       Отсечение отображаемых подэлементов
        ─────────────────────────────────────────────────────────────────

             Процесс самоизображения отображаемых элементов группы  авто-
        матически прекращается на границах группы. Т.к. отображаемые эле-
        менты отсекаются,  то когда вы инициализируете отображаемый  эле-
        мент и включаете его в группу, он должен хотя бы частично уклады-
        ваться в границы группы.  (Вы можете,  например, захватить окно и
        удалять его из рабочей области,  пока только один его угол не ос-
        танется в поле видимости,  однако, чтобы отображаемый элемент был
        полезен,  какая-то его часть должна оставаться отображаемой.) Ос-
        таваться видимой будет лишь часть отображаемого элемента, находя-
        щегося в границах группы которой он принадлежит.

             Вы можете  использовать преимущества этого отсечения при на-
        писании сложных методов Draw.  Обычно при заполнении буфера отоб-
        ражения для  записи  на  экран вы заполняете его числом символов,
        достаточным для отображения всего элемента.  Однако, если отобра-
        жаемый элемент  отсекается,  вам  может  потребоваться изобразить
        только несколько символов или пропустить целые строки.

             Чтобы определить  требующую  отображения  область  (то  есть
        часть отображаемого  элемента,  которая  не осекается),  вызовите
        вместо GetExtent   метод   GetClipRect.   Аналогично   GetExtent,
        метод GetClipRect возвращает прямоугольную  область  в  локальных
        координатах, но она включает в себя только ту часть отображаемого
        элемента, которая не отсекается границами его владельца.

                            Выполнение режимных групп
        ─────────────────────────────────────────────────────────────────

             Большинство сложных программ имеют несколько различных режи-
        мов операций,  где режим представляет собой некий отличный способ
        их функционирования.  Интегрированная среда разработки, например,
        имеет  режим редактирования и отладки,  режим компилятора и режим
        выполнения.  В зависимости от того,  какой режим активен, клавиши
        на  клавиатуре могут иметь различное действие (или не действовать
        вовсе).

             Почти все отображаемые элементы Turbo Vision  могут  опреде-
        лять режим работы. В этом случае они называются режимными отобра-
        жаемыми элементами.  Режимные отображаемые элементы почти  всегда
        представляют собой группы.  Классическим примером режимного отоб-
        ражаемого элемента является диалоговое окно. Обычно, когда диало-
        говое окно активно, вне его ничего не функционирует. Вы не можете
        использовать меню или другие управляющие элементы, не принадлежа-
        щие диалоговому окну.  Кроме того, щелчки "мышью" вне диалогового
        окна не действуют,  диалоговое окно управляет  вашей  программой,
        пока пользователь его не закроет.

             Чтобы использовать режимные отображаемые элементы, вы должны

         B.Pascal 7 & Objects/TV#1   - 176 -

        понимать четыре момента:

             - что такое режимность;
             - выполнение отображаемого элемента;
             - поиск режимного отображаемого элемента;
             - завершение режимного состояния.

             При выполнении приложения Turbo Vision всегда имеется режим-
        ный отображаемый  элемент.  При  запуске программы и часто на все
        время работы программы режимным отображаемым  элементом  является
        само приложение - объект TApplication в вершине дерева отображае-
        мых элементов.

                              Что такое режимность?
        ─────────────────────────────────────────────────────────────────

             Когда вы делаете отображаемый элемент режимным,  взаимодейс-
        твовать с пользователем может только этот отображаемый элемент  и
        его подэлементы.  Вы  можете  рассматривать режимный отображаемый
        элемент, как определяющий "область действия" части вашей програм-
        мы. Когда вы создаете блок в программе Паскаля (такой как функция
        или процедура),  любые определенные в данном блоке идентификаторы
        действуют только  в  границах этого блока.  Аналогично,  режимным
        отображаемый элемент определяет, какое поведение внутри его явля-
        ется допустимым  - события обрабатываются только режимным отобра-
        жаемым элементом и его подэлементами.  Любая часть дерева отобра-
        жаемых элементов,  не  являющаяся режимным отображаемым элементом
        или не принадлежащая режимному отображаемому  элементу,  является
        неактивной.

             В этом  правиле есть одно исключение:  строка состояния дос-
        тупна в любое время. Таким образом, вы можете иметь активные эле-
        менты строки  состояния,  даже когда ваша программа выполняется в
        режимном диалоговом окне, не являющемся владельцем строки состоя-
        ния. Однако,  события и команды,  генерируемые строкой состояния,
        будут обрабатываться таким образом как если бы они генерировались
        в режимном отображаемом элементе.

                   Примечание: Строка  состояния  всегда будет "оператив-
              ной",  независимо от того, какой отображаемый элемент явля-
              ется режимным.

                       Переход группы в режимное состояние
        ─────────────────────────────────────────────────────────────────

             Наиболее общий вид режимного отображаемого элемента  (отлич-
        ный от самого приложения,  которое является в Turbo Vision режим-
        ным элементом по умолчанию) - это диалоговые окна, поэтому объект
        приложения Turbo  Vision  обеспечивает  простой способ выполнения
        режимных диалоговых  окон   в   оперативной   области   -   метод

         B.Pascal 7 & Objects/TV#1   - 177 -

        ExecuteDialog. ExecuteDialog детально поясняется в Главе 11 "Объ-
        екты окон и диалоговых окон".

             В более общем случае вы можете сделать группу,  выполнив ее,
        текущим режимным отображаемым элементом (для этого вызывается ме-
        тод Execute).  TGroup.Execute реализует цикл событий, взаимодейс-
        твуя с пользователем и выполняя диспетчеризацию событий для соот-
        ветствующих отображаемых подэлементов.  В большинстве случаев вам
        потребуется не вызывать Execute непосредственно,  а  использовать
        метод ExecView.

                   Примечание: О циклах событий рассказывается в Главе  9
              "Программирование, управляемое событиями".

             ExecView - это метод группы, который работает во многом ана-
        логично Insert и Delete,  используемых Execute. Он включает отоб-
        ражаемый элемент  в группу,  выполняет новый отображаемый подэле-
        мент, а затем удаляет подэлемент,  когда  пользователь  завершает
        режимное состояние  (например,  закрывает режимное диалоговое ок-
        но).

                     Поиск режимного отображаемого элемента
        ─────────────────────────────────────────────────────────────────

             Каждый отображаемый  элемент  имеет  метод TopView,  который
        возвращает указатель на текущий  режимный  отображаемый  элемент.
        Есть пара моментов, включая завершение текущего режимного состоя-
        ния  (как описывается в следующем разделе) и оповещение о событии
        всех текущих  доступных отображаемых элементов (это описывается в
        Главе 9 "Программирование, управляемое событиями"), когда вам мо-
        жет потребоваться эта информация.

                         Завершение режимного состояния
        ─────────────────────────────────────────────────────────────────

             Любой отображаемый элемент может завершить текущее состояние
        путем вызова метода EndModal.  EndMoodal в качестве одного из ар-
        гументов воспринимает  командную константу и передает ее текущему
        режимному отображаемому элементу. Это завершает его режимное сос-
        тояние,  возвращая в качестве результата метода Execute,  который
        сделал этот отображаемый элемент режимным, значение команды. Пре-
        дыдущий режимный элемент становится текущим режимным отображаемым
        элементом. Если других отображаемых элементов нет (как, например,
        при завершении режимного состояния объекта приложения),  приложе-
        ние завершает работу.  В следующем примере показана часть  метода
        HandleEvent  в  TDialog.  Режимные диалоговые окна завершают свое
        режимное состояние,  когда обнаруживают команды  cmOK,  cmCancel,
        cmYes  или  cmNo.  Эта команда затем возвращается методом Execute
        или ExecuteDialog, который сделал диалоговое окно режимным.

             procedure TDialog.HandleEvent(var Event: TEvent);
             begin
               inherited HandleEvent(Event);

         B.Pascal 7 & Objects/TV#1   - 178 -

               case Event.What of
                    .
                    .
                    .
                  evCommand:
                     case Event.Command of
                       cmOK, cmCancel, cmTes, cmNo:
                          { для каждой из этих команд ... }
                        if State and sfModal <> 0 then
                          { если диалоговое окно режимное }
                        begin
                          EndModal(Event.Command);
                            { завершить режимное состояние командой }
                          ClearEvent(Event);
                            { и отметить событие как обработанное }
                        end;
                     end;
               end;
             end;

             Как проверить значение,  возвращаемое из вашего  диалогового
        окна, показывает  пример  программы ENDCMD.PAS на ваших дистрибу-
        тивных дисках.

                     Управление отображаемыми подэлементами
        ─────────────────────────────────────────────────────────────────

             После включения  отображаемого  подэлемента  в группу группа
        выполняет для вас почти все управление подэлементами, обеспечивая
        их отображение,  перемещение  и  так далее.  Когда вы уничтожаете
        групповой объект, он автоматически уничтожает все свои отображае-
        мые подэлементы, поэтому вам не требуется уничтожать их индивиду-
        ально. Так,  например,  хотя конструктор диалогового  окна  часто
        длинный и сложный,  (в нем выполняется построение и инициализация
        многочисленных управляющих элементов в качестве отображаемых  по-
        дэлементов), деструктор  часто даже не переопределяется - исполь-
        зуемый по умолчанию объект диалогового окна использует деструктор
        Done, который  он наследует из TGroup и который перед собственным
        уничтожением уничтожает каждый отображаемый подэлемент.

             Кроме автоматического управления отображаемыми подэлементами
        с подэлементами  группы  вам  часто требуется выполнять следующие
        задачи:

             - удаление отображаемых подэлементов;
             - итерация отображаемых подэлементов;
             - поиск конкретного отображаемого подэлемента.

                       Удаление отображаемых подэлементов
        ─────────────────────────────────────────────────────────────────

             Хотя группа  перед  собственным  уничтожением  автоматически

         B.Pascal 7 & Objects/TV#1   - 179 -

        уничтожает все свои отображаемые подэлементы,  иногда  желательно
        удалить подэлемент во время использования группы.  Очевидным при-
        мером является закрытие окна в оперативной  области:  уничтожение
        оперативной области приводит к уничтожению всех окон,  включенных
        в оперативную область, но вам часто требуется удалить окно в ходе
        выполнения приложения.

             Чтобы удалить  отображаемый  подэлемент из своего владельца,
        используйте метод Delete владельца.  Delete - это метод, обратный
        методу Insert:  он удаляет отображаемый подэлемент из списка всех
        отображаемых подэлементов владельца,  но не уничтожает  удаленный
        отображаемый элемент.

                       Итерация отображаемых подэлементов
        ─────────────────────────────────────────────────────────────────

             Как вы уже видели несколько раз в данной главе,  группы  вы-
        полняют множество своих обязанностей,  таких как отображение, вы-
        зывая все свои отображаемые подэлементы  в  Z-последовательности.
        Процесс вызова по порядку каждого отображаемого подэлемента назы-
        вается итерацией. Кроме стандартных итераций, TGroup обеспечивает
        методы итерации, позволяющие вам определить собственные действия,
        которые можно выполнить над каждым отображаемым подэлементом.

                   Поиск конкретного отображаемого подэлемента
        ─────────────────────────────────────────────────────────────────

             Иногда вам  нужно найти конкретный отображаемый подэлемент в
        группе, например, найти окно редактора среди окон оперативной об-
        ласти или выбрать в диалоговом окне командную кнопку OK,  объекты
        Group предусматривают полезный метод для  поиска  подэлементов  и
        проверки каждого из них, пока не будет удовлетворено определенное
        условие.

             Метод TGroup FindFirst  воспринимает  в  качестве  параметра
        указатель на  булевскую функцию и применяет эту функцию к каждому
        из отображаемых подэлементов группы в Z-последовательности,  пока
        функция не возвратит значение True (в этом случае FirstThat возв-
        ращает указатель на соответствующий отображаемый подэлемент).



         B.Pascal 7 & Objects/TV#1   - 180 -

─────────────────────────────────────────────────────────────────────────
                   ГЛАВА 9. Программирование, управляемое событиями
        ─────────────────────────────────────────────────────────────────

             Цель программного средства Turbo Vision -  обеспечить  прог-
        раммиста  рабочей  операционной  средой  для  создания прикладных
        программ,  чтобы он мог сосредоточиться на  разработке  основного
        содержания программ.  Двумя основными средствами Turbo Vision яв-
        ляются встроенная поддержка организации окон и обработка событий.
        В Главе 8 разъяснялись вопросы, связанные с отображаемыми элемен-
        тами, а в данной главе мы расскажем о том, как ориентировать ваши
        программы на обработку событий.

                     Turbo Vision и решение основных проблем
        ─────────────────────────────────────────────────────────────────

             Мы уже описывали прикладные программы Turbo Vision  как  уп-
        равляемые по  событиям  и  давали краткое определение событий как
        воздействий, на которые должны реагировать ваша программа.

                       Чтение входных данных пользователя
        ─────────────────────────────────────────────────────────────────

             В традиционной программе на языке Паскаль вы обычно создаете
        циклический фрагмент  программы,  который выполняет чтение данных
        пользователя, вводимых с клавиатуры, с помощью "мыши" или другими
        способами,  и  принимаете решения на основе этих входных данных в
        цикле.  Вы вызовете процедуры или функции или выполните переход в
        циклический  фрагмент в другом месте программы,  что вызовет пов-
        торное чтение входных данных пользователя:

             repeat
                 B := ReadKey;
                 case B of
                     'i': InvertArray;
                     'e': EditArrayParams;
                     'g': GraphicDisplay;
                     'q': Quit := true;
                 end;
             until Quit;

             Структура программы,  управляемой событиями не очень отлича-
        ется от этой программы. В действительности трудно представить се-
        бе  интерактивную программу,  которая не действует таким же обра-
        зом.  Однако,  для самого программиста программа,  работающая  по
        прерываниям, выглядит несколько иначе.

             В прикладной  программе  Turbo Vision вам не придется выпол-
        нять чтение входных данных пользователя, так как Turbo Vision са-
        ма выполняет эту операцию. Она упаковывает входные данные в запи-
        си на Паскале,  называемые событиями, и выполняет диспетчеризацию
        событий  по  соответствующим  отображаемым элементам в программе.
        Это означает,  что вашему  фрагменту  программы  необходимо  лишь
        знать,  как обращаться с соответствующими входными данными,  и не

         B.Pascal 7 & Objects/TV#1   - 181 -

        требуется выполнять сортировку потока входных данных и поиск  со-
        бытий для обработки.

             Например, если  пользователь  щелкает кнопкой "мыши" в неак-
        тивное окно, Turbo Vision считывает это действие "мыши", упаковы-
        вает его в запись события и передает ее в неактивное окно.

             Если у вас имеется опыт традиционного  программирования,  вы
        можете подумать:  "Ну хорошо, мне больше не потребуется считывать
        входные данные пользователя. Вместо этого я должен буду научиться
        считывать запись события,  связанного с нажатием кнопки "мыши"  и
        сообщить  неактивному окну,  каким образом оно может стать актив-
        ным". На самом деле вам не потребуется писать даже такого  исход-
        ного кода.

             Отображаемые элементы   могут   самостоятельно  обрабатывать
        большую часть входных данных пользователя.  Окно знает,  как отк-
        рыться, закрыться,  переместиться, быть выделенным, изменить раз-
        мер и многое другое. Меню знает, как открыться, взаимодействовать
        с пользователем и закрыться.  Командные кнопки знают, как их "на-
        жимать", как взаимодействовать друг с другом и как изменять цвет.
        Полосы прокрутки знают,  как с ними работать. Неактивное окно мо-
        жет превратиться в активное без вашего участия.

             Какие же функции остаются для программиста?  Вы будете опре-
        делять новые отображаемые элементы с помощью новых действий,  ко-
        торым потребуется знание об определенных видах определяемых  вами
        событий.  Вы должны также обучить свои отображаемые элементы реа-
        гировать на стандартные команды и даже  генерировать  свои  собс-
        твенные команды  ("сообщения") для других отображаемых элементов.
        Механизм уже отработан:  вам остается лишь генерировать команды и
        обучать отображаемые элементы реагировать на них.

             Что же конкретно представляют собой события для вашей  прог-
        раммы, и как Turbo Vision их обрабатывает?

                                 Природа событий
        ─────────────────────────────────────────────────────────────────

             События могут  быть представлены как небольшие пакеты инфор-
        мации, описывающие отдельные воздействия,  на которые должна реа-
        гировать ваша прикладная программа. Каждое нажатие клавиши, дейс-
        твие с помощью "мыши" и какое-то из определенных условий, генери-
        руемых другими компонентами программы, составляют отдельное собы-
        тие.  События нельзя разбивать на более мелкие части; таким обра-
        зом, набор слова пользователем не будет единым событием, а после-
        довательностью индивидуальных событий нажатий клавиш.

             Можно ожидать,  что в объектно-ориентированной  среде  Turbo
        Vision события также являются объектами. Однако, это не так. Сами
        события не выполняют никаких действий; они лишь передают информа-
        цию вашим объектам, поэтому являются структурами записей.


         B.Pascal 7 & Objects/TV#1   - 182 -

             Сердцевиной записи каждого события является единое поле типа
        Word по имени What.  Численное значение поля  What  отражает  вид
        происшедшего события,  а  в  оставшейся части записи события хра-
        нится специфическая информация об этом событии: код опроса клави-
        атуры для события нажатия клавиши,  информация о положении "мыши"
        и состоянии ее кнопок для события использования "мыши" и так  да-
        лее.

             Поскольку различные виды событий прокладывают путь  к  своим
        объектам  назначения  различными  способами,  мы  должны  сначала
        рассмотреть различные виды воспринимаемых средством Turbo  Vision
        событий.



         B.Pascal 7 & Objects/TV#1   - 183 -

                                 Виды сообщений
        ─────────────────────────────────────────────────────────────────

             Рассмотрим возможные  значения  Event.What  более  подробно.
        Имеются  четыре  основных  класса событий:  события,  связанные с
        действиями "мыши", события, связанные с клавиатурой, события свя-
        занные с сообщениями и события типа "никаких действий".  Для каж-
        дого класса определена маска,  следовательно,  ваши объекты могут
        быстро определить, какого общего типа событие произошло, не опре-
        деляя его специфическую  разновидность.  Например,  вместо  того,
        чтобы определять каждое из четырех событий, связанных с действия-
        ми "мыши",  вы лишь должны определить, взведен ли соответствующий
        флаг события в маске. Вместо выражения:

             if Event.What and (evMouseDown or evMouseUp
                            or evMouseMove or evMouseAuto) <> 0 then ...

        вы можете использовать выражение:

             if Event.What and evMouse  <> 0 then ...

             Для разделения событий служат маски:  evNothing (для событий
        типа "никаких   действий"),  evMouse  для  событий,  связанных  с
        "мышью",  evKeyBoard  для  событий,  связанных  с  клавиатурой  и
        evMessage для сообщений.

             Разряды маски события определены на Рис. 9.1.

             ┌───────── Event Flags ─────────┐
             msb                           lsb
              ┌─┬─┬─┬─┬─┬─┬─┬─────────────────── evMessage   = $FF00
              │ │ │ │ │ │ │ │       ┌─────────── evKeyboard  = $0010
              │ │ │ │ │ │ │ │       │ ┌─┬─┬─┬─── evMouse     = $000F
             ╔╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤═╤═╤═╤╧╤╧╤╧╤╧╤╧╗
             ╚═╧═╧═╧═╧═╧═╧╤╧╤╧═╧═╧═╧╤╧╤╧╤╧╤╧╤╝
                          │ │       │ │ │ │ └─── evMouseDown = $0001
                          │ │       │ │ │ └───── evMouseUp   = $0002
                          │ │       │ │ └─────── evMouseMove = $0004
                          │ │       │ └───────── evMouseAuto = $0008
                          │ │       └─────────── evKeyDown   = $0010
                          │ └─────────────────── evCommand   = $0100
                          └───────────────────── evBroadcast = $0200

             Рис. 9.1. Битовый массив поля TEvent.What.

             msb - старший байт; lsb - младший байт.



         B.Pascal 7 & Objects/TV#1   - 184 -

                          События, связанные с "мышью"
        ─────────────────────────────────────────────────────────────────

             Имеются четыре основных вида событий,  связанных с  "мышью":
        нажатие и  отпускание  каждой кнопки "мыши",  изменение положения
        или "автособытие",  связанное с "мышью".  Нажатие клавиши  "мыши"
        вызывает событие evMouseDown. Отпускание кнопки "мыши" генерирует
        событие  evMouseUp.   Перемещение   "мыши"   производит   событие
        evMouseMove. А если вы удерживаете кнопку "мыши" в нажатом состо-
        янии,  то Turbo Vision будет  периодически  генерировать  событие
        evMouseAvto,  позволяя вашей прикладной программе выполнять такие
        действия,  как повторяющуюся прокрутку.  Все записи событий, свя-
        занных с устройством "мыши",  включают положение "мыши", следова-
        тельно,  объекту, выполняющему обработку события, известно место-
        нахождение "мыши" в момент наступления события.

                        События, связанные с клавиатурой
        ─────────────────────────────────────────────────────────────────

             События, связанные  с клавиатурой,  еще более просты.  После
        нажатия вами клавиши Turbo Vision генерирует  событие  evKeyDown,
        которое отслеживает, какая клавиша была нажата.

                        События, связанные с сообщениями
        ─────────────────────────────────────────────────────────────────

             Эти события выступают в трех формах: команды, передачи сооб-
        щений и сообщения пользователя.  Разница между ними заключается в
        способах их обработки,  которые изложены ниже.  В целом,  команды
        отмечаются в  поле  What  с помощью значения evCommand,  передачи
        сообщений - с помощью значения evBroadcast, а сообщения пользова-
        телей - какой-либо определенной пользователем константой.

                         Событие типа "никаких действий"
        ─────────────────────────────────────────────────────────────────

             Это событие  можно  быть названо "неактивным" событием.  Оно
        перестало быть событием,  так как было полностью обработано. Если
        поле  What  в записи событий содержит значение evNothing,  то эта
        запись не содержит никакой полезной информации для обработки.

             Когда объект  Turbo  Vision завершает обработку события, она
        вызывает метод ClearEvent,  который снова  устанавливает  в  поле
        What значение evNothing,  указывающее, что событие было обработа-
        но. Объекты должны просто игнорировать события evNothing, так как
        они уже обработаны другими объектами.

                                События и команды
        ─────────────────────────────────────────────────────────────────

             События, в конечном итоге,  оканчивают  свое  существование,
        будучи транслированными в какие-либо команды.  Например,  нажатие
        клавиши "мыши" на элементе строки состояния  генерирует  событие,

         B.Pascal 7 & Objects/TV#1   - 185 -

        связанное с  "мышью".  Когда это событие достигает объекта строки
        состояния,  то он реагирует на событие, генерируя командное собы-
        тие с установкой значения поля Command, соответствующего команде,
        связанной с пунктом строки состояния.  Нажатие "мышью"  на  Alt+X
        Exit генерирует команду cmQuit, которая интерпретируется приклад-
        ной программой как указание на прекращение выполнения программы и
        завершение работы.

                              Маршрутизация событий
        ─────────────────────────────────────────────────────────────────

             Отображаемые элементы Turbo Vision функционируют по принципу
        "Говорить только тогда,  когда к тебе обращаются".  Это означает,
        что вместо того,  чтобы активно осуществлять  поиск  данных,  они
        пассивно  ожидают,  пока администратор событий сообщит им о собы-
        тии, на которое им следует реагировать.

             Для того,  чтобы ваши программы Turbo Vision действовали  по
        вашему плану, вы должны не только сообщать отображаемым элементам
        об их функциях при наступлении определенных событий,  но и  пони-
        мать, каким  образом события достигают ваших отображаемых элемен-
        тов.  Ключом к помещению событий в нужные места является правиль-
        ная трассировка событий.  Ряд событий передается на всем протяже-
        нии выполнения программы, а другие события узко направлены на вы-
        полнение отдельных частей программы.

                           Откуда появляются события?
        ─────────────────────────────────────────────────────────────────

             Как отмечено в Главе 10 "Объекты приложения",  главный  цикл
        обработки    объекта    TApplication   -   метод   Run   вызывает
        TGroup.Execute,  который является в основе своей повторяемым цик-
        лом, который выглядит примерно следующим образом:

             var E: TEvent;
             E.What := evNothing;           { указывает что нет событий }
             repeat
               if E.What <> evNothing then EventError(E);
               GetEvent(E);                { упаковывает запись события }
               HandleEvent(E);      { направляет событие в нужное место }
             until EndState <> Continue;

             В сущности,  GetEvent  анализирует ситуацию и выполняет про-
        верку на наступление события.  Если событие имело место, GetEvent
        создает соответствующую запись о событии.  HandleEvent направляет
        событие к соответствующим отображаемым элементам. Если событие не
        было  обработано  (и сброшено) к моменту возвращения в этот цикл,
        выполняется вызов EventError для обозначения несостоявшегося  со-
        бытия. По умолчанию, EventError не выполняет никаких действий.

                   Примечание: GetEvent,  HandleEvent  и EventError более
              подробно описываются ниже.


         B.Pascal 7 & Objects/TV#1   - 186 -

                            Описание маршрута событий
        ─────────────────────────────────────────────────────────────────

             Маршрут событий начинается всегда с текущего режимного отоб-
        ражаемого элемента.  Для  обычных операций этим отображаемым эле-
        ментом является,  как правило, объект вашей прикладной программы.
        При  работе  с режимным окном диалога объектом этого окна диалога
        является режимный отображаемый элемент.  В любом случае  режимный
        отображаемый  элемент  - это элемент,  инициализирующий обработку
        событий. Дальнейший маршрут события определяется его природой.

             Маршруты событий  формируются  тремя способами в зависимости
        от вида события. Эти способы включают трассировку событий позици-
        онных, выделенных  и  событий,  связанных  с передачей сообщений.
        Важно понять принцип определения маршрута для каждого вида  собы-
        тия.

                            События позиционирования
        ─────────────────────────────────────────────────────────────────

             В сущности, событиями позиционирования всегда являются собы-
        тия, связанные с "мышью" (evMouse).

             Режимный отображаемый  элемент  первым  получает позиционное
        событие,  а затем обращается к своим отображаемым элементам в со-
        ответствии  с Z-последовательностью для поиска отображаемого эле-
        мента, содержащего позицию, где произошло событие. Далее режимный
        отображаемый  элемент передает событие данному отображаемому эле-
        менту.  Поскольку возможно наложение отображаемых  элементов,  то
        такое место может находиться в ряде отображаемых элементов. Прос-
        мотр отображаемых элементов в  Z-последовательности  гарантирует,
        что  событие  попадет  к самому верхнему отображаемому элементу в
        данном положении.  Ведь пользователь нажимал именно на этот отоб-
        ражаемый элемент!

                   Примечание: О  Z-последовательности  было рассказано в
              Главе 8, "Отображаемые элементы".

             Этот процесс продолжается  до  того  момента,  когда  объект
        больше не сможет отыскать отображаемый элемент, в который необхо-
        димо передать событие,  либо потому что он является  терминальным
        отображаемым  элементом  (не  имеющим отображаемых подэлементов),
        либо в месте наступления события не было  отображаемого  элемента
        (таком,  как нажатие на открытое пространство в окне диалога).  В
        данной точке событие достигло объект, где имело место позиционное
        событие, и этот объект выполнит обработку события.

                           События перемещения фокуса
        ─────────────────────────────────────────────────────────────────

             События перемещения фокуса (события выделения) - это  обычно
        нажатия клавиш (evKeyDown) или команды (evCommand), и они переда-
        ются по цепочке выделения.

         B.Pascal 7 & Objects/TV#1   - 187 -


                   Примечание: Подробнее  о  выделенных отображаемых эле-
              ментах и цепочке выделения см. в разделе "Выбранные и выде-
              ленные отображаемые элементы" в Главе 8, "Отображаемые эле-
              менты".

             Вначале текущий режимный отображаемый элемент достигает  вы-
        деленного  события  и  передает  его в его выбранный отображаемый
        элемент.  Если этот отображаемый элемент имеет выделенный отобра-
        жаемый элемент,  то он передает в него событие. Этот процесс про-
        должается до достижения терминального отображаемого элемента:  им
        будет  выделенный  отображаемый элемент.  Выделенный отображаемый
        элемент принимает и обрабатывает событие перемещения фокуса.

             Если выделенный отображаемый элемент не знает, как обрабаты-
        вать отдельное событие,  он передает его обратно по цепочке выде-
        лений его владельцу.  Этот процесс повторяется до тех  пор,  пока
        событие не будет обработано или снова дойдет до режимного отобра-
        жаемого элемента.  Если режимный отображаемый элемент  не  знает,
        как обрабатывать  возвращенное  событие,  то  он  вызывает  метод
        EventError.  Такая ситуация носит название несостоявшегося  собы-
        тия.
                   Примечание: Невыделенные отображаемые  элементы  могут
              обрабатывать события выделения (перемещения фокуса). См. об
              этом в разделе "Фаза" в данной главе.

             События, связанные  с  клавиатурой,  наглядно   иллюстрируют
        принцип выделенных  событий.  Например,  в  интегрированной среде
        Турбо Паскаля у вас может быть открыто несколько файлов  в  окнах
        редактирования в рабочей области.  Когда вы нажимаете клавишу, вы
        знаете, в какой файл вы хотите поместить символ.  Рассмотрим  те-
        перь, как Turbo Vision реализует ваше намерение.

             Нажатием клавиши  вы производите событие evKeyDown,  которое
        передается в текущий режимный отображаемый элемент,  а именно - в
        объект TApplication. TApplication передает событие в свой выбран-
        ный отображаемый элемент,  в оперативную область (оперативная об-
        ласть    всегда   является   выбранным   отображаемым   элементом
        TApplication).  Оперативная область передает событие в ее выбран-
        ный  отображаемый  элемент,  которым служит активное окно (окно с
        двойной рамкой). Это окно редактирования также имеет отображаемый
        элементы - рамку,  прокручиваемый внутренний отображаемый элемент
        и две полосы прокрутки.  Среди  них  выбираемым  является  только
        внутренний отображаемый элемент (и,  следовательно, выбранным, по
        умолчанию), таким образом,  событие, связанное с клавиатурой, пе-
        реходит  к нему.  Внутренний отображаемый элемент,  редактор,  не
        имеет отображаемых элементов,  следовательно,  он должен  решать,
        как обрабатывать символ в событии evKeyDown.

                               События оповещения
        ─────────────────────────────────────────────────────────────────

             Такими событиями являются оповещения (evBroadcast) или опре-

         B.Pascal 7 & Objects/TV#1   - 188 -

        деленные пользователем сообщения.

             События, связанные с передачей сообщений,  не являются столь
        же ориентированными, как события позиционирования и выделения. По
        определению, при оповещении неизвестно назначения сообщения, поэ-
        тому оно посылается всем отображаемым элементам текущего режимно-
        го отображаемого элемента.

             Текущий режимный  отображаемый  элемент  принимает событие и
        начинает передавать его в его отображаемые элементы в  Z-последо-
        вательности. Если какие-то из этих отображаемых элементов образу-
        ют группу,  то она также передает событие своим отображаемым эле-
        ментам, также в порядке Z-последовательности. Процесс продолжает-
        ся до тех пор,  пока  все  отображаемые  элементы,  принадлежащие
        (прямо или косвенно) режимному отображаемому элементу,  не примут
        событие, или пока отображаемый элемент не сбрасывает событие.

             События, связанные с передачей сообщений, обычно используют-
        ся для связи между отображаемыми элементами.  Например,  когда вы
        нажимаете  с  помощью "мыши" на полосу прокрутки в окне просмотра
        файлов,  то эта полоса должна сообщить  текстовому  отображаемому
        элементу, что он будет изображать другой свой участок. Она выпол-
        няет это с помощью передачи отображаемому элементу оповещения  "Я
        изменилась!", которое получат другие отображаемые элементы, вклю-
        чая текст, и отреагируют на него. Подробнее об этом см. в разделе
        "Связь между отображаемыми элементами" в данной главе.

                   Примечание: Передаваемые  сообщения могут быть направ-
              лены объекту с помощью функции Message.

                       События, определяемые пользователем
        ─────────────────────────────────────────────────────────────────

             При более близком знакомстве с Turbo Vision и  событиями  вы
        уже можете пожелать определять целые новые категории событий, ис-
        пользуя старшие разряды в поле What записи события.  По умолчанию
        Turbo  Vision  будет выполнять трассировку этих событий как собы-
        тий, связанных с оповещением.  Однако,  вы можете пожелать, чтобы
        ваши  новые  события  были выделенными или позиционными,  и Turbo
        Vision предоставит вам такую возможность.

         B.Pascal 7 & Objects/TV#1   - 189 -


             Turbo Vision определяет две маски, Positional и Focused, со-
        держащие разряды, соответствующие событиям в поле What записи со-
        бытия, и трассировка которых должна выполняться по  местонахожде-
        нию и по выделению (фокусу),  соответственно. По умолчанию, маска
        Positional содержит все разряды evMouse,  а маска Focused  -  все
        разряды evKeyboard.  Если вы определите,  что другой разряд будет
        новым видом события, трассировку которого вы хотите выполнить ли-
        бо по местонахождению, либо по выделению, то вы должны просто до-
        бавить этот разряд в соответствующую маску.

              Примечание: Оперирование разрядами в маске излагается в
                          Главе 11.



         B.Pascal 7 & Objects/TV#1   - 190 -

                              Маскирование событий
        ─────────────────────────────────────────────────────────────────

             Каждый объект отображаемого элемента имеет битовое  поле  по
        имени EventMask,  которое используется для определения, какие со-
        бытия будет обрабатывать отображаемый  элемент.  Разряды  в  поле
        EventMask соответствуют разрядам в поле TEvent.What.  Если разряд
        для заданного вида события установлен,  то  отображаемый  элемент
        примет этот вид события для обработки.  Если разряд для заданного
        вида события очищен, то отображаемый элемент его проигнорирует.

             Например, по умолчанию EventMask отображаемого элемента иск-
        лючает evBroadCast, но EventMask группы включает его. Таким обра-
        зом, группы получают события оповещения по умолчанию, а отобража-
        емые элементы - нет.

                                      Фаза
        ─────────────────────────────────────────────────────────────────

             Существуют ситуации, когда обработку событий перемещения фо-
        куса (особенно нажатий клавиш) желательно поручить  невыделенному
        отображаемому элементу.  Например при  просмотре  прокручиваемого
        текста в окне вы можете нажимать клавиши для прокрутки текста, но
        поскольку текстовое окно является выделенным отображаемым элемен-
        том, то события перемещения фокуса передаются в него а не к поло-
        сам прокрутки,  которые могут выполнять  прокрутку  отображаемого
        элемента.

             Turbo Vision располагает механизмом,  позволяющим невыделен-
        ным отображаемым элементам просматривать и  обрабатывать  события
        перемещения фокуса. Хотя описанная в разделе "События перемещения
        фокуса" данной главы схема маршрутизации  вполне  верна,  имеются
        два исключения из схемы маршрутизации по цепочке выделений.

             Когда событие  перемещения  фокуса поступает для обработки в
        режимный отображаемый элемент, в трассировке его перемещения мож-
        но выделить три "фазы":

             - Событие  передается  в  какой-либо отображаемый элемент (в
               Z-последовательности)   в   котором   установлены    флаги
               ofPreProcess.

             - Если событие не очищается ни одним из них,  то оно переда-
               ется в выделенный отображаемый элемент.

             - Если и после этого событие не очищено,  то оно  передается
               (опять  же в Z-последовательности) в отображаемые элементы
               с установленными флагами ofPostProcess.

             Таким образом,  если  в предыдущем примере требуется,  чтобы
        полоса прокрутки просматривала последовательности нажатия клавиш,
        которые представляют интерес для выделенного текстового отобража-
        емого элемента, то она должна быть инициализирована с помощью ус-

         B.Pascal 7 & Objects/TV#1   - 191 -

        тановки флага ofPreProcess.

             Обратите внимание также, что в этом примере установка разря-
        дов ofPreProcess либо ofPostProcess не представляет существенного
        различия, так  как будет действовать лишь один из них.  Поскольку
        выделенный отображаемый элемент в данном случае не будет  обраба-
        тывать  событие  (сам объект TScroller не выполняет никаких дейс-
        твий по нажатиям клавиш), то полосы прокрутки могут просматривать
        события либо до, либо после того, как событие попадает в средство
        прокрутки.

             Однако, в целом в подобном  случае  желательно  использовать
        разряд ofPostProcess,  так как он предоставляет большую гибкость.
        Позднее вы сможете добавить дополнительные функциональные возмож-
        ности внутреннему отображаемому элементу,  который выполняет про-
        верку нажатий клавиш. Однако, если нажатия клавиш были восприняты
        полосой прокрутки до того, как вы достигли выделенного отображае-
        мого элемента (ofPreProcess), ваш внутренний отображаемый элемент
        не сможет выполнять по ним действия.

             Хотя может случиться,  что вам потребуется захватить события
        перемещения  фокуса до того,  как выделенный отображаемый элемент
        сможет их воспринять, правильно будет оставить открытыми как мож-
        но больше возможностей, чтобы вы (или кто-то другой) смогли в бу-
        дущем породить что-либо из этого объекта.

                                   Поле Phase
        ─────────────────────────────────────────────────────────────────

             Каждая группа имеет поле фазы по имени Phase, у которого мо-
        жет  быть  одно  из  трех  значений:  phFocused,  phPreProcess  и
        phPostProcess. С помощью проверки флага Phase владельца вид может
        сообщить,  попадает  ли  в него обрабатываемое им событие до,  во
        время или после маршрутизации фокуса.  Это может быть необходимо,
        так как некоторые отображаемые элементы выполняют поиск различных
        событий или реагируют на одни и те же события различным  образом,
        в зависимости от фазы.

             Рассмотрим пример простого окна  диалога,  который  содержит
        строку  ввода и кнопку с меткой "All right",  где A - сокращенное
        название клавиши для командной кнопки. При работе с обычными эле-
        ментами  управления  окном диалога вы не должны думать о фазе.  В
        большинстве элементов управления разряд ofPostProcess  установлен
        по умолчанию,  следовательно, нажатия клавиш (выделенные события)
        достигнут их и позволят им захватить выделение, если оно является
        буквой их сокращенного названия которое было набрано.  Нажатием A
        фокус перемещается к командной кнопке "All right".

             Предположим, однако что строка ввода выделена, и поэтому на-
        жатия клавиш будут обрабатываться и  вставляться  строкой  ввода.
        Нажатием клавиши A "A" помещается в строку ввода, и кнопка никог-
        да не "увидит" события,  так как оно было  обработано  выделенным
        отображаемым  элементом.  Вашим первым побуждением может быть вы-

         B.Pascal 7 & Objects/TV#1   - 192 -

        полнение кнопкой проверки препроцессорной  обработки  клавиши  A,
        поэтому  она может встретить клавишу-сокращение до того,  как она
        будет обработана выделенным отображаемым элементом.  К  сожалению
        это будет препятствовать вашему набору буквы "A" в строке ввода!

             Решение здесь достаточно просто: командная кнопка должна вы-
        полнять проверку различных клавиш-сокращений до и после обработки
        события выделенным отображаемым элементом.  По умолчанию,  кнопка
        будет выполнять поиск клавиши-сокращения в  ходе  препроцессорной
        обработки  формы Alt+буква и постпроцессорной обработке буквенной
        формы. Поэтому вы всегда можете использовать буквенные сокращения
        Alt  в  окне  диалога,  но использовать только стандартные буквы,
        когда выделенный элемент управления не "съедает" нажатия клавиш.

             Это довольно просто сделать. Кнопки, по умолчанию, имеют ус-
        тановленные разряды ofPreProcess  и  ofPostProcess  одновременно,
        следовательно, они могут просматривать события перемещения фокуса
        как до, так и после того, как это сделает выделенный отображаемый
        элемент. Однако, внутри HandleEvent кнопка лишь выполняет провер-
        ку определенных нажатий клавиш,  если выделенный элемент управле-
        ния уже просмотрел событие:

             evKeyDown:                      { это часть оператора case }
             begin
               C := HotKey(Title^);
               if (Event.KeyCode = GetAltCode(C)) or
                  (Owner^.Phase = phPostProcess) and (C <> #0) and
                  (upcase(Event.CharCode) = C) or
                  (State and sfFocused <> 0) and (Event.CharCode = ' ')
                  then
                    begin
                      PressButton;
                      ClearEvent(Event);
                    end;
             end;

                                     Команды
        ─────────────────────────────────────────────────────────────────

             Большинство событий  позиционирования перемещения фокуса за-
        канчивают существование после преобразованы в команды обрабатыва-
        ющими их объектами.  Это означает,  что объект часто реагирует на
        нажатие кнопки "мыши" или клавиши, генерируя связанное с командой
        событие.

             Например, при щелчке "мышью" в строке состояния в приложении
        Turbo Vision вы генерируете событие позиционирование (связанное с
        "мышью").  Программа определяет, что нажатие было выполнено в об-
        ласти,  управляемой строкой состояния, поэтому она передает собы-
        тие объекту StatusLine строки состояния.

             Этот объект  определяет,  какие  его  элементы управляют об-
        ластью нажатия и считывает запись элемента  состояния  для  этого

         B.Pascal 7 & Objects/TV#1   - 193 -

        элемента. Обычно имеется команда, связанная с этим элементом, по-
        этому объект StatusLine создаст запись "повисшего" события с  по-
        мощью поля What,  установленного evCommand и поле Command,  уста-
        новленное на команду,  связанную с его элементом состояния. Затем
        он очищает событие, связанное с "мышью", имея в виду, что следую-
        щим обнаруженным GetEvent событием будет только что сгенерирован-
        ное событие, связанное с командой.



         B.Pascal 7 & Objects/TV#1   - 194 -

                               Определение команд
        ─────────────────────────────────────────────────────────────────

             Turbo Vision располагает большим количеством  предопределен-
        ных команд, однако многие команды вы должны определить сами. Ког-
        да вы создаете новый отображаемый элемент, вы также создадите ко-
        манду для активизации отображаемого элемента. Команды могут назы-
        ваться как угодно, однако в Turbo Vision есть соглашение, соглас-
        но которому идентификатор команды должен начинаться с "cm". Меха-
        ника создания команд чрезвычайно  проста  -  вы  просто  создаете
        константу:

             const
               cmConfuseTheCat = 100;

             Turbo Vision  резервирует команды от 0 до 99 и от 256 до 999
        для собственных нужд.  В ваших прикладных  программах  вы  можете
        использовать числа от 100 до 255 и от 1000 до 65535 для обозначе-
        ния команд.

             Причиной использования двух диапазонов команд служит то, что
        заблокированы  могут быть лишь команды от 0 до 255.  Turbo Vision
        резервирует часть команд,  которые могут  быть  заблокированы,  и
        часть  команд,  которые  не могут быть заблокированы,  в качестве
        своих стандартных команд и внутренних рабочих элементов.  Осталь-
        ные команды находятся в вашем полном распоряжении.

             Диапазоны имеющихся команд приведены в Таблице 9.1.

                     Диапазоны команд Turbo Vision    Таблица 9.1
                ┌─────────────┬───────────────┬─────────────────┐
                │   Диапазон  │Зарезервировано│    Может быть   │
                │             │               │    запрещено    │
                ├─────────────┼───────────────┼─────────────────┤
                │ 0..99       │        Да     │      Да         │
                │ 100..255    │        Нет    │      Да         │
                │ 256..999    │        Да     │      Нет        │
                │ 1000..65535 │        Нет    │      Нет        │
                └─────────────┴───────────────┴─────────────────┘



         B.Pascal 7 & Objects/TV#1   - 195 -

                                 Привязка команд
        ─────────────────────────────────────────────────────────────────

             Когда вы создаете элемент меню или строки состояния,  то  вы
        "привязываете"  к нему команду.  Когда пользователь выбирает этот
        элемент, то генерируется запись события с полем What, установлен-
        ным в evCommand,  и полем Command, установленном на значение свя-
        занное с элементом команды.  Такой командой может быть либо стан-
        дартная команда Turbo Vision,  либо определенная вами команда.  В
        то же время вы связываете вашу команду с элементом меню или стро-
        ки состояния,  или же к оперативной клавише. Таким образом, поль-
        зователь может активизировать команду при использовании меню  или
        "мыши" нажатием одной клавиши (такой как клавиша-сокращение).

             Важно помнить,  что определение команды не определяет, какое
        действие будет предпринято,  когда эта команда появится в  записи
        события.  Вы  должны  будете  сообщить соответствующим объектам о
        том, как им реагировать на эту команду.

                         Разрешение и запрещение команд
        ─────────────────────────────────────────────────────────────────

             Бывают случаи,  когда вам нужно,  чтобы определенные команды
        были  недоступны  для пользователя на некоторое время.  Например,
        если у вас нет открытых окон, то для пользователя не имеет смысла
        иметь возможность генерации cmClose - стандартной команды  закры-
        тия окна. Turbo Vision располагает способом разрешения и запреще-
        ния наборов команд.

             А именно, для того, чтобы запретить или разрешить группу ко-
        манд,  вы должны использовать глобальный тип TCommandSet, который
        является набором чисел от 0 до 255. (Именно поэтому заблокированы
        могут быть только команды в диапазоне 0...255.) В следующем фраг-
        менте программы выполняется разрешение группы команд, связанных с
        окнами:

             var
               WindowCommands: TCommandSet;
             begin
               WindowCommands := [cmNext, cmPrev, cmZoom, cmResize,
                                  cmClose];
               DisableCommands(WindowCommands);
             end;



         B.Pascal 7 & Objects/TV#1   - 196 -

                                Обработка событий
        ─────────────────────────────────────────────────────────────────

             После того,  как вы определили команду и  установили  способ
        управления ее генерацией,  например,  с помощью элемента меню или
        командной кнопки окна диалога,  вы  должны  обучить  отображаемый
        элемент реагировать на эту команду.

             Каждый отображаемый элемент наследует метод HandleEvent, ко-
        торый способен реагировать на большую часть входных данных  поль-
        зователя. Если вы хотите, чтобы отображаемый элемент выполнил ка-
        кую-либо операцию для вашей прикладной программы,  то вам следует
        переопределить его метод HandleEvent и обучить новый метод выпол-
        нению двух операций - реагировать на определенные вами новые  ко-
        манды  и реагировать на события,  связанные с "мышью" и клавиату-
        рой, нужным вам образом.

             Метод HandleEvent определяет поведение отображаемого элемен-
        та.  Два отображаемых элемента с идентичными методами HandleEvent
        будут одинаково реагировать на события. Когда вы порождаете новый
        тип отображаемого элемента,  вы хотели бы,  чтобы его поведение в
        целом более-менее повторяло поведение предшествующего  отображае-
        мого элемента,  с некоторыми изменениями. Наиболее простым спосо-
        бом здесь является вызов метода HandleEvent предшествующего отоб-
        ражаемого  элемента в качестве составной части метода HandleEvent
        нового объекта.

             Общая схема метода  HandleEvent  порожденного  отображаемого
        элемента выглядит следующим образом:

             procedure NewDescendant.HandleEvent(var Event: TEvent);
             begin
                  { код, изменяющий или ограничивающий унаследованное
                  поведение }
               Parent.HandleEvent(Event);
                  { код, выполняющий дополнительные функции }
             end;

             Другими словами,  если вы хотите, чтобы новый объект обраба-
        тывал определенные события иначе,  чем его предок (или совсем  их
        не обрабатывал!),  вы должны прервать эти события до передачи со-
        бытия методу HandleEvent предшествующего отображаемого  элемента.
        Если  вы  хотите,  чтобы поведение нового объекта было аналогично
        поведению его предшественника,  но чтобы он имел и  ряд  дополни-
        тельных функций, вы должны добавить соответствующий код после вы-
        зова процедуры HandleEvent предка.



         B.Pascal 7 & Objects/TV#1   - 197 -

                                 Запись события
        ─────────────────────────────────────────────────────────────────

             До сих пор в данной главе события рассматривались в теорети-
        ческом плане.  Описывались различные виды  событий  (связанные  с
        "мышью", клавиатурой,  сообщениями и "холостыми" действиями), оп-
        ределяемыми полем события What.  Было также кратко упомянуто  ис-
        пользование поля Command для событий, связанных с командами.

             Теперь рассмотрим,  что  представляет  собой запись события.
        Модуль DRIVERS.TPU Turbo Vision определяет в качестве  вариантной
        записи тип TEvent:

             TEvent = record
                What: Word;
                case Word of
                   evNothing: ();
                   evMouse: (
                      Buttons: Byte;
                      Double: Boolean;
                      Where: TPoint);
                   evKeyDown: (
                      case Integer of
                         0: (KeyCode: Word);
                         1: (CharCode: Char; ScanCode: Byte));
                   evMessage: (
                     Command: Word;
                     case Word of
                         0: (InfoPtr: Pointer);
                         1: (InfoLong: Longint);
                         2: (InfoWord: Word);
                         3: (InfoInt: Integer);
                         4: (InfoByte: Byte);
                         5: (InfoChar: Char));
             end;

             TEvent является вариантной записью.  Ее содержание вы можете
        узнать из поля What. Так, например, если TEvent.What является со-
        бытием вида evMouseDown, то TEvent будет содержать:

             Buttons: Byte;
             Double: Boolean;
             Where: TPoint;

             Если TEvent.What является событием типа evKeyDown, то компи-
        лятор разрешит вам доступ к данным либо как:

             KeyCode: Word;

        либо как:

             CharCode: Char;
             ScanCode: Byte;

         B.Pascal 7 & Objects/TV#1   - 198 -


             Заключительное поле признака в записи события - это значение
        Pointer,  LongInt, Word, Integer, Byte или Char. Это поле в Turbo
        Vision используется различным образом.  Отображаемые элементы мо-
        гут  самостоятельно  генерировать  события и передавать их другим
        отображаемым элементам,  и при этом  они  часто  используют  поле
        InfoPtr.

                   Примечание: Вопросы связи между отображаемыми  элемен-
              тами и полем InfoPtr рассматриваются в разделе "Связь между
              отображаемыми элементами" в данной главе.

                                 Очистка событий
        ─────────────────────────────────────────────────────────────────

             Метод отображаемого  элемента  HandleEvent завершает процесс
        обработки события вызовом метода ClearEvent.  Этот метод устанав-
        ливает   поле   Event.What   равное   событию  evNothing  и  поле
        Event.InfoPtr, равное @Self, которые служат универсальными сигна-
        лами того,  что событие обработано. Если событие передается затем
        другому объекту, то этот объект проигнорирует это событие "холос-
        того действия".

                             Несостоявшиеся события
        ─────────────────────────────────────────────────────────────────

             Обычно какой-либо отображаемый элемент  выполняет  обработку
        события  в  вашей  прикладной программе.  Если такой отображаемый
        элемент не обнаруживается, то режимный отображаемый элемент вызы-
        вает метод EventError.  EventError вызывает метод EventError вла-
        дельца отображаемого элемента и так далее вверх по дереву отобра-
        жаемых элементов до вызова метода TApplication.EventError.

             По умолчанию метод TApplication.EventError не выполняет  ни-
        каких  действий.  Он  может  использоваться в процессе разработки
        программы для переопределения метода EventError, чтобы привести в
        действие окно диалога ошибок или подать звуковой сигнал.  Так как
        конечный пользователь вашего приложения не несет  ответственность
        за его неспособность обработать событие,  такое окно диалога оши-
        бок в поставляемой версии будет, вероятно, вызывать раздражение.

             Метод ClearEvent также способствует осуществлению связи меж-
        ду отображаемыми элементами.  Не следует забывать,  что обработка
        события не может быть закончена без вызова ClearEvent.

                     Модификация механизма обработки событий
        ─────────────────────────────────────────────────────────────────

             Основным в текущем режимном отображаемом  элементе  является
        следующий цикл:

             var
               E: TEvent;

         B.Pascal 7 & Objects/TV#1   - 199 -

             begin
               E.What := evNothing;
               repeat
                 if E.What <> evNothing then EventError(E);
                 GetEvent(E);
                 HandleEvent(E);
               until EndState <> Continue;
             end;

                          Централизованный сбор событий
        ─────────────────────────────────────────────────────────────────

             Одним из   важнейших  преимуществ  объектно-ориентированного
        программирования является то,  что вашей программе может быть не-
        известен источник событий. Объекту окна, например, требуется лишь
        знать,  что  когда  он  получает в событии команду cmClose,  окно
        должно закрыться. Не имеет значения, получена ли команда от щелч-
        ка кнопкой "мыши" или пиктограммы закрытия окна,  выбора элемента
        меню,  оперативной клавиши или сообщения  от  другого  объекта  в
        программе. Ему даже не требуется определять, для него ли предназ-
        начена эта команда.  Ему необходимо лишь знать,  что ему передано
        событие для обработки, и он его будет обрабатывать в соответствии
        с его осведомленностью в этой области.

             Ключом к подобным событиям из "черного ящика"  служит  метод
        GetEvent приложения.  Метод GetEvent является единственной частью
        вашей программы, которой требуется знать источник событий. Объек-
        ты  в  вашей прикладной программе просто вызывают GetEvent и пол-
        ностью на него полагаются  при  получении  событий,  связанных  с
        "мышью", клавиатурой или отложенных событий, генерируемых другими
        объектами.

             Если вы хотите создать новые виды событий (например,  чтение
        символов из последовательного порта), то нужно просто переопреде-
        лить метод TApplication.GetEvent в объекте приложения. Как вы мо-
        жете  видеть  из  фрагмента программы TProgram.GetEvent в примере
        программы APP.PAS, цикл GetEvent считывает информацию от "мыши" и
        с клавиатуры и затем вызывает метод Idle.  Для того, чтобы ввести
        новый источник событий,  вы должны либо переопределить  Idle  для
        считывания символов из последовательного порта и генерировать со-
        бытия на их основе, либо переопределить сам метод GetEvent, чтобы
        добавить  в цикл вызов GetComEvent(Event),  где метод GetComEvent
        возвращает запись события,  если имеется символ в предназначенном
        ему последовательном порте.

                         Переопределение метода GetEvent
        ─────────────────────────────────────────────────────────────────

             Метод GetEvent текущего режимного отображаемого элемента вы-
        зывает метод GetEvent его владельца и так далее на всем  протяже-
        нии вверх   по   дереву   отображаемых   элементов   до    метода
        TApplication.GetEvent,  являющегося обычным местом выбора следую-
        щего события.

         B.Pascal 7 & Objects/TV#1   - 200 -


             Поскольку Turbo    Vision    всегда     использует     метод
        TApplication.GetEvent для выполнения фактического выбора событий,
        вы можете модифицировать события для всей вашей прикладной  прог-
        раммы с помощью переопределения этого метода.  Например, для реа-
        лизации клавиатурных макрокоманд вы можете просматривать события,
        возвращаемые методом GetEvent, перехватывать определенные нажатия
        клавиш и развертывать их в  макрокоманды.  Далее  для  прикладной
        программы  будет известно,  что поток событий будет идти прямо от
        пользователя.

             procedure TMyApp.GetEvent(var Event: TEvent);
             begin
               inherited GetEvent(Event);
                                       { вызвать метод TApplication }
                       .               { специальная обработка }
                       .
                       .
             end;

                          Использование времени простоя
        ─────────────────────────────────────────────────────────────────

             Центральная роль TApplication.GetEvent имеет еще и то  преи-
        мущество, что он вызывает метод TApplication.Idle,  даже если со-
        бытия еще не поступали. TApplication.Idle - это пустой метод, ко-
        торый вы можете переопределять, чтобы выполнять обработку отобра-
        жаемого элемента,  параллельно  обработке  данного  отображаемого
        элемента.

             Предположим, например,  что вы определяете отображаемый эле-
        мент по имени THeapView,  который  использует  метод  UpDate  для
        отображения имеющейся  динамически распределяемой области памяти.
        Если вы переопределите метод TApplication.Idle следующим методом,
        то пользователь получит возможность непрерывно просматривать име-
        ющуюся динамическую память независимо  от  того,  в  каком  месте
        программы он находится.

                   Примечание: Пример средства просмотра динамической па-
              мяти имеется в составе примеров программ на ваших дистрибу-
              тивных дисках.

             procedure TMyApp.Idle;
             begin
               inherited Idle;
               HeapViewer.Update;
             end;

                      Связь между отображаемыми элементами
        ─────────────────────────────────────────────────────────────────

             Программа Turbo Vision является инкапсулированной  (скрытой)
        в  теле объектов,  таким образом вы разрабатываете фрагмент прог-

         B.Pascal 7 & Objects/TV#1   - 201 -

        раммы только в терминах объектов. Предположим, что объекту требу-
        ется обменяться информацией с другим объектом в вашей программе -
        в традиционной программе,  которая представляет собой простое ко-
        пирование информации из одной структуры данных в  другую,  или  в
        объектно-ориентированной  программе,  которая может быть не такой
        простой, так как объекты могут не знать, как обнаружить друг дру-
        га.

             Связь между отображаемыми элементами - это не просто переда-
        ча данных между эквивалентными частями  прикладной  программы  на
        языке Паскаль.  (Хотя две части традиционной прикладной программы
        на Паскале значительно уступают по своим  функциональным  возмож-
        ностям двум отображаемым элементам Turbo Vision.)

             Если вам  требуется  осуществить  связь  между отображаемыми
        элементами, то первым возникает вопрос о том, насколько правильно
        вы распределили задачи между отображаемыми элементами.  Здесь мо-
        гут проявиться недостатки в разработке программы.  Возможно, сле-
        дует объединить два отображаемых элемента в один, или переместить
        часть одного отображаемого элемента в другой.

                       Промежуточные отображаемые элементы
        ─────────────────────────────────────────────────────────────────

             Если разработка программы неплохая, но, тем не менее, требу-
        ет осуществления связи между отображаемыми  элементами,  то  пра-
        вильным  решением  будет  создать промежуточный отображаемый эле-
        мент.

             Предположим, например,  что у вас есть объект в виде  элект-
        ронной таблицы и объект в виде текстового процессора, и вы хотите
        вставить какой-либо фрагмент из электронной таблицы  в  текстовый
        процессор, и наоборот. В прикладной программе Turbo Vision вы мо-
        жете это сделать с помощью прямой связи между отображаемыми  эле-
        ментами. Предположим, что позднее вам потребуется добавить к этой
        группе объектов,  к примеру,  базу данных и включать данные в эту
        базу и считывать из нее. Для этого вам потребуется распространить
        установленную  вами связь между первыми двумя объектами на третий
        объект.

             Лучшим решением здесь будет установка промежуточного отобра-
        жаемого элемента - в данном случае,  буфера вырезанного изображе-
        ния.  Объекту потребуется лишь знать,  как заносить в него запись
        или изымать запись. Вне зависимости от того, сколько новых объек-
        тов вы добавите к группе, ваша работа от этого не усложнится.

                    Сообщения между отображаемыми элементами
        ─────────────────────────────────────────────────────────────────

             Если вы внимательно анализировали ситуацию и уверены в  раз-
        работке вашей программы и вам не требуется создание промежуточно-
        го вида,  то можете реализовать простую связь между двумя отобра-
        жаемыми элементами.

         B.Pascal 7 & Objects/TV#1   - 202 -


             Прежде, чем будет установлена связь между отображаемыми эле-
        ментами, отображаемый элемент должен обнаружить другой отображае-
        мый элемент и даже удостовериться, существует ли он вообще.

             Приведем наглядный пример.  Модуль Stddlg содержит окно диа-
        лога TFileDialog (это отображаемый элемент, который открывается в
        интегрированной  среде,  когда  вы  хотите загрузить новый файл).
        TFileDialog имеет объект TFileList, показывающий дисковый каталог
        и выше его - FilеInputLine,  демонстрирующий файл,  выбранный для
        загрузки в данным момент. Всякий раз, когда пользователь выбирает
        в списке файлов FileList другой файл, данный список должен требо-
        вать от FileInputLine вывода имени нового файла.

             В данном    случае   FileList   может   быть   уверен,   что
        FileInputLine существует,  так как оба они существуют в  одном  и
        том  же  объекте  FileDialog.  Каким же образом FileList сообщает
        FileInputLine, что пользователь выбрал новое имя?

             FileList создает и передает сообщение.  В данном случае име-
        ется метод TFileList.FocusItem,  который передает событие и метод
        (объекта FileInputLine) HandleEvent, который его принимает:

              procedure TFileList.FocusItem(Item: Integer);
              var
                Event: TEvent;
              begin
                 inherited FocusItem(Item);        { вначале вызывается
                                                     наследуемый метод }
                 Message(TopView, evBroadcast, cmFileFocused,
                         List^.At(Item));
                 { TopView указывает текущий режимный отображаемый
                   элемент }
              end;

              procedure TFileInputLine.HandleEvent(var Event:TEvent);
              var
                 Name: NameStr;
              begin
                 inherited HandleEvent(Event);
                 if (Event.What = evBroadcast) and
                    (Event.Command = cmFileFocused) and
                    (State and sfSelected = 0) then
                  begin
                    if PSearchRec(Event.InfoPtr)^.Attr and Directory <> 0
                    then Data^ := PSearchRec(Event.InfoPtr)^.Name + '\' +
                         PFileDialog(Owner)^.WildCard
                  else Data^ := PSearchRec(Event.InfoPtr)^.Name;
                  DrawView;
               end;
             end;

                   Примечание: TopView  указывает  на  текущий   режимный

         B.Pascal 7 & Objects/TV#1   - 203 -

              отображаемый элемент.

             Message - это функция, которая генерирует событие, связанное
        с сообщением, и возвращает указатель на объект (если таковой име-
        ется), который выполняет обработку события.

             Имейте в виду,  что TFileList.FocusItem для применения функ-
        ции Message в качестве процедуры,  использует расширенный синтак-
        сис Турбо Паскаля (директиву компилятора $X+),  так как здесь  не
        имеют значения результаты, получаемые от функции Message.

                           Кто управляет оповещением?
        ─────────────────────────────────────────────────────────────────

             Предположим, прежде чем вы  приступите  к  выполнению  како-
        го-либо действия,  вам требуется узнать, имеется ли в оперативной
        области открытое окно.  Каким же образом вы сможете это  сделать?
        Для этого ваш фрагмент программы должен передать событие, связан-
        ное с оповещением,  на которое окна смогут  отреагировать.  "Под-
        пись",  оставленная объектом,  обрабатывающим событие, укажет вам
        его обработчик.

                                Все ли в порядке?
        ─────────────────────────────────────────────────────────────────

             Приведем конкретный пример.  В интегрированной среде  разра-
        ботки программ Турбо Паскаля  IDE,  если  пользователю  требуется
        открыть  окно просмотра,  то выполняющей это программе необходимо
        сделать проверку на открытие такого окна ранее.  Если такое  окно
        не открыто,  то программа его откроет;  если не открыто, то прог-
        рамма переместит его наверх.

             Выполнить передачу оповещающего сообщения достаточно просто:

             AreYouThere := Message(DeskTop, evBroadcast, cmFindWindow,
                                    nil);

             В программе  для  метода  HandleEvent окна просмотра имеется
        проверка на реагирование на  cmFindWindow  посредством  "очистки"
        события:

             case Event.Command of
                 .
                 .
                 .
               cmFindWindow: ClearEvent(Event);
                 .
                 .
                 .
             end;

             Не следует забывать,  что ClearEvent не только устанавливает
        поле What записи события на evNothing,  но также и  устанавливает

         B.Pascal 7 & Objects/TV#1   - 204 -

        поле InfoPtr на @Self.  Функция Message выполняет чтение из  этих
        полей,  и,  если событие было обработано, возвращает указатель на
        объект, который  обрабатывал  связанное  с сообщением событие.  В
        данном случае этим объектом будет окно просмотра.  Таким образом,
        далее за строкой, которая посылает сообщение, мы включаем следую-
        щее:

             if AreYouThere = nil then
               CreateWatchWindow            { если отсутствует, создать }
             else AreYouThere^.Select;      { иначе вывести на экран }

             Пока окно  просмотра  будет  единственным объектом,  который
        способен реагировать на передачу cmFindWindow,  то по  завершении
        программы поверх отображаемых элементов в оперативной области бу-
        дет наверняка находиться только одно окно просмотра.

                               Какое окно верхнее?
        ─────────────────────────────────────────────────────────────────
             Используя изложенный ранее способ вы  можете  также  опреде-
        лить,  например,  какое  окно является самым верхним отображаемым
        элементом этого типа в рабочей области.  Так как событие, связан-
        ное  с  передачей  сообщения,  передается каждому из отображаемых
        подэлементов режимного отображаемого элемента в  Z-последователь-
        ности (порядок  обратной  вставки),  то  отображаемый  элементом,
        включенный позднее других, будет "верхним" отображаемый элементом
        оперативной области.

             Рассмотрим кратко  ситуацию  в интегрированной интерактивной
        среде, при которой пользователь имеет открытое окно просмотра на-
        верху в  оперативной области при прохождении программы через окно
        редактирования. Окно просмотра может быть активным окном (с двой-
        ной  рамкой,  вершиной  стека),  однако  строка выполнения в окне
        программы должна отслеживать выполняющую программу.  Если в вашей
        оперативной области открыто несколько окон редактирования, они не
        должны накладываться, а интегрированная среда должна знать, в ка-
        ком  из  окон редактирования она будет выполнять отслеживание вы-
        полнения программы.
             Этим окном должно быть переднее или самое верхнее  окно  ре-
        дактирования, которое  определяется как последнее вставленное ок-
        но. Для того,  чтобы указать,  какое окно находится "сверху", ин-
        тегрированная интерактивная среда передает сообщение,  на которое
        смогут отреагировать только окна редактирования. Первым окном ре-
        дактирования, которое получит сообщение, будет последнее включен-
        ное окно; оно будет обрабатывать событие посредством "очистки", и
        интегрированная  среда поэтому будет знать,  какое окно использо-
        вать для отслеживания программы с  помощью  чтения  возвращаемого
        функцией Message результата.

                            Вызов метода HandleEvent
        ─────────────────────────────────────────────────────────────────

             Вы можете также создать или модифицировать событие,  а затем

         B.Pascal 7 & Objects/TV#1   - 205 -

        вызвать непосредственно метод HandleEvent. У вас имеется в распо-
        ряжении три вида вызова:

             1. Отображаемый  элемент  вызывает   непосредственно   метод
                HandleEvent братского отображаемого элемента.  Событие не
                будет распространяться на другие  отображаемые  элементы.
                Оно    перейдет    непосредственно   к   другому   методу
                HandleEvent, который управляет возвратом к пользователю.

                       Примечание: "Братские" отображаемые элементы - это
                 отображаемые элементы, имеющие одного владельца.

             2. Вы  можете  вызвать метод HandleEvent владельца.  Событие
                будет распространяться на  другие  отображаемые  элементы
                вниз по цепочке отображаемых элементов. (Если вы вызывае-
                те  метод  HandleEvent  из  вашего  собственного   метода
                HandleEvent,  то  ваш  метод HandleEvent будет вызываться
                рекурсивно.) После обработки события управление возвраща-
                ется к пользователю.

             3. Вы можете вызвать метод HandleEvent вида из другой цепоч-
                ки отображаемых элементов.  Событие будет спускаться вниз
                по  этой цепочке отображаемых элементов.  После обработки
                события управление возвращается к пользователю.



         B.Pascal 7 & Objects/TV#1   - 206 -

─────────────────────────────────────────────────────────────────────────
                             ГЛАВА 10. Объекты приложения
        ─────────────────────────────────────────────────────────────────

             Сердцевиной любой программы  Turbo  Vision  является  объект
        приложения. В  данной  главе  подробно описываются различные виды
        объектов приложений,  что они могут делать,  и как вы  можете  их
        настраивать. Она охватывает следующие темы:

             * Организация объектов приложения.

             * Построение объекта приложения.

             * Настройка оперативной области.

             * Выход в командный процессор DOS.

             * Настройка строки состояния.

             * Настройка строки меню.

             * Использование времени простоя.

             * Создание контекстно-зависимого справочника.

                           Организация объектов приложения
        ─────────────────────────────────────────────────────────────────

             Объект приложения играет в вашем приложении Turbo Vision две
        решающих роли.  Это отображаемый элемент,  который управляет всем
        экраном и является управляемым событиями механизмом,  взаимодейс-
        твующим с "мышью",  клавиатурой и другими частями компьютера. Эти
        две роли взаимосвязаны, но вы можете рассматривать их отдельно. В
        данном разделе эти вопросы рассматриваются в плане следующих воп-
        росов:

             - роль приложения как отображаемого элемента;

             - роль приложения как группы;

             - три важнейших метода: Init, Run и Done.

                         Приложение как отображаемый элемент
        ─────────────────────────────────────────────────────────────────

             Сначала может  показаться  странным рассматривать приложение
        как отображаемый элемент.  Кроме того, отображаемый элемент - это
        что-то видимое,  в  то  время  как  приложения представляет собой
        просто некую концепцию.  Однако основным принципом  отображаемого
        элемента является то, что он занимает прямоугольную область экра-
        на, а приложение отвечает за весь экран.

             В действительности объект приложение делает гораздо  больше,
        чем простое управление экраном, но это одна из его важнейших обя-

         B.Pascal 7 & Objects/TV#1   - 207 -

        занностей, и в этом смысле в  определенные  моменты  очень  важно
        помнить, что объект приложения - это отображаемый элемент.

                                Приложение как группа
        ─────────────────────────────────────────────────────────────────

             Приложение является не только отображаемым элементом,  но  и
        группой. Групповые  отображаемые  элементы  имеют два специальных
        свойства: возможность владеть отображаемыми подэлементами и  спо-
        собность быть  режимными.  Объекты  приложения используют преиму-
        щества и того, и другого свойства.

                         Приложение как владелец подэлементов
        ─────────────────────────────────────────────────────────────────

             Границы отображаемого элемента  приложения  охватывают  весь
        экран, но само приложение невидимо. Оно подразделяет экран на три
        различных  области и назначает для каждой из них отображаемый по-
        дэлемент. По умолчанию приложение присваивает объекту строки меню
        верхнюю строку экрана, строке состояния - нижнюю строку экрана, а
        объекту приложения - все строки между ними.

             Три отображаемых  подэлемента  приложения  легко  запомнить,
        поскольку вы видите их при работе с программой,  но иногда  легко
        забыть, что владельцем их всех является объект приложения. Другие
        разделы  данной  главы  посвящены конкретно строка меню,  строкам
        состояния и оперативным областям,  однако важно помнить,  что  за
        всеми ими стоит объект приложения.

             Вы можете рассматривать отображаемый элемент приложения  как
        конечного владельца  всех отображаемых элементов программы.  Если
        вы будете следовать по цепочке владения от любого заданного отоб-
        ражаемого элемента,  это  приведет вас обратно к объекту приложе-
        ния.

                                Режимность приложения
        ─────────────────────────────────────────────────────────────────

             Большую часть времени во время работы программы Turbo Vision
        объект приложения   является   режимным  отображаемым  элементом.
        Единственным исключением является время, когда вы выполняете дру-
        гой отображаемый элемент (обычно диалоговое окно), который стано-
        вится текущим отображаемым элементом,  пока не  вызывается  метод
        EndModal и приложение снова не становится режимным.

                               Методы Init, Run и Done
        ─────────────────────────────────────────────────────────────────

             Основной блок приложения Turbo Vision всегда состоит из трех
        операторов, вызывающих  три  основных  метода объекта приложения:
        Init, Run и Done:

             var AnyApp: TApplication;

         B.Pascal 7 & Objects/TV#1   - 208 -

             begin
               AnyApp.Init;
               AnyApp.Run;
               AnyApp.Done;
             end;

             Никакие другие  операторы  помещать  в  основной блок вам не
        потребуется. Специфическое для приложения поведение следует зада-
        вать в конструкторе Init и завершаться в деструкторе Done.

                                   Конструктор Init
        ─────────────────────────────────────────────────────────────────

             Поскольку объект приложения (как все отображаемые  элементы)
        содержит виртуальные  методы,  перед  использованием  объекта  вы
        должны вызвать конструктор. По умолчанию все объекты Turbo Vision
        имеют конструктор  с  именем Init.  Конструктор приложения задает
        отображаемые элементы приложения и инициализирует подсистемы при-
        ложения, включая  драйверы "мыши" и видеодрайверы,  администратор
        памяти и обработчик ошибок.  Если вы переопределяете Init,  чтобы
        добавить к вашему приложению специальные элементы, убедитесь, что
        вы вызываете конструктор Init, наследуемые от TApplication.

                                      Метод Run
        ─────────────────────────────────────────────────────────────────

             Run - это простой метод,  но он очень важен.  После того как
        Init устанавливает объект приложения,  метод Run выполняет объект
        приложения, делая его режимным и запуская работу приложения.  Ос-
        новная  деятельность  метода  Run   состоит   в   простом   цикле
        repeat..until, который имеет примерно следующий вид:

             Repeat
               получить событие;
               обработать событие;
             until Quit;

             Это не является фактическим кодом, а просто показывает прин-
        ципы. Метод Run получает отложенные события от "мыши" или клавиа-
        туры или других частей приложения, затем обрабатывает события не-
        посредственно или выполняя их маршрутизацию соответствующим отоб-
        ражаемым элементам.  В итоге некоторое событие генерирует команду
        "выхода", цикл завершает работу и приложение завершается.



         B.Pascal 7 & Objects/TV#1   - 209 -

                                   Деструктор Done
        ─────────────────────────────────────────────────────────────────

             После завершения метода Done деструктор Done уничтожает  лю-
        бые принадлежащие приложению объекты: строку меню, строку состоя-
        ния, оперативную область и любые добавленные вами объекты,  а за-
        тем останавливает обработчик ошибок Turbo Vision и драйверы.

              В общем случае деструктор Done вашего приложения должен от-
        менять все,  что установлено конструктором Init,  затем  вызывать
        деструктор Done,  наследуемый из TApplication,  который управляет
        уничтожением стандартных отображаемых подэлементов  приложения  и
        остановом подсистем  приложения.  Если  вы  переопределяете метод
        Init приложения,  то,  возможно,  вам потребуется  переопределить
        также метод Done.

                            Построение объекта приложения
        ─────────────────────────────────────────────────────────────────

             Конструктор приложения в общем случае достаточно прост и  не
        требует параметров, но выполняет ряд важных функций. Когда вы оп-
        ределяете конструктор приложения, то существует относительно нем-
        ного вещей,  которые вы обязаны сделать,  и одним из них является
        вызов конструктора Init,  наследуемого от TApplication. Конструк-
        тор TApplication выполняет две важных функции,  которые вы должны
        понимать:

             - вызов наследуемого конструктора;
             - инициализация подсистем.

             Вызов наследуемого из TApplication  конструктора  Init  пол-
        ностью берет на себя заботу об этом. Если ваше приложение являет-
        ся производным от TProgram,  а не TApplication, то убедитесь, что
        ваш конструктор  вызывает наследуемый конструктор и устанавливает
        все подсистемы, которые вы хотите использовать.

                           Вызов наследуемого конструктора
        ─────────────────────────────────────────────────────────────────

             В большинстве  случаев,  когда вы в своем объекте приложения
        переопределяете конструктор Init, то включаете вызов наследуемого
        конструктора, а  затем добавляете код.  Большую часть настроек вы
        можете получить путем переопределения виртуальных методов, поэто-
        му вам редко требуется заменять наследуемый конструктор. В следу-
        ющем разделе описывается все поведение,  наследуемое из TProgram,
        которое вам  нужно  заменить,  если  вы  не вызываете наследуемый
        конструктор.

         B.Pascal 7 & Objects/TV#1   - 210 -

                                 Конструктор TProgram
        ─────────────────────────────────────────────────────────────────

             Конструктор TProgram выполняет несколько важных функций:

             - устанавливает переменную Application таким образом,  чтобы
               она указывала на ваш объект приложения;

             - вызывает виртуальный метод InitScreen для установки  пере-
               менных режима экрана;

             - вызывает конструктор, наследуемый из TGroup;

             - устанавливает флаги State и Options;

             - устанавливает видеобуфер;

             - вызывает виртуальные методы InitDesktop,  InitStatusLine и
               InitMenuBar.

             Обратите внимание на инициализацию переменных режима экрана,
        объекта оперативной  области,  объекта строки состояния и объекта
        строки меню, которая происходит через вызовы виртуальных методов,
        так что  вы  можете переопределить соответствующие методы в своем
        объекте приложения, и наследуемый конструктор будет вызывать ваши
        переопределенные методы.

                   Примечание: Эти  виртуальные методы описываются в раз-
              делах данной главы, посвященных оперативной области, строке
              состояния и строке меню.

                                   Порядок вызовов
        ─────────────────────────────────────────────────────────────────

             При переопределении конструктора приложения очень важен  по-
        рядок, в котором вы вызываете наследуемый конструктор. В качестве
        общего правила вам следует вызывать наследуемый конструктор  Init
        первым, а  затем определять все специфические моменты своего при-
        ложения:

             constructor TNewApplication.Init;
             begin
               inherites Init;            { вызов TApplication.Init }
                .
                .                         { ваш код инициализации }
                .
             end;

             Помните, что объекты приложения представляют собой отобража-
        емые элементы,  и конечный объект-предок TObject очищает все поля
        в объекте,  присваивая им нули или значения nil.  Поскольку вызов
        TApplication.Init дает в результате вызов TObject.Ini,  любые из-
        менения, которые вы вносите в объект приложения пере вызовом нас-

         B.Pascal 7 & Objects/TV#1   - 211 -

        ледуемого конструктора Init, будут потеряны.

             В общей  ситуации  единственным  случаем,  когда  вы  должны
        что-то делать перед вызовом наследуемого конструктора  приложения
        является использование объектов редакторов файлов. Перед построе-
        нием объекта приложения вы должны выделить буферы  файлового  ре-
        дактора (как описывается в Главе 15).

                               Инициализация подсистем
        ─────────────────────────────────────────────────────────────────

             Основной разницей между TApplication  и  его  предшествующим
        типом TProgram является то, что TApplication переопределяет конс-
        труктор объекта и его деструктор для инициализации,  а затем  за-
        вершает работу основных подсистем. Этими пятью подсистемами явля-
        ются:

             - администратор памяти;

             - видеоадминистратор;

             - администратор событий;

             - обработчик системных ошибок;

             - администратор протокола.

             Turbo Vision устанавливает каждую подсистему, вызывая проце-
        дуру в  модуле  App.  Конструктор TApplication вызывает каждую из
        них перед вызовом конструктора Init, наследуемого из TProgram:

             constructor TApplication.Init;
             begin
               InitMemory;         { установить администратор памяти }
               InitVideo;          { установить видеоадминистратор }
               InitEvents;         { установить администратор событий }
               InitSysError;       { установить обработчик системной
                                     ошибки }
               InitHistory;        { установить администратор протокола }
               inherited Init;     { вызвать TProgram.Init }
             end;

             Хотя можно  создать  рабочее приложение,  производное непос-
        редственно от TProgram,  вам все равно  следует  использовать  по
        крайней мере некоторые из стандартных подсистем приложения.  Нап-
        ример, чтобы создать тип приложения,  не использующий систему ве-
        дения протокола,  вы  можете  аналогично  TApplication создать из
        TProgram новый производный  тип,  но  без  вызова  в конструкторе
        InitHistory.


         B.Pascal 7 & Objects/TV#1   - 212 -

                                 Администратор памяти
        ─────────────────────────────────────────────────────────────────

             Администратор памяти делает для Turbo Vision три важных  ве-
        щи:
             - устанавливает буфер безопасности;
             - управляет отменяемыми буферами отображения;
             - управляет перемещаемыми буферами файлового редактора.

             Буфер безопасности - это составная часть Turbo Vision. Когда
        вы выделяете память для объекта Turbo Vision, администратор памя-
        ти выполняет проверку, чтобы убедиться, что распределение не зат-
        ронуло буфера безопасности в конце памяти. Эта защита предохраня-
        ет  ваше  приложение  от ситуации нехватки памяти,  и дает вашему
        приложению возможность освободить память и выполнить восстановле-
        ние.

             При наличии  свободной  памяти  над стеком групповые объекты
        распределяют в этой области отменяемые буфера отображения. Сохра-
        няя копию образа экрана,  группа может сохранить время при вызове
        для самоотображения.  Если эта память потребуется при другой опе-
        рации выделения  памяти,  группа отменяет буфер и в следующий раз
        полностью отображается заново.

             Если вы используете в своих приложения  файловые  редакторы,
        вам нужно зарезервировать,  для перемещаемых буферов, память выше
        динамически распределяемой области (как  поясняется  в  Главе  15
        "Редактор  и текстовые отображаемые элементы").  Подсистема адми-
        нистратора памяти управляет за вас данными буферами.

                                  Видеоадминистратор
        ─────────────────────────────────────────────────────────────────

             Процедура InitVideo  устанавливает  видеоадминистратор Turbo
        Vision. Видеоадминистратор отслеживает режим экрана  при  запуске
        приложения, так  что может восстановить экран при завершении при-
        ложения. InitVideo также устанавливает значения внутренних видео-
        переменных Turbo Vision: ScreenHeight, ScreenWidth, ScreenBuffer,
        CheckSnow, CursorLines и HiResScreen.

             Соответствующая процедура DoneVideo восстанавливает экран  в
        то состояние, в каком он был при запуске, очищает экран и восста-
        навливает курсор.

                                Администратор событий
        ─────────────────────────────────────────────────────────────────

             Процедура InitEvents  проверяет,  установлена  ли  в системе
        "мышь", и,  если "мышь"  присутствует,  устанавливает  переменную
        MouseEvents в значение True,  разрешая обработчик прерываний "мы-
        ши" и выводя на экран курсор "мыши". Если Turbo Vision не обнару-
        живает при запуске "мышь",  администратор событий полностью игно-
        рирует "мышь".

         B.Pascal 7 & Objects/TV#1   - 213 -


             Соответствующая процедура DoneEvent останавливает  админист-
        ратор событий,  запрещая  обработчик  прерывания  "мыши и скрывая
        курсор "мыши.

                             Обработчик системной ошибки
        ─────────────────────────────────────────────────────────────────

             Обработчик системной ошибки выполняет в вашем приложении две
        функции:

             - перехватывает критические ошибки DOS;

             - перехватывает нажатия клавиш Ctrl+Break.

             По умолчанию  обработчик  критической  ошибки  перехватывает
        критические ошибки DOS и выводит на экран в строке состояния при-
        ложения  Turbo  Vision  предупреждающее  сообщение,  предоставляя
        пользователю возможность восстановления.

             Обработчик ошибок  также  перехватывает  клавиши Ctrl+Break,
        позволяя вашей программе реагировать некоторым отличным от завер-
        шения способом.

             Если вы  не вызываете для установки обработчика ошибок Turbo
        Vision InitSysError, ваше приложение будет обрабатывать критичес-
        кие ошибки  и клавиши Ctrl+Break как любое другое приложение Пас-
        каля:  критические ошибки будут давать ошибки этапа выполнения, а
        Ctrl+Break  будет обрабатываться в соответствии с системной уста-
        новкой.

                   Примечание: Об обработке ошибок по умолчанию рассказы-
              вается в Главе 20 "Руководства по языку".

                               Администратор протокола
        ─────────────────────────────────────────────────────────────────

             Процедура InitHistory выделяет блок памяти для списков  про-
        токола строк ввода. Переменная HistorySize определяет объем выде-
        ляемой памяти (по умолчанию это 1 килобайт). Если вы хотите выде-
        лить  другой объем памяти,  то перед вызовом InitHistory (то есть
        перед вызовом   TApplication.Init)   нужно   изменить    значение
        HistorySize.

             Если выделение  памяти  выполняется успешно,  то InitHistory
        устанавливает переменную HistoryBlock таким образом, что она ука-
        зывает  на  выделенную память.  Если выделение памяти завершается
        неудачно,  то HistoryBlock содержит значение nil,  и все  попытки
        добавить данные в протокол или считать их из него будут игнориро-
        ваться.

             Соответствующая процедура DoneHistory освобождает блок памя-
        ти, выделенный для HistoryBlock. Процедура DoneHistory использует

         B.Pascal 7 & Objects/TV#1   - 214 -

        HistorySize для определения объема освобождаемой памяти,  поэтому
        важно, чтобы вы не изменяли значение переменной HistorySize после
        вызова InitHistory.

                               Изменение режимов экрана
        ─────────────────────────────────────────────────────────────────

             Turbo Vision  отслеживает текущий режим экрана в битовой пе-
        ременной с  именем  ScreenMode.  ScreenMode  содержит  комбинацию
        констант режима  экрана smMono,  smBW80,  smCO80 и smFont8x8.  По
        умолчанию приложение Turbo Vision подразумевает режим экрана, ко-
        торый ваша операционная среда DOS использует при запуске приложе-
        ния. Если вы находились в цветном 25-строчном режиме,  то его бу-
        дут использовать  приложения  Turbo Vision.  Если вы находились в
        50-строчном текстовом режиме VGA,  приложение Turbo Vision  также
        запускается в этом режиме.

             В большинстве  случаев  вам не нужно переключаться между мо-
        нохромным, черно-белым и цветным режимами,  поскольку они  обычно
        зависят от аппаратуры пользователя.  Чаще вы будете переключаться
        между 25-строчным обычным режимом и 43-/50-строчным режимом высо-
        кого разрешения.   Для   этого   переключите   бит   smFont8x8  в
        ScreenMode, вызвав для этого  метод  SetScreenMode.  В  следующем
        примере показана часть метода приложения HandleEvent, который от-
        вечает на команду cmVideo переключением бита  режима  шрифта  8х8
        элементов изображения:

             procedure TSomeApplication.HandleEvent(var Event: TEvent);
             begin
               inherited HandleEvent(Event);
               if Event.What = evCommand then
               case Event.Command of
                  cmVideo: SetScreenMode(ScreenMode xor smFont8x8);
                      .
                      .
                      .
               end;
             end;

                            Настройка оперативной области
        ─────────────────────────────────────────────────────────────────

             Объект оперативной области изменять требуется редко. Исполь-
        зуемый по  умолчанию  объект  оперативной области охватывает весь
        экран, кроме верхней и нижней его строки, и знает управлять вклю-
        ченными в нее окнами и диалоговыми окнами. Однако, вам может пот-
        ребоваться изменить ее размер или позицию,  либо изменить исполь-
        зуемый по умолчанию образец фона.

             В данном разделе мы коснемся следующих тем:

             - построение объекта оперативной области;
             - включение и выполнение окон;

         B.Pascal 7 & Objects/TV#1   - 215 -

             - упорядочивание окон;
             - изменение образца фона.

                        Построение объекта оперативной области
        ─────────────────────────────────────────────────────────────────

             Объекты приложения вызывают для построения объекта оператив-
        ной области и присваивание его глобальной переменной Desktop вир-
        туальный метод InitDesktop. По умолчанию InitDesktop получает ог-
        раниченный прямоугольник  приложения  и строит объект оперативной
        области типа TDesktop,  который  покрывает  отображаемый  элемент
        приложения кроме первой и последней строки.

             Чтобы построить  объект приложения,  охватывающий другую об-
        ласть, вам нужно переопределить InitDesktop.  Например, если ваше
        приложение не имеет строки состояния, вам нужно обеспечить  охват
        объектом оперативной области той строки, которая обычно принадле-
        жит строке состояния.  Вы можете сделать это двумя способами: пу-
        тем вызова наследуемого метода  и  модификации  результата,  либо
        путем полной замены наследуемого метода.

                          Использование наследуемого метода
        ─────────────────────────────────────────────────────────────────

             Так как вы знаете, что делает наследуемый метод InitDesktop,
        то можете вызвать этот метод, а затем модифицировать полученный в
        результате объект,  изменив,  как показано в  следующем  примере,
        границы оперативной области:

             procedure TMyApplication.InitDesktop;
             var R: TRect;
             begin
               inherited InitDesktop;   { конструктор используемой по
                                          умолчанию оперативной области }
               Desktop^.GetExtent(R);   { получить его границы }
               Inc(R.B.Y);              { переместить нижнюю на строку
                                          вниз }
               Desktop^.Locate(R);      { установить для границ новый
                                          размер }
             end;

                              Замена наследуемого метода
        ─────────────────────────────────────────────────────────────────

             Вместо того, чтобы использовать наследуемый метод, вы можете
        также создать отдельный объект оперативной области.  В показанном
        ниже примере приведен метод InitDesktop,  который  строит  объект
        оперативной области, покрывающий ту же область, что и оперативная
        область в предыдущем примере.

             procedure TMyApplication.InitDesktop;
             var R: TRect;
             begin

         B.Pascal 7 & Objects/TV#1   - 216 -

               GetExtent(R);           { получить границы приложения }
               Int(R.A.Y);             { переместить верхнюю строку, что
                                         даст место для строки меню }
               New(Desktop, Init(R));  { построить оперативную область с
                                         этими границами }
             end;

             Преимущество данного подхода в том,  что он несколько  быст-
        рее, но  он основан на знании наследуемого метода.  То есть,  ис-
        пользование наследуемого метода гарантирует,  что все выполняемые
        наследуемым методом действия будут выполняться. Если вы заменяете
        метод, то нужно обеспечить дублирование всех действий заменяемого
        метода.

                             Включение и выполнение окон
        ─────────────────────────────────────────────────────────────────
             Почти во всех случаях  объект  оперативной  области  владеет
        всеми окнами и диалоговыми окнами в приложении. Так как оператив-
        ная область - это группа,  для включения режимных  и  безрежимных
        отображаемых  элементов  вы  можете  использовать  обычные методы
        Insert и Execute.  Однако для включения и  выполнения  приложение
        предлагает более надежный способ.

                              Включение безрежимных окон
        ─────────────────────────────────────────────────────────────────
             Объект приложения наследует метод InsertWindow, воспринимаю-
        щий в  качестве  своего параметра оконный объект и обеспечивающий
        допустимость окна перед включением его в оперативную область. Ис-
        пользование InsertWindow  вместо включения окон непосредственно в
        оперативную область обеспечивает,  что любые окна  в  оперативной
        области  проходят две проверки на допустимость,  что позволит вам
        избежать проблем.

             InsertWindow выполняет с оконным объектом две проверки:

             * Вызывает метод ValidView,  чтобы убедиться, что построение
               окна  не приведет при распределении памяти к использованию
               памяти из буфера безопасности.
             * Вызывает метод Valid окон, передавая ему параметр cmValid.
               Этот метод возвращает значение True только если окно и все
               его отображаемые подэлементы построены корректно.

             Если оба метода (Valid и ValidView) указывают,  что окно яв-
        ляется допустимым,  то InsertWindow вызывает метод Insert объекта
        оперативной области для включения окна. Если окно не проходит од-
        ну из проверок,  то InsertWindow не включает окно, уничтожает его
        и возвращает False.

                      Выполнение режимных отображаемых элементов
        ─────────────────────────────────────────────────────────────────

             Метод ExecuteDialog  приложения  во многом аналогичен методу

         B.Pascal 7 & Objects/TV#1   - 217 -

        InsertWindow. Разница между ними в том,  что при определении  до-
        пустимости оконного  объекта ExecuteDialog вызывает метод Execute
        оперативной области,  чтобы сделать окно режимным,  а не включает
        его. Как и подразумевает его название, метод ExecuteDialog сконс-
        труирован с учетом диалоговых окон, но вы можете передать ему лю-
        бой оконный объект, который хотите сделать режимным.

             ExecuteDialog воспринимает также второй параметр - указатель
        на буфер данных для использования GetData и SetData.  Если указа-
        тель имеет  значение  nil,  то ExecuteDialog пропускает обработку
        GetData/SetData. Если  значение  указателя  отлично  от  nil,  то
        ExecuteDialog перед  выполнением  окна  вызывает SetData,  а если
        пользователь не отменяет  диалогового  окна,  то  вызывает  метод
        GetData.

                   Примечание: Методы GetData  и  SetData  описываются  в
              Главе 12 "Объекты управляющих элементов".

                                 Упорядочивание окон
        ─────────────────────────────────────────────────────────────────

             Объектам оперативной области известны два способа упорядочи-
        вания  принадлежащих им окон - вывод с перекрытием и без перекры-
        тия.  Вывод без перекрытия предусматривает такое упорядочивание и
        изменение размеров окон,  что на экране они не перекрываются. Вы-
        вод с перекрытием означает упорядочивание окон по убыванию разме-
        ра,  начиная  с верхнего левого угла оперативной области.  Первое
        окно покрывает всю оперативную область,  следующее смещается вниз
        и вправо на один пробел и так далее. Результатом будет стек окон,
        спускающихся вниз по оперативной области с видимой строкой меню и
        левой стороной каждого окна.

             Вывод без  перекрытия или с перекрытием выполняется методами
        объекта TApplication Tile и Cascade соответственно.  По умолчанию
        метод HandleEvent объекта TApplication связывает Tile и Cascade с
        командами cmTile и cmCascade.  Эти команды поступают  от  пунктов
        Tile и Cascade стандартного меню Window.

             Чтобы автоматически  выводить окна с перекрытием или без пе-
        рекрытия, для всех окон нужно установить бит ofTileable. По умол-
        чанию для оконных объектов бит ofTileable установлен,  а для диа-
        логовых окон - нет.  Если вы собираетесь использовать безрежимные
        диалоговые окна,  которые  хотите выводить с перекрытием или без,
        не забудьте установить в конструкторе объекта бит ofTileable.

                            Задание области упорядочивания
        ─────────────────────────────────────────────────────────────────

             По умолчанию  для вывода окон с перекрытием и без перекрытия
        используется вся оперативная область. Если вы хотите изменить эту
        область, ваш  объект приложения должен переопределять виртуальный

         B.Pascal 7 & Objects/TV#1   - 218 -

        метод GetTileRect.

             Например, если у вас есть неперекрывающиеся окна  сообщений,
        которые все охватывают последние четыре строки оперативной облас-
        ти, вы можете упорядочить окна для покрытия области выше окна со-
        общений:

             procedure TTileApp.GetTileRect(var R: TRect):
             begin
               Desktop^.GetExtent(R);      { получить размеры оперативной
                                             области }
               R.B.Y := R.B.Y - 4;         { исключить последние четыре
                                             строки }
             end;

                                 Задание направления
        ─────────────────────────────────────────────────────────────────

             Оперативная область позволяет вам управлять направлением вы-
        вода перекрывающихся окон по вертикали или горизонтали.  По умол-
        чанию окна упорядочиваются по вертикали. Это означает, что если у
        вас есть два окна,  и они выводятся с перекрытием,  то одно выво-
        дится выше другого.  Если вы установите поле TileColumnFirst объ-
        екта оперативной области в значение True,  то оперативная область
        будет при перекрытии использовать упорядочивание в горизонтальном
        направлении.  При  установке TileColumnFirst в True и выводе двух
        окон с перекрытием они будут располагаться рядом.

                                    Изменение фона
        ─────────────────────────────────────────────────────────────────

             Объект оперативной  области даже перед включением каких-либо
        окон по умолчанию владеть еще одним отображаемым  элементом.  Это
        отображаемый элемент  фона.  Фоновый  отображаемый  элемент - это
        очень простой отображаемый элемент,  который ничего не делает,  а
        только  отображается в неперекрытой части оперативной области.  В
        Z-последовательности фон располагается за всеми другими отобража-
        емыми  элементами,  и,  поскольку  он не является выбираемым,  то
        всегда там остается.  Оперативная область сохраняет указатель  на
        свой фоновый отображаемый элемент в поле Background.

             Вероятно, единственное,  что  вы  захотите сделать с фоном -
        это изменение образца фона.  По умолчанию объект оперативной  об-
        ласти выводит единственный символ,  повторяя его по всех области.
        Изменить этот  единственный  символ очень просто.  Изменение фона
        для отображения более одного символа несколько более сложно.

                              Изменение символа образца
        ─────────────────────────────────────────────────────────────────

             Простейший способ изменения символа образца фона  состоит  в
        том, чтобы  подождать,  пока оперативная область создаст свой ис-
        пользуемый по  умолчанию  фон.  Затем  вы  можете  изменить  поле

         B.Pascal 7 & Objects/TV#1   - 219 -

        Pattern объекта фона, которое содержит этот повторяющийся символ.
        В следующем примере используемый по умолчанию символ фона заменя-
        ется буквой C:

             procedure TMyApplication.InitDesktop;
             begin
               inherited InitDesktop;    { построить оперативную область
                                           по умолчанию }
               Desktop^.Background^.Pattern := 'C'; { изменить символ
                                           образца }
             end;

             Начальное значение символа образца фона передается в качест-
        ве параметра конструктору фона  отображаемого  элемента,  который
        вызывается виртуальным методом InitBackground объекта оперативной
        области. Если вы создаете свой производный объект оперативной об-
        ласти, то  можете  переопределить InitBackground для передачи при
        построении фона нужного символа,  а не более позднего его измене-
        ния. Однако, поскольку единственной причиной определения вами но-
        вого объекта оперативной области является создание более сложного
        фона, вам следует просто подставить новое значение в поле Pattern
        в InitDesktop.

                              Изображение сложного фона
        ─────────────────────────────────────────────────────────────────

             Изображение сложного фона с образцом, состоящим из более чем
        одного символа,  требует создания двух новых производных объектов
        - фонового  объекта,  который отображается нужным вам образом,  и
        объекта оперативной области,  который использует вместо стандарт-
        ного фона TBackground ваш специализированный фон.

             Программа следующего примера реализует фоновый объект, кото-
        рый повторяет заданную строку по всей оперативной области.

             program NewBack;

             uses Objects, Drivers, Views, App;

             type
               PMyBackground = ^TMyBackground;
               TMyBackground = object(TBackground)
                 Text: TTitleStr;
               constructor Init(var Bounds: TRect; AText: TTitleStr);
               procedure Draw; virtual;
             end;
             PMyDesktop = ^TMyDesktop;
             TMyDesktop = object(TDesktop)
               procedure InitBackground; virtual;
             end;
             TMyApplication = object(TApplication)
               procedure InitDesktop; virtual;
             end;

         B.Pascal 7 & Objects/TV#1   - 220 -


             constructor TMyBackground.Init(var Bounds: TRect; AText:
                                            TTitleStr);
             begin
               inherited Init(Bounds,  ' ');  { построить новый
                                                отображаемый элемент }
               Text := AText;                 { получить текст }
               while Length(Text) < SizeOf(TTitleStr) - 1 do
                 Text := Text + AText;        { заполнить всю строку }
             end;

             procedure TMyBackground.Draw;
             var DrawBuffwer: TDrawBuffer;
             begin
               MoveStr(DrawBuffer, Text, GetColor(1)); { поместить
                                                строку в буфер }
               WriteLine(0, 0, Size.Y, DrawBuffer); { записать текст }
             end;

             procedure TMyDesktop.InitBackground;
             var R: TRect;
             begin
               GetExtrent(R);                 { получить прямоугольник
                                                оперативной области }
               Background := New(PMyBackground, Init(R,'Turbo Vision'));
             end;

             procedure TMyApplicartion.InitDesktop;
             var R: TRect;
             begin
               GetExtent(R);                  { получить прямоугольник
                                                приложения }
               R.Grow(0, -1);                 { обеспечить место для
                                                строки меню и строки
                                                состояния }
               Desktop := New(PMyDesktop, Init(R)); { построение
                                                специальной оперативной
                                                области }
             end;

             var MyApp: TMyApplication;
             begin
               MyApp.Init;
               MyApp.Run;
               MyApp.Done;
             end.

             Ключевым в  фоновом  объекте является метод Draw.  Если вы с
        ним поработаете,  то можете получить весьма  интересные  эффекты.
        Однако имейте в виду, что обычной целью фона является обеспечение
        нейтрального фона для работы пользователей,  поэтому он не должен
        быть слишком отвлекающим.


         B.Pascal 7 & Objects/TV#1   - 221 -

                           Выход в командный процессор DOS
        ─────────────────────────────────────────────────────────────────

             TApplication обеспечивает простой способ,  который позволяет
        пользователям вашего  приложения работать с командным процессором
        DOS. В  ответ  на  команду  cmDosShell  стандартного  меню  File,
        TApplication вызывает его метод DosShell.

             DosShell перед  фактическим  запуском  командного процессора
        останавливает некоторые из подсистем приложения,  а  затем  вновь
        запускает их при выходе пользователя командный процессор. Исполь-
        зуемый командным процессором интерпретатор команд задается  пере-
        менной операционной среды COMSPEC.

                      Настройка сообщения командного процессора
        ─────────────────────────────────────────────────────────────────

             Перед выходом в интерпретатор команд DosShell вызывает  вир-
        туальный метод WriteShellMsg для вывода на экран следующего сооб-
        щения:

             Type EXIT to return...

             Переопределив WriteShellMsg,  вы можете настроить  сообщение
        для вывода другого текста.  Однако, чтобы избежать компоновки не-
        нужного кода,  вместо  процедуры  WriteLn  следует   использовать
        PrintStr. Следующий фрагмент программы выводит другое сообщение:

             procedure TShellApp.WriteShellMsg;
             begin
               PrintStr('Выход из Turbo Vision для DOS.');
               PrintStr('Для возврата нажмите Exit.');
             end;

                              Настройка строки состояния
        ─────────────────────────────────────────────────────────────────

             Используемый по умолчанию конструктор объекта приложения для
        инициализации и построения объекта строки состояния вызывает вир-
        туальный метод InitStatusLine.  Чтобы создать  специализированную
        строку состояния,  вам  нужно  переопределить  InitStatusLine для
        построения нового объекта строки состояния и присвоить  его  гло-
        бальной переменной StatusLine.  Строка состояния выполняет в при-
        ложении три важных функции:

             * Показывает команды,  на которых пользователь может щелкать
               "мышью".

             * Связывает с командами оперативные клавиши.

             * Обеспечивает  для пользователя контекстно-зависимую справ-
               ку.


         B.Pascal 7 & Objects/TV#1   - 222 -

             Первые две функции задаются,  когда вы строите объект строки
        состояния. С другой стороны,  контекстно-зависимая справка управ-
        ляется методом Hint объекта.

             Конструктор объекта строки состояния воспринимает два  пара-
        метра: прямоугольник  ее  границ  и указатель на связанный список
        определений состояния.  Определение состояния - это запись, кото-
        рая содержит  диапазон контекстно-зависимой справки и список кла-
        виш состояния,  которые строка состояния выводит при попадании  в
        этот диапазон справочного контекста приложения. Клавиши состояния
        - это записи,  которые содержат команды и текстовые строки и опе-
        ративные клавиши, которые генерируют эти команды.

             Построение строки состояния состоит из трех шагов:

             * Установки границ отображаемого элемента.

             * Задания определений состояния.

             * Определения клавиш состояния.

                         Определение границ строки состояния
        ─────────────────────────────────────────────────────────────────

             Строка состояния почти всегда выводится в нижней строке при-
        ложения, но вы можете поместить ее там, где хотите. Вы можете да-
        же сделать строку состояния невидимой,  так что  пользователь  не
        будет ее  видеть  и  не сможет щелкать на ней кнопкой "мыши",  но
        оперативные клавиши все равно будут связаны с командами.

             Простейший способ размещения строки состояния в нижней стро-
        ке экрана  состоит  в  привязке ее расположения к ограничивающему
        прямоугольнику объекта приложения. Это показано в следующем  при-
        мере:

             procedure TYourApplication.InitStatusLine;
             var R: TRect;
             begin
               GetExtent(R);       { получить границы приложения }
               R.A.T := R.B.Y - 1; { задать верх на одну строку выше
                                     нижней границы }
                      .
                      .
                      .             { использовать R как ограничивающий
                                      прямоугольник строки состояния }
             end;

                       Использование невидимых строк состояния
        ─────────────────────────────────────────────────────────────────

             Чтобы использовать невидимый объект строки состояния, вы мо-
        жете либо назначить прямоугольник границ вне экрана (например, на
        одну строку ниже нижней границы приложения)  или  пустой  прямоу-

         B.Pascal 7 & Objects/TV#1   - 223 -

        гольник. Например,  если вы измените в предыдущем примере присва-
        ивание на следующее:

             R.A.Y := R.B.Y;

        то строка состояния не будет иметь высоты,  и,  следовательно, не
        появится на  экране.  Убедитесь,  что границы объекта оперативной
        области охватывают ту область,  которую  обычно  занимает  строка
        состояния.

                            Создание определений состояния
        ─────────────────────────────────────────────────────────────────

             Записи определений  состояния  создаются  обычно  с  помощью
        функции NewStatusDef, которая облегчает создание связанного спис-
        ка записей путем  вложенных  вызовов  NewStatusDef.  NewStatusDef
        воспринимает четыре параметра:

             - нижнюю границу диапазона справочного контекста;

             - верхнюю границу диапазона справочного контекста;

             - указатель на связанный список клавиш состояния;

             - указатель  на следующую запись определения состояния (если
               она имеется).

             Используемый по умолчанию объект строки состояния, создавае-
        мый методом InitStatusLine объекта TProgram,  очень прост. Он со-
        держит  только одно определение состояния,  которое получает свой
        список клавиш состояния от функции StandardStatusKeys:

             procedure TProgram.InitStatusLine;
             var R: TRect;
             begin
               GetExtent(R);        { получить границы приложения }
               R.A.Y := R.B.T - 1;  { использовать только нижнюю строку }
               New(StatusLine, Init(R,
                                    { построить StatusLine с помощью R }
                 NewStatusLineDef(0, $FFFF,
                          { охватить все возможные справочные контексты }
                 NewStatusKey('~Alt+X~ Exit', kbAltX, cmQuit,
                                    { вывести Alt+X }
                 StdStatusKeys(nil)), nil))); { включить стандартные
                                      клавиши }
             end;

             Для простых  приложений  вероятно  достаточно   единственной
        строки состояния для всех справочных контекстов. Если ваше прило-
        жение содержит другие отображаемые элементы, которые могут потре-
        бовать доступности  в  строке состояния других команд,  вы можете
        обеспечить их, задав для этих отображаемых элементов другой спра-
        вочный контекст и создав для каждого из них соответствующие опре-

         B.Pascal 7 & Objects/TV#1   - 224 -

        деления состояния.
             Простая программа в следующем  примере  (которую  вы  можете
        найти не  дистрибутивных  дисках в файле TWOSTAT.PAS) показывает,
        как можно изменить строки состояния, изменяя справочный контекст:

             program TwoStat;
             uses Object, Drivers, Views, App, Menus;
             type
               TStatApp = object(TApplication);
                   constructor Init;
                   procedure InitStatusLine; virtual;
              end;
             constructor TStatApp.Init;
             var
               R: TRect;
               Window: PWindow;
             begin
               inherited Init;
               Desktop^.GetExtent(R);
               R.B.X := R.B.X div 2;
               Window := New(PWindow, Init(R, 'Окно A', 1));
               InsertWindow(Window);
               Desktop^.GetExtent(R);
               R.A.X := R.B.X div 2;
               Window := New(PWindow, Init(R, 'Окно B', 2));
               Window^.HelpCtx := $8000;
               InsertWindow(Window);
             end;
             procedure TStatusApp.InitStatusLine;
             var R: TRect;
             begin
               GetExtent(R);
               R.A.Y := R.B.Y - 1;
               New(StatusLine, Init(R,
                   NewStatusDef(0, $7FFF,
                     NewStatusKey('~F6~ Go to B', kbF6, cmNext,
                     StdStatusKeys(nil)),
                   NewStatusDef(0, $FFFF,
                     NewStatusKey('~F6~ Go to A', kbF6, cmNext,
                     StdStatusKeys(nil)),
             end;
             var StatApp: TStatApp;
             begin
               StatApp.Init:
               StatApp.Run;
               StatApp.Done;
             end.

                              Создание клавиш состояния
        ─────────────────────────────────────────────────────────────────
             После задания  определений для каждого из них требуется спи-

         B.Pascal 7 & Objects/TV#1   - 225 -

        сок клавиш состояния. Запись клавиши состояния состоит из четырех
        полей:

             - текстовой строки, которая выводится в строке состояния;
             - кода опроса клавиатуры для оперативной клавиши;
             - генерируемой команды;
             - указателя  на следующую запись клавиши состояния (если она
               имеется).

                          Использование функции NewStatusKey
        ─────────────────────────────────────────────────────────────────

             Простейший способ создания списка клавиш состояния состоит в
        том, чтобы сделать вызовы функции NewStatusKey вложенными. Созда-
        ние простого  одноэлементного списка клавиш состояния требует од-
        ного вызова вида:

             NewStatusKey('~Alt+Q~ Quit', bkAltQ, cmQuit, nil);

             Чтобы создать более длинный список,  замените nil другим вы-
        зовом NewStatusKey:

             NewStatusKey('~Alt+Q~ Quit', bkAltQ, cmQuit
             NewStatusKey('~F10~ Menu', bkF10, cmMenu, nil);

                        Использование функций клавиш состояния
        ─────────────────────────────────────────────────────────────────

             Если вы  в  нескольких различных определения состояния или в
        нескольких приложения используете один и тот же набор клавиш сос-
        тояния, то вы, вероятно, захотите сгруппировать их вместе в функ-
        цию. Модуль App  предусматривает  одну  такую  функцию  с  именем
        StdStatusKeys для  общих  наиболее  часто используемых команд.  В
        следующем примере показано описание StdStatusKeys:

             function StdStatusKeys(Next: PStatusItem): PStatusItem;
             begin
               StdStatusKeys :=
                   NewStatusKey('', kbAltX, cmQuit,
                   NewStatusKey('', kbF10, cmMenu,
                   NewStatusKey('', kbAltF3, cmClose,
                   NewStatusKey('', kbF5, cmZoom,
                   NewStatusKey('', kbCtrlF5, cmResize,
                   NewStatusKey('', kbF6, cmNext,
                   Next))))));
             end;

         B.Pascal 7 & Objects/TV#1   - 226 -

             Заметим, что предусматривая указатель на следующий  элемент,
        вы можете  использовать такую функцию как StdStatusKey в середине
        списка клавиш, а не в конце.

                 Добавление справочной информации в строку состояния
        ─────────────────────────────────────────────────────────────────

             Объект строк  состояния  предусматривает  виртуальный  метод
        Hint, который вы можете переопределить для обеспечения  в  строке
        состояния контекстно-зависимой  информации  справа  от  выводимых
        клавиш состояния.  Hint воспринимает в качестве единственного па-
        раметра номер  справочного контекста и возвращает по этому номеру
        строку. По умолчанию наследуемый из TStatusLine метод Hint  возв-
        ращает для любого ввода нулевую строку, поэтому для получения ос-
        мысленных сообщений вам нужно переопределить Hint.

             program Hinter;
             uses Objects, Drivers, Menus, Views, App;

             const
               hcFile = 1001; hcFileNew = 1002; hcFileOpen = 1003;
               hcFileExit = 1004; hcTest = 1005; hcWindow = 1100;
               cmFileNew = 98; cmFileOpen = 99;

             type
               PHintStatusLine = ^THintStatusLine;
               THintStatusLine = object(TStatusLine)
                 function Hint(AHelpCtx: Word): String; virtual;
             end;
             THintpp = object(TApplication)
               constructor Init;
               procedure InitMenuBar; virtual;
               procedure InitStatusLine; virtual;
             end;

             function THintStatusLine.Hint(AHelpCtx: Word): String;
             begin
               case AHelpCtx of
                  hcFile: Hint := 'Это меню File';
                  hcFileNew: Hint := 'Создание нового файла';
                  hcFileOpen: Hint := 'Открытие существующего файла';
                  hcFileExit: Hint := 'Завершение приложения';
                  hcText: Hint = 'Это тест, всего лишь тест.';
                  hcWindow: Hint := 'Это окно';
               else Hint := '';
               end;
             end;

             constructor THintApp.Init;
             var
               R: TRect;
               Windows: PWindow;
             begin

         B.Pascal 7 & Objects/TV#1   - 227 -

               inherited Init;
               Desktop^.GetExtent(R);
               Window := New(PWindow, Init(R, 'Окно', wnNoNumber));
               Window^.HelpCtx := hcWindow;
               InsertWindow(Window);
             end;

             procedure THintApp.InitMenuBar;
             var R: TRect;
             begin
               GetExtent(R); R.B.Y := R.A.Y + 1;
               MenuBar := New(PMenuBar, Init(R, NewMenu(
                  NewSubMenu('~F~ile', hcFile, NewMenu(
                    NewItem('~N~ew', '', kbNoKey, cmFileNew, hcFileNew,
                    NewItem('~O~pen...', 'F3', kbF3, cmFileOpen,
                            hcFileOpen,
                    NewLine(
                    NewItem('E~x~it', 'Alt+X', kbAltX, cmQuit,
                            hcFileExit,
                    nil))))),
                  NewItem('~T~est', '', kbNoKey, cmMenu, hcTest,
                    nil)))));
             end;

             procedure THintApp.InitStatusLine;
             var R: TRect;
             begin
               GetExtent(R); R.A.Y := R.B.Y - 1;
               StatusLine := New(PHintStatusLine, Init(R,
                 NewStatusDef(0, $FFFF, StandardStatusKeys(nil),
                              nil))));
             end;

             var HintApp: THintApp;
             begin
               HintApp.Init;
               HintApp.Run;
               HintApp.Done;
             end.

             В сложном  приложении,  которое  выводит множество различных
        справок, для задания строк вместо длинных операторов case в  Hint
        следует использовать списки строковых ресурсов.

                             Обновление строки состояния
        ─────────────────────────────────────────────────────────────────

             Вам никогда не следует изменять  строку  состояния  вручную.
        Метод Idle объекта приложения вызывает метод Update объекта стро-
        ки состояния, поэтому клавиши оперативной строки и справки никог-
        да не будут "устаревшими".


         B.Pascal 7 & Objects/TV#1   - 228 -

                                    Настройка меню
        ─────────────────────────────────────────────────────────────────

             Меню в Turbo Vision состоит из двух частей  -  списка  меню,
        который содержит  описание пунктов меню и генерируемые ими коман-
        ды, и отображаемый элемент меню,  который выводит эти элементы на
        экран.
             Turbo Vision  определяет два вида отображаемых элементов ме-
        ню: строки (полосы) меню и блоки меню.  Оба отображаемых элемента
        используют в своей основе один и тот же список пунктов меню. Фак-
        тически, одни и те же элементы меню можно выводить в виде  полосы
        меню, либо в виде блока.  Основное отличие в том, что полоса меню
        может представлять собой только меню верхнего уровня, обычно фик-
        сированно расположенное по верхней строке экрана приложения. Блок
        меню может быть основным меню (обычно всплывающим  или  локальным
        меню) или  более  часто подменю,  выводимое по пункту полосы меню
        или другого блока меню.

             Конструктор Init приложения для  построения  строки  меню  и
        присваивания ее  переменной  ManuBar вызывает виртуальный метод с
        именем MenuBar.  Чтобы определить свою собственную  строку  меню,
        вам нужно переопределить метод InitMenuBar для создания специаль-
        ной полосы меню и присвоить ее MenuBar.

             Создание меню предусматривает два шага:

             - задание границ полосы меню;
             - определение пунктов меню.

                              Задание границ полосы меню
        ─────────────────────────────────────────────────────────────────

             Полоса меню почти всегда занимает верхнюю строку экрана при-
        ложения. Наилучший способ размещение вашего меню в верхней строке
        состоит в  установке его границ на основе границ приложения.  Это
        показано в следующем примере:

             procedureTYourApplication.InitMenuBar;
             var R: TRect;
             begin
               GetExtent(R);              { получить границы приложения }
               R.B.Y := R.A.Y + 1;        { установить нижнюю строку }
                   .
                   .
                   .
             end;

             В отличие от полос меню блоки настраивают свои границы в со-
        ответствии с их содержимым,  поэтому вам не нужно беспокоиться об
        установке размеров каждого подменю.  Вам  следует  просто  задать
        границы полосы меню, а объекты меню позаботятся об остальном.

         B.Pascal 7 & Objects/TV#1   - 229 -

                               Определение пунктов меню
        ─────────────────────────────────────────────────────────────────

             Для определения структуры меню система меню  использует  два
        различных вида записей.  Каждый из типов записей предназначен для
        использования в связанном списке и имеет указатель  на  следующую
        запись.

             * TMenu определяет список пунктов меню и отслеживает исполь-
               зуемый по умолчанию (или выбранный) пункт. Каждое основное
               меню и подменю содержат одну запись TMenu.  Список пунктов
               меню - это связанный список записей TMenuItem.

             * TMenuItem определяет  текст,  оперативную клавишу, команду
               и справочный контекст пункта меню.  Каждый пункт меню (ко-
               манда или подменю) имеет собственную запись TMenuRecord.

             Когда меню выводится в виде строки,  строка оперативных кла-
        виш является скрытой, хотя оперативные клавиши действуют.

                            Использование функции NewItem
        ─────────────────────────────────────────────────────────────────

             Обычный способ распределения и инициализации записи  пунктов
        меню состоит в использовании функции NewItem. Путем вложенных вы-
        зовов MenuItem вы легко можете создать список пунктов.

                           Использование функции NewSubMenu
        ─────────────────────────────────────────────────────────────────

             Подменю - это элемент меню, который вместо генерации команды
        выводит другое меню.  Обычно меню создаются путем  вызова  вместо
        NewItem функции  NewSubMenu.  На  самом деле NewSubMenu и NewItem
        имеют только два отличия:

             * Подменю  не  имеет  связанной  с  ним   команды,   поэтому
               NewSubMenu устанавливает поле Command в ноль,  а оператив-
               ная клавиша не присваивается и не описывается.

             * Кроме указания на следующий элемент меню, подменю указыва-
               ет на запись TMenu, которая содержит список пунктов в под-
               меню.

                            Использование времени простоя
        ─────────────────────────────────────────────────────────────────

             В цикле  сообщения объекта приложения при отсутствии ожидаю-
        щих событий в очереди событий вызывается виртуальный метод с име-
        нем Idle.  Это означает, что при отсутствии ввода от пользователя
        вы можете использовать Turbo Vision для выполнения  фоновых  про-
        цессов.

             Чтобы создать фоновый процесс,  вам нужно просто переопреде-

         B.Pascal 7 & Objects/TV#1   - 230 -

        лить метод Idle и сделать так,  чтобы он выполнял некоторые зада-
        чи, которую  вы  хотите выполнять в фоновом режиме.  Не забудьте,
        однако, вызвать наследуемый метод Idle,  поскольку  по  умолчанию
        Idle выполняет  такие функции,  как обновление строки состояния и
        уведомление отображаемых элементов о  запрещении  или  разрешении
        команд.

             Нужно обеспечить,  чтобы любая фоновая обработка, помещаемая
        в методе Idle,  не занимает слишком много  времени,  в  противном
        случае  прикладная  программа  будет слишком медленно реагировать
        на действия пользователя.

             Программа TVDemo на ваших дистрибутивных  дисках  использует
        два отображаемых  элемента  из модуля Gadgets.  Один из них - это
        отображаемый элемент часов, который обновляет время с помощью ме-
        тода приложения  Idle.  Другой представляет собой указание объема
        доступной динамически распределяемой  памяти,  также  обновляемое
        методом Idle.

         B.Pascal 7 & Objects/TV#1   - 231 -

                           Контекстно-зависимый справочник
        ─────────────────────────────────────────────────────────────────

             В Turbo Vision имеются встроенные средства, которые способс-
        твуют  реализации  контекстной подсказки в вашей прикладной прог-
        рамме.  Вы можете присвоить отображаемому элементу номер контекс-
        тной подсказки,  и Turbo Vision гарантирует, что как только отоб-
        ражаемый элемент будет выделен, то номер его контекстной подсказ-
        ки станет номером текущей контекстной подсказки программы.

             Для создания глобальной системы контекстной подсказки вы мо-
        жете реализовать объект HelpView,  которому известны определенные
        вами  номера  контекстных  подсказок.  При  активизации  HelpView
        (обычно при нажатии пользователем клавиши F1 или другой оператив-
        ной  клавиши),  он попросит у владельца текущую контекстную подс-
        казку с помощью вызова метода GetHelpCtx.  После  этого  HelpView
        сможет считать и выдать на экран правильный текст подсказки. При-
        мер HelpView имеется на ваших дистрибутивных дисках Турбо  Паска-
        ля.

             Контекстная подсказка - это одна из последних функций, кото-
        рую вы  захотите  реализовать в вашей программе,  поэтому объекты
        Turbo Vision инициализируются с заданным по умолчанию  контекстом
        hcNoContext, который является предопределенным контекстом, не из-
        меняющим текущий контекст.  В свое время вы  сможете  разработать
        систему номеров подсказок,  затем вставить правильный номер в со-
        ответствующий отображаемый элемент с  помощью  вызова  SetHelpCtx
        сразу после создания отображаемого элемента.

             Контексты подсказки  используются  также  в строке состояния
        для определения отображаемых элементов для вывода на экран.  Пом-
        ните,  что при  создании  строки  состояния  вы  вызываете  метод
        NewStatusDef,  который  определяет  набор элементов состояния для
        заданного диапазона значений  контекста  подсказки.  Когда  новый
        отображаемый элемент становится выделенным, то контекст подсказки
        для этого элемента определяет, какая строка состояния изображает-
        ся на экране.

         B.Pascal 7 & Objects/TV#1   - 232 -

─────────────────────────────────────────────────────────────────────────
                       ГЛАВА 11. Объекты окон и диалоговых окон
        ─────────────────────────────────────────────────────────────────

             Объекты окон представляют собой специализированные групповые
        отображаемые элементы,  обеспечивающие ограниченные рамкой перек-
        рывающиеся окна с заголовками,  которые приложения  Turbo  Vision
        выводят в оперативной области.  Диалоговые окна - это специализи-
        рованные окна,  поэтому все описанное в данной главе и специфици-
        рующее  окна  в равной степени относится и к диалоговым окнам.  В
        этой главе описываются также свойства,  уникальные  для  объектов
        диалоговых окон.

             В данной главе описываются следующие темы:

             - принципы организации окон и диалоговых окон;

             - работа с окнами;

             - работа с диалоговыми окнами;

             - использование управляющих элементов с диалоговыми окнами;

             - использование стандартных диалоговых окон.

                               Принципы построения окон
        ─────────────────────────────────────────────────────────────────

             Окна в Turbo Vision отличаются от окон в других системах,  с
        которыми вы,  возможно, работали. Вместо того, чтобы быть подмно-
        жеством экрана,  с которым вы можете выполнять операции чтения  и
        записи, окно Turbo Vision представляет собой групповой отображае-
        мый элемент.  Это различие поясняется,  если рассмотреть простого
        потомка окна - диалоговое окно.

             На Рис.  11.1 показано типичное диалоговое окно, которое со-
        держит различные управляющие элементы. Если посмотреть на это ди-
        алоговое окно,  то станет совершенно ясно, что пользователь взаи-
        модействует с ним путем набора в  строке  ввода,  щелчка  кнопкой
        "мыши"  на командных кнопках и т.д.  Пользователь не предполагает
        возможности набора данных в фоновых областях.


         B.Pascal 7 & Objects/TV#1   - 233 -


        ╔═[]══════════════════════════Directories══════════════════════╗
        ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
        ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
        ║▒▒EXE & TPU directories▒▒████████████████████████████████████▒▒║
        ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
        ║▒▒Include directories▒▒▒▒████████████████████████████████████▒▒║
        ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
        ║▒▒Unit directories▒▒▒▒▒▒▒█c:\tp;c\tp\tvision;c:\tp\tvdemo████▒▒║
        ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
        ║▒▒Object directories▒▒▒▒▒█c:\tp;c:tp\tvision█████████████████▒▒║
        ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
        ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
        ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████OK████▒▒▒▒▒██Cancel██▒▒▒▒███Help████▒▒▒▒▒▒║
        ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒║
        ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒║
        ╚═══════════════════════════════════════════════════════════════╝

             Рис. 11.1 Типичное диалоговое окно.

             В этом отношении диалоговое окно не  отличается  от  другого
        окна Turbo  Vision.  Это не только область,  куда вы записывается
        данные, но и то,  что содержит другие отображаемые элементы. Если
        вы хотите  вывести  в  окне текст,  то включаете в окно текстовый
        отображаемый элемент.

                        Чем отличаются окна и диалоговые окна
        ─────────────────────────────────────────────────────────────────

             В большинстве случаев объекты окон и диалоговых окон взаимо-
        заменяемы. Однако диалоговые окна имеют несколько  дополнительных
        обновлений, которые  делают их особенно полезными при использова-
        нии в качестве режимных отображаемых элементов.  Если вы помните,
        режимным может быть любой групповой отображаемый элемент, включая
        окна, диалоговые окна и приложения. Однако, диалоговые окна вклю-
        чают в  себя некоторые элементы,  которые пользователи ожидают от
        режимных отображаемых элементов.

             Объекты диалоговых окон обрабатывают события  несколько  от-
        лично от диалоговых окон. Они делают следующее:

             - преобразуют нажатия клавиши Esc в команды cmCancel;

             - преобразуют нажатия клавиши Enter в оповещения cmDefault;

             - в  ответ  на стандартные команды cmOK,  cmCancel,  cmYes и
               cmNo закрывают диалоговое окно (завершая режимное  состоя-
               ния).



         B.Pascal 7 & Objects/TV#1   - 234 -

                                   Работа с окнами
        ─────────────────────────────────────────────────────────────────

             В данном разделе описывают различные задачи,  которые вы мо-
        жете выполнять над всеми объектами окон, включая диалоговые окна:

             - построение оконных объектов;

             - включение окон в оперативную область;

             - работа с режимными окнами;

             - изменение используемых по умолчанию параметров окон;

             - управление размером окон;

             - создание полос прокрутки окна.

                             Построение оконных объектов
        ─────────────────────────────────────────────────────────────────

             Оконные объекты обеспечивают определенную гибкость, позволя-
        ющую вам  настроить их поведение без необходимости создания новых
        производных оконных типов.

             Данных раздел освещает следующие темы:

             * Построение используемого по умолчанию объекта окна.

             * Изменение флагов окна.



         B.Pascal 7 & Objects/TV#1   - 235 -

                      Построение используемых по умолчанию окон
        ─────────────────────────────────────────────────────────────────

             Конструктор используемого   по  умолчанию  оконного  объекта
        воспринимает три параметра:  ограничивающий прямоугольник, строку
        заголовка и  номер  окна.  Используемое по умолчанию окно создает
        групповой отображаемый элемент с заданными границами,  устанавли-
        вает его  поле  заголовка для указания на копию строки заголовка,
        сохраняет номер окна и устанавливает состояние флагов параметров,
        чтобы задать тень окна или сделать его выбираемым.

             После вызова  конструктора окна вы можете модифицировать лю-
        бое из его полей,  как и в случае любого другого объекта.  Напри-
        мер, чтобы  окно  центрировалось  при включении его в оперативную
        область, установите в его поле Options флаг ofCentered:
                 .
                 .
             Window := New(PWindow, Init(R, 'Заголовок окна',
                           wmNoNumber));
             Window^.Options := Window^.Options or ofCentered;
             Application^.InsertWindow(Window);
                 .
                 .

                                Изменение флагов окна
        ─────────────────────────────────────────────────────────────────

              Кроме флагов параметров стандартного отображаемого элемента

         B.Pascal 7 & Objects/TV#1   - 236 -

        оконные объекты  имеют битовое поле Flags,  которое управляет от-
        дельными видами поведения при перемещении  и  изменении  размера.
        Биты в поле флагов окна идентифицируются константами,  начинающи-
        мися с wf. Назначение каждого из этих флагов описывается в следу-
        ющей таблице:

                              Действие флагов окна           Таблица 11.1
        ┌──────────────┬────────────────────────────────────────────────┐
        │   Флаг       │                 Смысл                          │
        ├──────────────┼────────────────────────────────────────────────┤
        │   wfMove     │ Пользователь может перемещать окно путем букси-│
        │              │ ровки его заголовка.                           │
        ├──────────────┼────────────────────────────────────────────────┤
        │   wfGrow     │ Пользователь может изменять размер  окна  путем│
        │              │ буксировки нижнего правого угла.               │
        ├──────────────┼────────────────────────────────────────────────┤
        │   wfClose    │ Пользователь может закрывать окно, щелкая кноп-│
        │              │ кой "мыши" в верхнем левом углу.               │
        ├──────────────┼────────────────────────────────────────────────┤
        │   wfZoom     │ Пользователь может распахивать окно или возвра-│
        │              │ щать его к прежнему размеру, щелкая  кнопкой  в│
        │              │ правом верхнем углу.                           │
        └──────────────┴────────────────────────────────────────────────┘

             По умолчанию для окон устанавливаются все четыре флага.

                         Включение окон в оперативную область
        ─────────────────────────────────────────────────────────────────

             Окна обычно включаются в группу оперативной области приложе-
        ния, так  как  вы обычно хотите,  чтобы окно выводилось в области
        между строкой меню и строкой состояния без их перекрытия. Включе-
        ние в  оперативную область обеспечивает отсечение окон на границе
        оперативной области.

             Лучшим способов включение окна в оперативную область являет-
        ся вызов    метода   InsertWindow   объекта   приложения.   Метод
        InsertWindow выполняет над объектом окна перед его включением две
        проверки допустимости. Этим обеспечивается, что при включении ок-
        на пользователь сможет его использовать.

                   Примечание: О   проверке    надежности,    выполняемой
              InsertWindow,  рассказывается  в Главе 10 "Объекты приложе-
              ния".

             InsertWindow - это функция.  Она возвращает указатель на ок-
        но, передаваемый в качестве параметра, если окно было допустимым,
        или nil, если окно допустимым не было. Если окно не было допусти-
        мым, InsertWindow уничтожает его,  так что вам не требуется снова
        обращаться к указателю.  Фактически, во многих случаях вам, веро-
        ятно, даже    не   потребуется   результат   функции.   Поскольку

         B.Pascal 7 & Objects/TV#1   - 237 -

        InsertWindow полностью берет на себя проверку допустимости  окон,
        вы можете  использовать преимущества расширенного синтаксиса (ди-
        рективу компилятора $X+) для интерпретации InsertWindow как  про-
        цедуры.

             Следующая программа    показывает   типичное   использование
        InsertWindow как  процедуры.  Эту  же  программу  содержит   файл
        INSWIN.PAS на дистрибутивных дисках.

             procedure InsWin;
             uses Objects, App, Drivers, Views, Menus;

             const cmNewWin = 2000;

             type
               TInsApp = object(TApplication)
                 WinCount: Integer;
                 procedure HandleEvent(var Event: TEvent); virtual;
                 procedure InitMenuBar; virtual;
               end;

             procedure TInsApp.HandleEvent(var Event: TEvent);
             var R: TRect;
             begin
               inherited HandleEvent(Event);
               if Event.What = evCommand then
               begin
                 if Event.Command = cmNewWin then
                 begin
                   Inc(WinCount);
                   Desktop^.GetExtent(R);
                   InsertWindow(New(PWindow, Init(R, 'Test window',
                                WinCount)));
                end;
              end;
             end;

             procedure TInsApp.InitMenuBar;
             var R: TRect;
             begin
               GetExtent(R);
               R.B.Y := R.A.Y + 1;
               MenuBar := New(PMenuBar, Init(R, NewMenu(
                    NewItem('~A~dd window', 'F3', kbF3, cmNewWin,
                             hcNoContext, nil)))));
             end;

             var InsApp: TInsApp;
             begin
               InsApp.Init;
               InsApp.Run;
               InsApp.Done;
             end.

         B.Pascal 7 & Objects/TV#1   - 238 -


                               Выполнение режимных окон
        ─────────────────────────────────────────────────────────────────

             Выполнение режимного окна аналогично включению окна в опера-
        тивную область.  Существуют два исключение: это то, что окно ста-
        новится текущим  режимным окном приложения и то, что вы передаете
        для инициализации его управляющих элементов запись данных.

             Использование режимных окон требует от вас понимание следую-
        щих трех задач:

             - перевода окна в режимное состояние;
             - завершение режимного состояния;
             - обработка записи данных.

                          Перевод окна в режимное состояние
        ─────────────────────────────────────────────────────────────────

             Выполнить режимное окно очень просто. После построения окон-
        ного объекта   вы   передаете   его   методу  объекта  приложения
        ExecuteDialog. Как   и   подразумевает   его   название,    метод
        ExecuteDialog используется обычно с диалоговыми окнами, но вы мо-
        жете выполнять любой оконный объект.

             Метод ExecuteDialog воспринимает два параметра  -  указатель
        на объект окна и указатель на запись данных для инициализации уп-
        равляющих элементов окна (как описывается в  следующем  разделе).
        Приведем простой пример использования ExecuteDialog:

             MyWindow := New(PWindow, Init(R, 'Будет режимным',
                                           wmNoNumber));
             ExecuteDialog(MyWindow, nil);

             Передача значения  nil  в  качестве  указателя записи данных
        позволяет обойти автоматическую установку и  считывание  значений
        управляющих элементов.

                            Завершение режимного состояния
        ─────────────────────────────────────────────────────────────────

             На самом деле единственная тонкость при работе с диалоговыми
        окнами заключается в том, чтобы убедиться, что вы обеспечили спо-
        соб завершения режимного состояния. Все оконные объекты наследуют
        ют от TGroup метод EndModal,  но вы должны  убедиться,  что  ваши
        объекты  в  ответ на некоторые события или событие вызывают метод
        EndModal.  Объекты диалоговых  окон  обладают  этой  возможностью
        построения  методов  HandleEvent по умолчанию,  но если вы хотите
        выполнять другие диалоговые объекты,  то должны добавить это  са-
        мостоятельно.


         B.Pascal 7 & Objects/TV#1   - 239 -

                               Обработка записей данных
        ─────────────────────────────────────────────────────────────────

             ExecuteDialog автоматически  поддерживает установку и считы-
        вание управляющих    элементов    окна.    Второй    передаваемый
        ExecuteDialog параметр указывает на запись данных для управляющих
        элементов окна. Запись данных поясняется ниже в разделе "Работа с
        управляющими элементами".

             После выполнения  окна  ExecuteDialog  вызывает  метод  окна
        SetData, передавая запись данных, на которую указывает второй па-
        раметр. Когда  пользователь завершает режимное состояние окна без
        отмены (другими словами,  вызывает EndModal с командой,  отличной
        от cmCancel),  ExecuteDialog вызывает GetData для считывания зна-
        чений управляющих элементов обратно в запись данных.

                   Изменение параметров окна, заданных по умолчанию
        ─────────────────────────────────────────────────────────────────

             После построения объектов окна существует несколько аспектов
        его внешнего вида и поведения, которое вы можете изменить. В этом
        разделе поясняются следующие вопросы:

             - использование стандартных палитр окна;
             - изменение заголовка окна;
             - изменение рамки окна;
             - использование номеров окон.

                        Использование стандартных палитр окна
        ─────────────────────────────────────────────────────────────────

             Turbo Vision использует для оконных объектов три стандартных
        цветовых схемы.  Используемой по умолчанию схемой цветов является
        голубое окно с белой рамкой,  желтым текстом, зелеными пиктограм-
        мами рамки и бирюзовыми полосами прокрутки.  Альтернативные схемы
        цветов используются для серых окон (по умолчанию используется ди-
        алоговыми окнами)  и  бирюзовых  окон (которые в IDE используются
        для сообщений и окон просмотра).

             Схема цветов  для  данного  окна  управляется  полем Palette
        оконного объекта.  По умолчанию конструктор объекта окна устанав-
        ливает Palette в wpBlueWindow.  Чтобы изменить одну из других па-
        литр,  установите Palette в wpCyanWindow или wpGrayWindow.  Метод
        GetColor объекта окна использует значение Palette для определения
        отображения цветов в палитру объекта приложения.

                   Примечание: Полностью  об отображении цветов рассказы-
              вается в Главе 14 "Палитры и выбор цветов".

             Конструктор в приведенном ниже примере создает окно, которое

         B.Pascal 7 & Objects/TV#1   - 240 -

        использует бирюзовую палитру окна:

             constructor TCyanWindow.Init(var Bounds: TRect; ATitle:
                                          TTitleStr; ANumber: Integer);
             begin
               inherited Init(Bounds, ATitle, ANumber);  { используемое
                                                      по умолчанию окно }
               Palette := wpCyanWindow;        { изменение палитры окна }
             end;

                               Изменение заголовка окна
        ─────────────────────────────────────────────────────────────────

             Объект окна сохраняет строку заголовка, переданную его конс-
        труктору, в  поле Title.  Однако в общем случае вам следует обра-
        щаться к строке заголовка с помощью метода GetTitle объекта окна,
        который предоставляет  возможность  ограничить длину строки заго-
        ловка. В общем случае единственной частью программы, где требует-
        ся доступ к заголовку окна,  является рамка объекта окна, которая
        вызывает метод GetTitle при своем отображении.

             GetTitle воспринимает единственный параметр целого типа, ко-
        торый вы  можете  использовать для ограничения длины возвращаемой
        строки. По умолчанию GetTitle игнорирует параметр длины и возвра-
        щает всю строку Title, которую в случае превышения заданной длины
        рамка затем усекает.  Во многих случаях  не  важно,  какая  часть
        строки усекается.  Однако,  если вы хотите сохранить определенную
        информацию, то можете переопределить метод GetTitle для  возврата
        строки соответствующей длины, которая содержит важную информацию.

             Вы можете  также  использовать  метод  GetTitle для возврата
        различных заголовков в зависимости  от  обстоятельств.  Например,
        тип TEditWindow обычно выводит на экран полное имя маршрута файла
        в редакторе.  Если файл еще не имеет имени,  GetTitle  возвращает
        вместо этого строку 'Untitled'.

                                 Изменение рамки окна
        ─────────────────────────────────────────────────────────────────

             По умолчанию объект окна строит экземпляр типа  TFrame,  ис-
        пользуя его в качестве его рамки. Объекты рамки очень просты, и у
        вас редко возникает  необходимость  изменять  их.  Однако,  Turbo
        Vision облегчает изменение рамки окна, если вы этого хотите.

             По умолчанию  конструктор  объекта  окна  Init  вызывает для
        построения объекта рамки виртуальный метод InitFrame и присваива-
        ет этот объект полю Frame объекта.  После вызова InitFrame  конс-
        труктор Init проверяет,  что поле Frame отлично от nil,  и,  если
        может, включает его.

             Чтобы построить  другую рамку,  переопределите InitFrame для
        построения экземпляра некоторого типа,  производного от TFrame, и
        присваивает этот  объект  Frame.  Затем  Init будет включать вашу

         B.Pascal 7 & Objects/TV#1   - 241 -

        производную рамку в окно.

                              Использование номеров окон
        ─────────────────────────────────────────────────────────────────
             Последний параметр,  передаваемый используемому по умолчанию
        конструктору окна,  это номер,  который окно  записывает  в  поле
        Number. Если  число  находится между 1 и 9,  то число выводится в
        рамке окна справа от заголовка рядом с пиктограммой распахивания.
        По умолчанию нажатие клавиш Alt+1 по Alt+9 выбирает (активизирует
        и выводит на передний план) окна с соответствующим номером.

             Turbo Vision предусматривает механизм для отслеживания того,
        какие номера вы присвоили и какие из них доступны. Если вы хотите
        использовать преимущества работы с номерами окон, ваше приложение
        само должно поддерживать номера. Turbo Vision только обрабатывает
        присваивание передаваемых номеров полю Number  и  выбирает  окна,
        выделенные по клавише Alt.

             Turbo Vision  также  предусматривает мнемонические константы
        wmNoNumbner, которые вы можете  передать  конструктору  окна  для
        указания того, какое окно имеет конкретный номер.

                               Управление размером окна
        ─────────────────────────────────────────────────────────────────
             По умолчанию пользователи могут изменять размеры окон  путем
        буксировки нижнего  правого  угла в нужную позицию и распахивания
        окна для заполнения оперативной области путем щелчка кнопкой "мы-
        ши" на пиктограмме окна. Tubo Vision дает вам средство управления
        обоими этими аспектами поведения,  что позволяет вам ограничивать
        размер окон и задавать для окон "нераспахиваемый" размер.

                               Ограничение размера окна
        ─────────────────────────────────────────────────────────────────
             Как и для всех отображаемых элементов,  минимальный и макси-
        мальный размеры окна определяются виртуальным методом SizeLimits.
        Однако TWindow  вносит  в  SizeLimits  одно важное изменение.  По
        умолчанию минимальный  размер  отображаемого  элемента  равен  0.
        TWindow переопределяет это и устанавливает минимальный размер ок-
        на в значение, записанное в переменной MinWinSize.

             По умолчанию  MinWinSize ограничивает окно минимум 16 столб-
        цами (ширина) и 6 строками (высота),  что обеспечивает вывод угла
        изменения размера,  пиктограммы закрытия,  пиктограммы распахива-
        ния, плюс некоторая часть  заголовка.  Вы  можете  переопределить
        SizeLimits для специальных типов окон, например, обеспечить вывод
        в них полос прокрутки в рамке.

                                  Распахивание окон
        ─────────────────────────────────────────────────────────────────
             Каждый объект  окна  имеет  виртуальный метод с именем Zoom,

         B.Pascal 7 & Objects/TV#1   - 242 -

        который переключает размер окна между полным  заполнением  опера-
        тивной области (распахивание) и возвратом к прежнему размеру, за-
        данному полем объекта окна ZoomRect.  ZoomRect первоначально  со-
        держит границы окна при его построении. Когда вы распахиваете ок-
        но для заполнения оперативной области,  в  ZoomRect  записывается
        новый размер окна, который оно имело до распахивания.

             Если вы  хотите изменить для конкретного типа окна поведение
        при распахивании (например,  чтобы при отмене распахивания всегда
        устанавливать конкретный размер),  то можете переопределить Zoom.
        Вероятно, вы не захотите  вызывать  метод  Zoom,  наследуемый  из
        TWindow в методах потомках, так как если окно не заполняет опера-
        тивную область,  TWindow.Zoom устанавливает  значение ZommRect  в
        новый размер окна.

                            Создание полос прокрутки окна
        ─────────────────────────────────────────────────────────────────

             Объектный тип TWindow предоставляет  функцию  для  генерации
        полос прокрутки окна.  Если у вас есть окна,  в которых требуется
        прокручивать все содержимое, вызов метода StandardScrollBar стро-
        ит, включает  объект  полосы  прокрутки в рамке окна и возвращает
        указатель на него.

             StandardScrollBar воспринимает единственный параметр, задаю-
        щий нужный   вам   вид   полосы   прокрутки.  Если  вы  передаете
        sbVertical, то метод возвращает вертикальную полосу  прокрутки  с
        левой стороны рамки окна. Передача sbHorizontal дает горизонталь-
        ную полосу прокрутки в нижней части рамки окна.

             Чтобы полученная в результате полоса прокрутки  могла  кроме
        нажатия кнопки  "мыши"  реагировать на клавиши стрелок и перевода
        страницы,  вы может комбинировать sbHandleKeyboard  с  sbVertical
        или sbHorizontal (с помощью операции or).

             В следующем     примере    конструктор    окна    использует
        StandardScrollBar для  создания  полос  прокрутки  для  прокрутки
        внутренней области,  заполняющей окно.  Заметим, что вам не нужно
        включать полосы прокрутки окна, как это обычно делается.

             constructor TScrollWindow.Init(Var Bounds: TRect; ATitle:
                                            TTitleStr; ANumber: Integer);
             var

               R: TRect;
               Interior: PScroller;
             begin
               inherited Init(Bounds, ATitle, ANumbner);
                                                     { построение окна }
               GetExtent(R);                   { получить границы окна }
               R.Grow(-1, -1);                   { сжать прямоугольник }
               Interior := New(PScroller, Init(R),

         B.Pascal 7 & Objects/TV#1   - 243 -

                                     { построить в R элемент прокрутки }
                  StandardScrollBar(sbHorizontal or sbHandleKeyboard),
                  StandardScrollBar(sbVertical or sbHandleKeyboard));
                Insert(Interior);
             end;

                             Работа с диалоговыми окнами
        ─────────────────────────────────────────────────────────────────

             Диалоговые окна могут делать все то, что делает любой другой
        объекта окна. Основное отличие между объектами диалогового окна и
        объектом окна  состоит  в том,  что объект диалогового окна имеет
        различные используемые по умолчанию атрибуты, встроенную поддерж-
        ку для режимных операций и приспособлены для работы с диалоговыми
        объектами. В данном разделе описываются атрибуты диалогового окна
        и режимные операции. Использование управляющих элементов описыва-
        ется ниже в соответствующих разделах.

                 Используемые по умолчанию атрибуты диалогового окна
        ─────────────────────────────────────────────────────────────────

             Назначенные по  умолчанию  свойства объекта диалогового окна
        только слегка отличаются от других оконных объектов.  Конструктор
        диалогового окна  воспринимают  вместо трех только два параметра,
        поскольку диалоговые окна по умолчанию не имеют номера окна.

             Между используемыми по умолчанию объектами диалоговых окон и
        оконными объектами существуют следующие отличия:

             - Серая схема цвета (Palette равно wpGrayWindow).

             - Отсутствие номера окна.

             - Фиксированный размер, поэтому GrowMode равно нулю, а Flags
               исключает wfGrow и wfZoom.

             Эти отличия влияют на диалоговые окна,  когда вы используете
        их как режимные или безрежимные окна или выполняете их как режим-
        ные диалоговые окна.

                         Поведение режимного диалогового окна
        ─────────────────────────────────────────────────────────────────

             Объекты диалоговых  окон имеют два метода,  которые упрощают
        их использование как режимных отображаемых элементов.  Это методы
        HandleEvent и Valid.

                          Обработка событий диалогового окна
        ─────────────────────────────────────────────────────────────────

             Объекты диалоговых  окон  обрабатывают  большинство  событий
        аналогично другим оконным объектам, но вносите два изменения, ко-
        торые вы заметите при использовании диалогового окна  в  качестве

         B.Pascal 7 & Objects/TV#1   - 244 -

        режимного отображаемого элемента:

             * Клавиши Enter и Esc обрабатываются особым образом.

               По клавише   Enter   рассылается   оповещающее   сообщение
               cmDefault,  что приводит в действие командную кнопку  (как
               при ее "нажатии"). Esc транслируется в команду cmCancel.

             * Отдельные команды автоматически завершают режимное состоя-
               ние.

               Команды cmOk,  cmCancel,  cmYew и cmNo приводят  к  вызову
               EndModal (команда передается в качестве параметра).

                Использование в диалоговом окне управляющих элементов
        ─────────────────────────────────────────────────────────────────

             Обычно диалоговые окна используются как место для  включения
        управляющих элементов.  Управляющие  элементы  представляют собой
        специализированные отображаемые элементы,  которые позволяют реа-
        лизовать такие  виды взаимодействия с пользователем как командные
        кнопки, блоки списка и полосы прокрутки.  Хотя вы можете включать
        управляющие элементы  в  объект окна,  диалоговые окна специально
        приспособлены для работы с ними.

                  Добавление в диалоговое окно управляющих элементов
        ─────────────────────────────────────────────────────────────────

             Добавление в  окно управляющих элементов аналогично добавле-
        нию любых других отображаемых подэлементов.  Обычно эта  операция
        является частью  конструктора  окна.  После  вызова  наследуемого
        конструктора окна вы можете построить и включить другие управляю-
        щие объекты. Это показано в следующем примере:

             constructor TCtlWindow.Init(var Bounds: TRect;
                                    ATitle: TTitleStr; ANumber: Integer);
             var R: TRect;
             begin
               inherited Init(Bounds, ATitle, ANumber);
                                                     { построение окна }
               R.Assign(5, 5, 20, 7);
               Insert(New(PInputLine, Init(R, 15)));
                                     { включение управляющего элемента }
               R.Assign(10, 8, 20, 10);
               Insert(New(PButton, Init(R, 'O~k~', cmOk, bfDefault)));
                                                    { командная кнопка }
             end;

             Вы должны представлять тот порядок,  в котором включаете уп-
        равляющие элементы.  Порядок  включения  (вставки)  устанавливает
        Z-последовательность отображаемых элементов, которые, в свою оче-
        редь, определяют порядок табуляции для управляющих элементов. По-
        рядок табуляции - это порядок, в котором управляющие элементы по-

         B.Pascal 7 & Objects/TV#1   - 245 -

        лучают фокус (становятся выделенными) при  нажатии  пользователем
        клавиши Tab.

             Порядок табуляции имеет важное значение,  поскольку он опре-
        деляет:

             - порядок взаимодействия с пользователем;

             - порядок инициализации управляющих элементов.

                     Как пользователи наблюдают порядок табуляции
        ─────────────────────────────────────────────────────────────────

             Хорошим примером того,  как порядок табуляции представляется
        пользователям, является формуляр ввода данных. Когда пользователь
        заканчивает ввод в одном поле и нажимает клавишу Tab для перехода
        к следующему полю,  фокус должен перемещаться на следующий  логи-
        ческий управляющий  элемент.  Если  программист неаккуратно задал
        порядок полей ввода данных, это раздражает пользователей и делает
        их работу менее продуктивной.

             Общепринятых правил,  управляющих порядком управляющих  эле-
        ментов в диалоговом окне, нет, но в общем неплохо иметь такой по-
        рядок. Когда установлен порядок сверху-вниз или слева-направо, то
        следует придерживаться этого шаблона.

                     Как программист наблюдает порядок табуляции
        ─────────────────────────────────────────────────────────────────

             Как уже отмечалось ранее, порядок включения управляющих эле-
        ментов в окно определяет порядок табуляции,  так что когда вы за-
        писываете для окна код инициализации, учитывайте порядок, в кото-
        ром вы создаете и включаете управляющие элементы.

             Важно принимать во внимание не только фактический код, в ко-
        тором создаются  и  включаются управляющие  элементы,  но также и
        код, в котором устанавливаются и считываются значения управляющих
        элементов (как описывается в следующем разделе).

                           Работа с управляющими элементами
        ─────────────────────────────────────────────────────────────────

             В любой момент после построения объекта окна с  управляющими
        элементами вы  можете установить или считать значения всех управ-
        ляющих элементов с помощью методов SetData и GetData.  Эти методы
        отличаются от  соответствующих  методов  в  управляющих  и других
        отображаемых элементах. Все группы, включая окна и диалоговые ок-
        на, наследуют методы GetData и SetData,  которые выполняют итера-
        цию по их подэлементам  в  Z-последовательности,  вызывая  методы
        GetData и SetData отображаемых подэлементов.

                   Примечание: О  методах  GetData  и SetData и отдельных
              управляющих элементах рассказывается в  Главе  12  "Объекты

         B.Pascal 7 & Objects/TV#1   - 246 -

              управляющих элементов".

             В том случае,  когда окно содержит управляющие элементы, вы-
        зов его метода  SetData  приводит  к  вызову  по  порядку  метода
        SetData каждого управляющего элемента, так что вместо того, чтобы
        вручную инициализировать каждый управляющий  элемент,  вы  можете
        переложить эти обязанности на окно. Передаваемый SetData параметр
        - это запись, которая содержит поле для каждого управляющего эле-
        мента в окне.

                           Определение записей данных окна
        ─────────────────────────────────────────────────────────────────

             Чтобы определить запись данных для окна или диалогового  ок-
        на, сделайте следующее:

             - перечислите  каждый управляющий элемент в Z-последователь-
               ности;

             - определите для каждого управляющего элемента  запись  дан-
               ных;

             - создайте для каждого управляющего элемента запись с полем.

                       Установка значений управляющих элементов
        ─────────────────────────────────────────────────────────────────

             Метод SetData объекта окна вызывает  в  Z-последовательности
        методы SetData каждого его отображаемого подэлемента.  Передавае-
        мая каждому  отображаемому  подэлементу  запись  данных  является
        подмножеством записи,  переданной методу SetData окна. Первый уп-
        равляющий элемент в Z-последовательности получает весь отображае-
        мый элемент.  Если он считывает из записи несколько байт (что со-
        общается методом DataSize),  то SetData передает следующему отоб-
        ражаемому подэлементу только оставшуюся часть записи. Поэтому ес-
        ли  первый  управляющий считывает 4 байта,  метод SetData объекта
        окна передает второму отображаемому подэлементу запись,  начинаю-
        щуюся на 4 байта от начала исходной записи.

                      Считывание значений управляющих элементов
        ─────────────────────────────────────────────────────────────────

             Считывание значений управляющих элементов диалогового окна -
        это процесс,  в  точности  обратный  установке  значений.   Метод
        GetData объекта  диалогового окна вызывает в Z-последовательности
        методы GetData каждого отображаемого подэлемента.  Каждый отобра-
        жаемый подэлемент  получает  возможность  записать несколько байт
        (определяемый методом DataSize) в запись данных диалогового окна.



         B.Pascal 7 & Objects/TV#1   - 247 -

                              Работа с управляющими
                     элементами в режимных диалоговых окнах
        ─────────────────────────────────────────────────────────────────

             Если второй параметр метода ExecuteDialog отличен от nil, то
        приложение устанавливает  значения управляющих элементов в диало-
        говом окне и считывает их значения при закрытии режимного  диало-
        гового окна.

             Предполагается, что второй параметр ExecuteDialog - это ука-
        затель на запись данных диалогового окна. Как и в случае всех за-
        писей данных при установке и считывании значений управляющих эле-
        ментов, вы несете ответственность за обеспечение включения данных
        в указанную запись в корректном порядке.

             После построения  диалогового окна и выполнения проверок до-
        пустимости, если  указатель  записи  данных   отличен   от   nil,
        ExecuteDialog вызывает  метод  SetData  окна.  Когда пользователь
        завершает режимное состояние окна, ExecuteDialog считывает обрат-
        но в ту же запись данных с помощью вызова GetData значения управ-
        ляющих элементов,  пока режимное состояние не завершится командой
        cmCancel. В этом случае передачи данных не происходит.

                      Использование стандартных диалоговых окон
        ─────────────────────────────────────────────────────────────────

             Turbo Vision предусматривает три специальных вида диалоговых
        окон, которые  вы  можете  встраивать в свои программы.  В данном
        разделе поясняется, как использовать следующие окна:

             - окна сообщений;

             - файловые диалоговые окна;

             - диалоговые окна смены каталога.

                             Использование окон сообщений
        ─────────────────────────────────────────────────────────────────

             Модуль MsgBox  Turbo  Vision  предусматривает  две  полезных
        функции, которые выводят на экран в  диалоговом  окне  сообщения.
        Хотя блоки сообщений не вполне элегантны, их полезно использовать
        для вывода сообщений об ошибках  или представления информации при
        отладке приложения.

             Эти две  функции,  MessageBox  и  MessageBoxRect  отличаются
        только тем,  что MessageBoxRect воспринимает в качестве одного из
        своих параметров ограничивающий прямоугольник, а MessageBox всег-
        да использует для своих сообщений окно размером в 40 столбцов и 9
        строк. В   большинстве  случаев  MessageBox  использовать  легче.
        MessageBoxRect потребуется вам,  возможно,  только если вы хотите
        вывести очень большое сообщение.


         B.Pascal 7 & Objects/TV#1   - 248 -

             Чтобы использовать окна сообщений, вы должны понимать следу-
        ющие два вида параметров:

             - строку сообщений и ее параметры;

             - флаги параметров окна сообщения.

                           Строка сообщения и ее параметры
        ─────────────────────────────────────────────────────────────────

             Первые две  передаваемые  MessageBox строки - это строки для
        вывода на  экран  и  указания  массива  параметров  для   строки.
        MessageBox передает эти два параметра непосредственно в процедуру
        FormatStr, которая генерирует  строку  вывода  путем  подстановки
        значений из  списка параметров в строку сообщения.  В большинстве
        случаев вы будете передавать простую строку без параметров,  ука-
        зывая в списке параметров nil.

             Примером простого использования окна сообщений является окно
        About:

             procedure TMyApplication.ShowAboutBox;
             begin
               MEssageBox('Версия программы 1.0', nil,
                                           mfInformation of mfOkButton);
             end;

             В файле STRMERR.PAS на дистрибутивных дисках вы найдете  бо-
        лее сложный  пример  использования  диалогового окна для вывода в
        окне сообщений подробных сообщений об ошибках.

                           Установка флагов окна сообщения
        ─────────────────────────────────────────────────────────────────

             Последним параметром MessageBox является битовое слово, опи-
        сывающее заголовок окна сообщения и выводимые в этом окне команд-
        ные кнопки.  Turbo  Vision  определяет для каждого из этих флагов
        мнемонические константы.  Обычно передается комбинация двух конс-
        тант, одна  из  которых  задает  заголовок,  а другая - командные
        кнопки. Например,  следующий фрагмент программы  генерирует  окно
        подтверждения с  командными кнопками Yes (Да),  No (Нет) и Cancel
        (Отмена):

             MessageBox('Требуется немедленное переформатирование
               жесткого диска?', nil, mfConfirmation or mfYesNoCancel);

             Все возможные  значения флагов перечислены в Главе 19 "Спра-
        вочник по Turbo Vision".

                        Использование файловых диалоговых окон
        ─────────────────────────────────────────────────────────────────

             Общим типом  диалогового  окна  является файловое диалоговое

         B.Pascal 7 & Objects/TV#1   - 249 -

        окно, используемое для задания имени сохраняемого или открываемо-
        го файла.  В модуле StdDlg Turbo Vision предусмотрено стандартное
        диалоговое окно, которое вы можете использовать как для загрузки,
        так и для сохранения файлов.

                     Использование диалоговых окон смены каталога
        ─────────────────────────────────────────────────────────────────

             Другим общепринятым типом диалогового окна является диалого-
        вое окно смены каталога,  которое позволяет  пользователю  видеть
        структуру каталога на диске и перемещаться по подкаталогам. В мо-
        дуле StdDlg Turbo Vision предусмотрено стандартное диалоговое ок-
        но,  которое вы можете использовать для смены пользователем теку-
        щего каталога.



         B.Pascal 7 & Objects/TV#1   - 250 -

─────────────────────────────────────────────────────────────────────────
                ГЛАВА 12. Использование объектов управляющих элементов
        ─────────────────────────────────────────────────────────────────

             Объекты управляющих элементов - это специализированные отоб-
        ражаемые элементы,  которые  могут  выполнять стандартные функции
        интерфейса с пользователем.  В данной главе описываются операции,
        общие для  всех типов объектов управляющих элементов и предусмот-
        рена информация по каждому конкретному управляющему элементу:

             - использование объектов управляющих элементов;
             - использование текстовых управляющих элементов;
             - использование полос прокрутки;
             - использование кнопок с зависимой и независимой фиксацией;
             - выбор из списков;
             - вывод на экран схемы;
             - получения вводимых пользователем данных;
             - использование протоколов;
             - метки управляющих элементов.

                  Использование объектов управляющих элементов
        ─────────────────────────────────────────────────────────────────

             Вы можете использовать объекты управляющих элементов как лю-
        бые другие отображаемые элементы.  Чаще всего вы помещаете управ-
        ляющие элементы  в диалоговые окна для получения ввода от пользо-
        вателя, но их можно использовать также и в  обычных  окнах.  Хотя
        каждый вид  управляющих элементов имеет свои уникальные свойства,
        существует три общих задачи, которые вы должны понимать для рабо-
        ты со всеми управляющими элементами:

             - построение и включение управляющих элементов;
             - инициализация значений управляющих элементов;
             - установка и считывание значение управляющих элементов.

                    Построение объектов управляющих элементов
        ─────────────────────────────────────────────────────────────────

             В общем случае  построение  объектов  управляющих  элементов
        требует трех шагов:

             - назначения ограничивающего прямоугольника;

             - вызов конструктора;

             - включение во владельца.

             Второй и  третий  шаг часто комбинируются в один оператор (в
        зависимости от того,  присваиваете ли вы объект управляющего эле-
        мента переменной). В следующем примере показаны два способа пост-
        роения одного и того же статического управляющего элемента:

             R.Assign(10, 2, 20, 3);
             Control := New(PStaticText, Init(R, 'Borland'));

         B.Pascal 7 & Objects/TV#1   - 251 -

             Insert(Control);

             R.Assign(10, 2, 20, 3);
             Insert(New(PStaticText, Init(R, 'Borland')));

             Во многих случаях вторая форма, где объект управляющего эле-
        мента не присваивается переменной - это все,  что требуется. Если
        вам необходим  доступ к конкретному управляющему элементу (напри-
        мер, для присваивания объекту метки и работы с  этим  управляющим
        элементом в программе), его следует присвоить переменной.

                  Инициализация объектов управляющих элементов
        ─────────────────────────────────────────────────────────────────

             После построения объекта управляющего элемента вы можете из-
        менить его характеристики или изменить начальное значение. Напри-
        мер, следующий фрагмент программы показывает,  как можно  устано-
        вить флаг  объекта  командной кнопки ofCenterX,  чтобы обеспечить
        горизонтальное центрирование в его окне-владельце:

             CenterButton := New(PButton, Init(R, 'O~k~', cmOk,
                                 bfDefault));
             CenterButton^.Options := CenterButton^.Options or
                                 ofCenterX;
             Insert(CenterButton);

             Аналогично, вы можете задать  начальное  строковое  значение
        для строки ввода, как показывает следующий фрагмент:

             InitText := New(PInputLine, Init(R, 30));
             InitText^.Data^ := Copy('Borland International', 1, 30);
             Insert(InitText);

             В общем случае вам не следует при использовании режимных ди-
        алоговых окон присваивать начальные значения управляющим  элемен-
        там таким образом. В таком случае для инициализации всех управля-
        ющих элементов сразу используйте запись данных.

              Установка и считывание значений управляющих элементов
        ─────────────────────────────────────────────────────────────────

             Кроме установки  начальных  значений  управляющих  элементов
        (что обсуждалось в предыдущем разделе),  существует две ситуации,
        в которых  вам потребуется возможность считывания значений управ-
        ляющих элементов:

             - при открытии или закрытии режимного диалогового окна;

             - в любой момент существования безрежимного окна или  диало-
               гового управляющего элемента.

             Управляющие элементы  используют  преимущества трех методов,
        встроенных  во все отображаемые  элементы  и  позволяющие  вашему

         B.Pascal 7 & Objects/TV#1   - 252 -

        приложению считывать или  записывать значения управляющих элемен-
        тов по запросу.  Используя методы DataSize, GetData и SetData, вы
        можете изменить  значения управляющих элементов или при необходи-
        мости считать текущие установленные значения.

             В данном разделе подробно  описывается,  как  можно  сделать
        следующее:

             - установить значения управляющих элементов;

             - считать значения управляющих элементов;

             - настроить передачу данных.

                    Установка значений управляющих элементов
        ─────────────────────────────────────────────────────────────────

             В любой момент вы можете установить значение объекта  управ-
        ляющего элемента путем вызова ее метода SetData. SetData считыва-
        ет данные из записи,  передаваемой в качестве аргумента,  и уста-
        навливает соответственно значение управляющего элемента. Посколь-
        ку для каждого вида управляющего элемента требуется в чем-то  от-
        личная информация,  записи данных могут различаться в зависимости
        от типа управляющего элемента.

             Параметр метода SetData - это нетипизированный  параметр-пе-
        ременная, так  что вы можете передать управляющему элементу прак-
        тически все,  но с некоторыми огранчениями. Во-первых, SetData (и
        соответствующий  метод GetData) ожидает запись,  содержащую число
        байт,  заданных методом DataSize. Например, тип TCheckBoxes имеет
        размер данных 2, поскольку предполагает, что запись данных содер-
        жит число типа Word (2 байта).


         B.Pascal 7 & Objects/TV#1   - 253 -


             В Таблице 12.1 показаны размеры данных и записи  данных  для
        каждого из стандартных управляющих элементов Turbo Vision:

                             Записи передачи данных
                       для объектов управляющих элементов    Таблица 12.1
        ┌───────────────────────┬─────────────────┬─────────────────────┐
        │          Тип          │     Размер      │     Интерпретация   │
        │ управляющего элемента │данных (в байтах)│        данных       │
        ├───────────────────────┼─────────────────┼─────────────────────┤
        │ Командная кнопка      │       0         │ Нет.                │
        ├───────────────────────┼─────────────────┼─────────────────────┤
        │ Кнопки с независимой  │       2         │ Один бит на кнопку с│
        │ фиксацией             │                 │ независимой фиксаци-│
        │                       │                 │ ей.                 │
        ├───────────────────────┼─────────────────┼─────────────────────┤
        │ Строка ввода          │  MaxLen + 1     │ Строка   Паскаля   с│
        │                       │                 │ байтом длины,  пред-│
        │                       │                 │ шествующим тексту.  │
        ├───────────────────────┼─────────────────┼─────────────────────┤
        │ Метка                 │       0         │ Нет.                │
        ├───────────────────────┼─────────────────┼─────────────────────┤
        │ Блок списка           │       6         │ Указатель на  список│
        │                       │                 │ элементов  и   номер│
        │                       │                 │ выбранного элемента.│
        ├───────────────────────┼─────────────────┼─────────────────────┤
        │ Кнопки с независимой  │       4         │ Изменяется в зависи-│
        │ фиксацией с нескольким│                 │ мости от флагов.    │
        │ состояниями           │                 │                     │
        ├───────────────────────┼─────────────────┼─────────────────────┤
        │ Текст параметра       │  ParamCount + 1 │ Параметры  для  под-│
        │                       │                 │ становки в текст.   │
        ├───────────────────────┼─────────────────┼─────────────────────┤
        │ Кнопки с зависимой    │       2         │ Порядковый     номер│
        │ фиксацией             │                 │ кнопки с независимой│
        │                       │                 │ фиксацией.          │
        ├───────────────────────┼─────────────────┼─────────────────────┤
        │ Полоса прокрутки      │       0         │ Нет.                │
        ├───────────────────────┼─────────────────┼─────────────────────┤
        │ Статический текст     │       0         │ Нет.                │
        └───────────────────────┴─────────────────┴─────────────────────┘

         B.Pascal 7 & Objects/TV#1   - 254 -

                    Считывание значений управляющих элементов
        ─────────────────────────────────────────────────────────────────

             Считывание значения управляющего элемента - это  процесс,  в
        точности обратный  установке  значения.  Вы можете вызывать метод
        GetData объекта управляющего элемента, передавая запись данных, а
        GetData заполняет запись представлением его значения. Объем и тип
        передаваемых данных в точности тот же, что и для SetData (как по-
        казано в Таблице 12.1).

             Например, чтобы  определить,  какой  элемент  в блоке списка
        выбран в данный момент,  используем фрагмент программы, аналогич-
        ный предыдущему примеру:

             type
               TListBoxRec = record     { определить запись данных для
                                          блока списка }
                  ListPtr: PCollection; { указатель на список
                                          элементов }
                  SelectedItem: Word;   { номер выбранного элемента }
               end;

             function GetSelectedItem: Word;
             car ListInfo: TListBoxRec;
             begin
               ListBox.GetData(ListInfo); { установить запись из
                                         управляющего элемента }
               GetSelectedItem := ListInfo.SelectedItem; { возвратить
                                         выбранный элемент }
             end;

             В основном вам не потребуется считывать  значения  отдельных
        управляющих элементов.  Вероятнее всего, вы будете считывать зна-
        чения всех управляющих элементов,  используя метод GetData диало-
        гового окна.

                            Настройка передачи данных
        ─────────────────────────────────────────────────────────────────

             Управление типами в Turbo Vision  предназначено  для  общего
        использования, так  что  оно может оказаться не самым эффективным
        инструментом для конкретного приложения. Для установки и считыва-
        ния  их значений вы можете создать производные управляющие объек-
        ты, которые используют более специализированные записи данных.

             Например, если у  вас  есть  программа,  которая  использует
        строки ввода для числового ввода, то передавать всю строку в объ-
        ект и из объекта не слишком эффективно. Гораздо больший смысл ис-
        пользовать числовое значение. В следующем примере показаны методы
        передачи данных для простой числовой строки ввода,  которая обра-
        батывает значения типа Word:

             type

         B.Pascal 7 & Objects/TV#1   - 255 -

               TWordInputLine = object(TInputLine);
                  function DataSize: Word; virtual;
                  procedure GetData(var Rec); virtual;
                  procedure SetData(var Rec); virtual;
               end;

             function TWordInputLine.DataSize: Word;
             begin
               DataSize := SizeOf(Word);
             end;

             procedure TWordInputLine.GetData(var Rec);
             var ErrCode: Integer;
             begin
               Val(Data^, Word(Rec), ErrCode);
             end;

             procedure TWordInputLine.SetData(var Rec);
             begin
               Str(Word(Rec), Data^);     { установить данные Data
                                            из Rec }
             end;

             Используя объекты  проверки  допустимости данных,  вы можете
        также настроить передачу данных для строк ввода.  О том  как  ис-
        пользовать средства  проверки допустимости рассказывается в Главе
        13 "Объекты проверки допустимости данных".

                            Вывод статического текста
        ─────────────────────────────────────────────────────────────────

             Объекты статического текста - это простейший вид управляющих
        элементов. Тип TStaticText инкапсулирует в отображаемом  элементе
        текстовую строку,  выводя на экране заданный текст в ограниченном
        прямоугольнике отображаемого элемента. Объект статического текста
        не предназначен  для вывода текста,  который часто изменяется,  а
        используется для вывода фиксированной строки в фиксированной  по-
        зиции. В  Главе  15  "Редактор и текстовые отображаемые элементы"
        описывается,  как выводить на экран большие объемы  динамического
        текста.  По умолчанию управляющие элементы статического текста не
        выбираются,  поэтому пользователь с ними никогда активно не взаи-
        модействует.

             Turbo Vision предусматривает также объект TParamText,  кото-
        рый выводит на экран в отображаемом элементе  статический  текст,
        но  позволяет  вам подставлять в текст параметры для простого его
        форматирования.

             Остальная часть данного раздела описывает,  как использовать
        статические текстовые управляющие элементы, включая следующие те-
        мы:

             - вывод простого текста;

         B.Pascal 7 & Objects/TV#1   - 256 -


             - вывод параметризованного текста.

                              Вывод простого текста
        ─────────────────────────────────────────────────────────────────

             Базовый объект  TStaticText управляет строками,  которые со-
        держат только стандартные символы ASCII и два символа  управления
        форматированием. Существуют  только  три задачи,  которые требуют
        понимания для использования объектов статического текста:

             - форматирование статического текста;

             - построение управляющих элементов статического текста;

             - задание и считывание статического текста.

                       Форматирование статического текста
        ─────────────────────────────────────────────────────────────────

             Объекты статического  текста допускают два вида форматирова-
        ния. Символ Ctrl+M (#13) в тексте указывает на перевод  страницы,
        так что  вы  можете  задать  в  одной  строке несколько текстовых
        строк. Строки,  которые начинаются с Ctrl+C (#3)  центрируются  в
        отображаемом элементе горизонтально.

             Например, строка  'Turbo  Text'#13'Version 0.9' выводится на
        экран в виде:

             Turbo  Text
             Version 0.9

        а строка

             Например, строка '#3Turbo Text'#13'Version 0.9' - в виде:

                                   Turbo  Text
                                   Version 0.9

             Построение статических текстовых отображаемых элементов
        ─────────────────────────────────────────────────────────────────

             Конструктор статических   текстовых   управляющих  элементов
        воспринимает только два параметра: ограничивающий прямоугольник и
        текст для управляющего элемента:

             constructor TStaticText.Init(var Bounds: TRect;
                                          AText: String);

             Наиболее важным моментом, о котором не следует забывать, яв-
        ляется то,  что прямоугольник границ должен быть достаточно боль-
        шим для вывода на экран всей текстовой строки,  так как выходящий
        за границу текст будет отсекаться, то есть окажется скрытым.

         B.Pascal 7 & Objects/TV#1   - 257 -


             Это означает, что управляющие элементы статического текста с
        несколькими строками должны включать в себя достаточно  текстовых
        строк на экране,  и каждая строка должна быть достаточно длинной,
        чтобы содержать весь свой текст.

             Например, наименьший прямоугольник,  который выводит  строку
        'Borland', назначается оператором:

             R.Assign(0, 0, 7, 1);

             Для вывода  на  экран  'Borland'#13'International' вам нужно
        присвоить прямоугольник с, по крайней мере, двумя строками и три-
        надцатью столбцами.

             Статические текстовые  управляющие элементы определяют текст
        для отображения,  вызывая  текущий  виртуальный  метод  с  именем
        GetText. Таким  образом,  вы  можете изменить способ вывода в нем
        текста, переопределив один этот метод (как это  делается,  напри-
        мер, в параметризированных текстовых управляющих элементах).

                    Задание и считывание статического текста
        ─────────────────────────────────────────────────────────────────

             По умолчанию статические текстовые отображаемые элементы  не
        могут устанавливать  или  считывать  новые значения.  Статические
        текстовые строки устанавливаются при инициализации,  и  ни  метод
        GetData, ни  метод  SetData не передают никаких данных.  DataSize
        возвращает нулевое значение.

                   Вывод на экран параметризированного текста
        ─────────────────────────────────────────────────────────────────

             Тип TParamText  допускает  несколько  большую гибкость,  чем
        простой статический текстовый управляющий элемент.  Кроме  вывода
        текстовых строк, параметризированный статический текстовый управ-
        ляющий элемент позволяет вам передавать ему различные  параметры,
        которые он форматирует, в текст с помощью процедуры FormatStr.

             Единственными двумя задачами, которые выполняются в парамет-
        ризированных текстовых  управляющих  элементах  и  в  статических
        текстовых управляющих элемента по-разному являются:

             - форматирование текста;

             - установка и считывание управляющего элемента.

                   Форматирование параметризированного текста
        ─────────────────────────────────────────────────────────────────

             Параметризированный текст использует процедуру FormatStr для
        подстановки параметров в текст, который в противном случае был бы
        статической текстовой строкой.  Каждый параметр - это четыре бай-

         B.Pascal 7 & Objects/TV#1   - 258 -

        та, передаваемые  в виде массива или записи.  Специальные символы
        форматирования в текстовой строке сообщают FormatStr, как интерп-
        ретировать  значение  каждого  параметра.  Каждый  параметр может
        представлять число типа Longint, указатель на строку или символ.

             Предположим, например, что у вас есть запись с двумя полями:
        указатель на имя файла и размер файла в байтах:

             type
               TFileInfoREc = record
                 FileName: PString;
                 FileLength: Longint;
               end;

             var FileInfo: TFileInfoRec;

             Используя FormatStr,  вы  можете на основе значений в записи
        форматировать строку, которая включает имя файла и размер:

             FormatStr(ResultStr, 'File: #-12s, Size: %9d', FileInfo);

             Чтобы использовать в параметризированном текстовом управляю-
        щем элементе форматирование, присвойте 'File: #-12s, Size: %9d' в
        качестве текстовой строки управляющего элемента и укажите ему  на
        подстановку двух параметров.



         B.Pascal 7 & Objects/TV#1   - 259 -

                                   Построение
               параметризированных текстовых управляющих элементов
        ─────────────────────────────────────────────────────────────────

             Конструкторы параметризированного   текстового  управляющего
        элемента воспринимают на один параметр  больше,  чем  статические
        текстовые управляющие элементы. Кроме ограничивающего прямоуголь-
        ника и текстовой строки,  вы передаете также число параметров для
        подстановки в текст:

             constructor TParamText.Init(var Bounds: TRect;
                                    AText: String; AParamCount: Integer);

             Init выделяет память,  достаточную для AParamCount  парамет-
        ров.  Параметры получают свои значения в методе SetData.  SetData
        копирует DataSize байт из переданной записи данных в список пара-
        метров  управляющего  элемента.  Убедитесь в вызове SetData перед
        отображением управляющего элемента.

             Подстановка параметров в текст имеет место в виртуальном ме-
        тоде GetText.  Метод Draw,  наследуемый из TStaticText,  вызывает
        метод GetText для определения того, какой текст нужно выводить на
        экран.  Метод GetText в TParamText вызывает FormatStr для слияния
        параметров в списке параметров в текстовую  строку  и  возвращает
        результат.

               Установка и считывание параметризированного текста
        ─────────────────────────────────────────────────────────────────

             Пользователям никогда не предоставляется  возможности  изме-
        нять значения параметров в параметризированном текстовом управля-
        ющем элементе, так нет необходимости считывать значения из объек-
        та TParamText.  TParamText, таким образом, использует наследуемый
        из TStaticText метод GetData, который ничего не делает.

             С другой стороны,  важно иметь возможность устанавливать па-
        раметры, поскольку это определяет вывод на экран.  Таким образом,
        SetData копирует из заданной записи данных  в  список  параметров
        достаточно данных для всех параметров.

                          Использование полос прокрутки
        ─────────────────────────────────────────────────────────────────

             Полоса прокрутки - это  визуальное  представление  диапазона
        чисел. Пользователь  манипулирует текущим значением в этом диапа-
        зоне (представленным индикатором или маркером полосы  прокрутки),
        щелкая кнопкой  "мыши"  на  стрелках на концах полосах прокрутки,
        щелкая "мышью" на "страничных" областях между стрелками  или  не-
        посредственно перемещая индикатор прокрутки.

             Полосы прокрутки   предоставляют   пользователю  возможность
        быстро перемещаться по большому количеству информации,  например,
        просматривать текст  документа.  Большинство  полос  прокрутки  в

         B.Pascal 7 & Objects/TV#1   - 260 -

        Turbo Vision работают аналогично другим  отображаемым  элементам,
        таким как отображаемый элемент прокрутки или блок списка. В боль-
        шинстве случаев вам необходимо  только  построить  объект  полосы
        прокрутки и связать его с другим отображаемым элементом; обо всем
        остальном позаботятся другие отображаемые элементы.

             Существует три вида задач,  которые вы будете выполнять  при
        работе с управляющими элементами полос прокрутки:

             - построение управляющих элементов полосы прокрутки;

             - манипулирование управляющими элементами полос прокрутки;

             - реакция на полосы прокрутки.

                Построение управляющих элементов полос прокрутки
        ─────────────────────────────────────────────────────────────────

             Построить объект  управляющего  элемента  полосы   прокрутки
        очень просто.  Все, что вам нужно задать, это один параметр - об-
        рамляющий прямоугольник.  Если прямоугольник  имеет  ширину  один
        символ, то  результатом будет вертикальная полоса прокрутки.  Все
        другие размеры дают горизонтальную полосу прокрутки.

             Все прочие параметры управляющего элемента полосы  прокрутки
        устанавливаются после их создания, обычно соответствующим отобра-
        жаемым элементом. Например, когда вы строите полосу прокрутку для
        блока списка,  то  можете включить полосу прокрутки в окно-владе-
        лец, а затем передать  указатель на полосу прокрутки  в  качестве
        параметра конструктора  блока  списка.  Затем объект блока списка
        берет на себя установку диапазона полосы  прокрутки  в  значения,
        соответствующие размеру блока списка и его элементам.

            Манипулирование управляющими элементами полосы прокрутки
        ─────────────────────────────────────────────────────────────────

             Объекты полосы прокрутки обеспечивают три метода, которые вы
        можете вызывать  непосредственно  для  манипулирования значениями
        полосы прокрутки:  SetRange,  SetStep и SetValue.  Метод SetRenge
        присваивает диапазону полосу прокрутки минимальное и максимальное
        значения. SetStep устанавливает величину изменения значения, ког-
        да  пользователь щелкает "мышью" на областях листания и стрелках.
        SetValue устанавливает значение индикатора полосы прокрутки.

             Все три метода вызывают более общий метод,  SetParams, кото-
        рый выполняет  установку всех параметров для полосы прокрутки,  а
        затем изображает заново отображаемый  элемент и посылает оповеща-
        ющее сообщение  для уведомления других отображаемых элементов при
        изменении позиции полосы прокрутки.

                           Реакция на полосы прокрутки
        ─────────────────────────────────────────────────────────────────


         B.Pascal 7 & Objects/TV#1   - 261 -

             Другие управляющие  элементы  редко просто опрашивают полосу
        прокрутки для определения ее значения. Полоса прокрутки при изме-
        нении своего  значения сама посылает оповещающее сообщение своему
        владельцу, а другие объекты реагируют на это оповещение, запраши-
        вание значение полосы прокрутки.

             При изменении  значения полосы прокрутки объект полосы прок-
        рутки вызывает его метод ScrollDraw, который посылает оповещающее
        сообщение:

             Message(Owner, evBroadcast, cmScrollBarChanged, @Self);

             Объекты, реагирующие  на изменения полосы прокрутки,  должны
        проверять поле InfoPtr оповещающего сообщения, которое уведомляет
        их  об  изменении полосы прокрутки.  Если InfoPtr указывает на ту
        полосу прокрутки, на которую должен реагировать данный отображае-
        мый элемент, он должен запросить у полосы прокрутки ее значение и
        использовать это значение для обновления своего вида. В следующем
        примере показано,  как TScroller проверяет, изменилась ли его по-
        лоса прокрутки:

             procedure TScroller.HandleEvent(var Event: TEvent);
             begin
               inherited HandleEvent(Event);
               with Event do
               if (What = evBroadcast) and (Command = cmScrollBarChanged)
                   and ((InfoPtr = HScrollBar) or (InfoPtr = VScrollBar))
                   then ScrollDraw;
             end;

             procedure TScroller.Scroller.ScrollDraw;
             var D: TPoint;
             begin
               if HScrollBar <> nil then D.X := HScrollBar^.Value
               else D.X := 0;
               if VScrollBar <> nil then D.Y := HScrollBar^.Value
               else D.Y := 0;
                .
                .
                .
             end;

                        Использование кластерных объектов
        ─────────────────────────────────────────────────────────────────

             Turbo Vision предусматривает три вида управляющих элементов,
        которые выводятся  в  кластерах или группах связанных управляющих
        элементов: кнопки с независимой  фиксацией,  кнопки  с  зависимой
        фиксацией и  кнопки с независимой фиксацией с несколькими состоя-
        ниями. Хотя вы можете иметь кластер, который содержит только одну
        кнопку с  независимой  фиксацией,  в большинстве случаев их число
        превышает единицу.  Фактически, хотя вы можете иметь единственную
        кнопку с  зависимой фиксацией,  она будет бесполезной,  поскольку

         B.Pascal 7 & Objects/TV#1   - 262 -

        отмена нажатия такой кнопки (ее "отжатие") заключается в  нажатии
        другой командной кнопки того же кластера.

                         Работа с кластерными объектами
        ─────────────────────────────────────────────────────────────────

             Существует несколько задач,  которые в равной степени приме-
        нимы ко всем кластерным объектам:

             - построение кластера;

             - нажатие командной кнопки;

             - сообщение, является ли командная кнопка выбранной;

             - запрещение отдельных командных кнопок.

                         Построение кластерных объектов
        ─────────────────────────────────────────────────────────────────

             Конструктор кластерного объекта воспринимает только два  па-
        раметра: ограничивающий  прямоугольник и связанный список строко-
        вых элементов.  Когда вы присваиваете ограничивающий  прямоуголь-
        ник, убедитесь,  что  у  вас  достаточно места для блока слева от
        текста и для всех строк в списке.

             Связанный список строковых элементов создается обычно в  ре-
        зультате последовательности  вложенных вызовов NewItem - функции,
        которая выделяет для динамической  строки  память  в  динамически
        распределяемой области  с  указателем на следующий такой элемент.
        Например чтобы построить набор из трех кнопок с независимой  фик-
        сацией, используйте следующий фрагмент программы:

             var Control: PView;
               .
               .
               .
             R.Assign(11, 6, 22, 9);               { установить границы }
             Control := New(PCheckBox, Init(R,     { построить кластер }
                 NewSItem('~R~ed',                 { первый элемент }
                 NewSItem('~G~reen',               { второй элемент }
                 NewSItem('~B~lue',                { третий элемент }
                   .
                   .
                   .

                            Нажатие командной кнопки
        ─────────────────────────────────────────────────────────────────

             Хотя делать это требуется редко,  вы можете моделировать на-
        жатие отдельного элемента в кластере вызова метода Press  объекта
        кластера. Press - это виртуальный метод, поэтому каждый вид клас-
        тера может реагировать соответствующим образом. Метод Press восп-

         B.Pascal 7 & Objects/TV#1   - 263 -

        ринимает единственный параметр - номер нажимаемого элемента. Эле-
        менты имеют последовательные номера,  которые начинаются с  нуля.
        Вызов метода Press имеет тот же эффект,  что и щелчок на элементе
        кнопкой "мыши".

                            Указание на выбор кнопки
        ─────────────────────────────────────────────────────────────────

             Кластеры имеют  виртуальный  метод Mark,  который работает в
        сочетании с Press. Метод Mark воспринимает единственный параметр,
        указывающий элемент, о котором вы хотите знать, и возвращает зна-
        чение True, если элемент отмечен. Для кнопок с независимой фикса-
        цией с несколькими состояниями Mark не имеет смысла.

                      Запрещение отдельных командных кнопок
        ─────────────────────────────────────────────────────────────────

             Кластерные объекты содержат маску, указывающую на запрещение
        отдельных элементов в кластере. EventMask - это битовое поле типа
        Longint, в котором каждый бит  представляет  состояние  одной  из
        кнопок в кластере. Так как различные потомки TCluster интерпрети-
        руют их поля Value по-разному,  то взаимно-однозначное  соответс-
        твие между битами EnableMask и битами в Value отсутствует.

             Каждый бит в EnableMask представляет один из первых тридцати
        двух элементов  в кластере,  где младший бит - это первый элемент
        (элемент с номером 0), а старший бит - это 32-ой элемент (элемент
        с номером 31). Если бит установлен, то элемент разрешен. По умол-
        чанию кластерные объекты устанавливают все биты (EnableMask равно
        $FFFFFFFF), так что все элементы разрешенные.  Таким образом,  вы
        можете запретить любой из элементов,  переключив  соответствующий
        бит или биты.

             Если EnableMask равно 0,  это означает,  что ни один из эле-
        ментов не является разрешенным, и кластер устанавливает свое сос-
        тояние таким образом,  что весь управляющий элемент будет невыби-
        раемым.

                  Использование кнопок с независимой фиксацией
        ─────────────────────────────────────────────────────────────────

             Кластер кнопок с независимой фиксацией интерпретирует нижнюю
        половину поля Value как 16 отдельных бит, каждый из которых соот-
        ветствует одной кнопке с независимой фиксацией. Если бит установ-
        лен, то кнопка выбрана ("нажата").  Если бит очищен, то кнопка не
        выбрана. Если  в  одном  кластере вам требуется более 16 кнопок с
        независимой фиксацией, то из TCheckBox нужно создать новый произ-
        водный тип, который использует все 32 бита Value.

                   Использование кнопок с зависимой фиксацией
        ─────────────────────────────────────────────────────────────────

             Так как в кластере в каждый момент  выбирается  только  одна

         B.Pascal 7 & Objects/TV#1   - 264 -

        кнопка с независимой фиксацией из набора,  кластер интерпретирует
        значение Value как целое число,  значение которого указывает  по-
        рядковый номер "нажатой" кнопки.  Это означает,  что теоретически
        вы можете иметь более 65000 кнопок  с  независимой  фиксацией  на
        кластер. Так  как  в отображаемом элементе столько кнопок размес-
        тить невозможно, реальный предел ощутимо меньше.



         B.Pascal 7 & Objects/TV#1   - 265 -

                             Использование кнопок с
                 независимой фиксацией с несколькими состояниями
        ─────────────────────────────────────────────────────────────────

             Кнопки с независимой фиксацией с несколькими состояниями ра-
        ботают как обычные кнопки с независимой фиксацией, но могут иметь
        состояния, отличные от выбранного и  невыбранного.  Например,  вы
        можете представить выбранное, невыбранное и неопределенное состо-
        яние и циклически по ним переключаться.

             Так как представление более двух состояний требует более од-
        ного бита, интерпретация поля Value для кнопок с независимой фик-
        сацией с несколькими состояниями более сложная. В отличие от кно-
        пок с зависимой и независимой фиксацией кнопки с независимой фик-
        сацией с несколькими состояниями  переопределяют  наследуемый  из
        TCluster конструктор:

             constructor Init(var Bounds: TRect; AStrings: PSItem;
                   ASelRange: Byte; AFlags: Word; const AStates: String);

             Когда вы строите набор кнопок с независимой фиксацией с нес-
        колькими состояниями,  нужно  указать,  число состояний,  которые
        имеет каждая кнопка (ASelRange), и число бит в Value представляет
        каждый  элемент (AFlags).  Turbo Vision предусматривает константы
        cfOneBit,  cfTwoBits, cfFourBits и cfEightBits, которые вы можете
        передать для представления одного,  двух,  четырех или восьми бит
        на кнопку с независимой фиксацией соответственно. Строка, переда-
        ваемая в AStates,  должна содержать символ для представления каж-
        дого состояния кнопки с независимой фиксацией.

                                Выбор из списков
        ─────────────────────────────────────────────────────────────────

             Turbo Vision  предусматривает  ряд  объектов  для  работы со
        списками, включая несколько отображаемых  элементов,  позволяющих
        пользователю выбирать элементы из списков.  В данном разделе опи-
        сывается абстрактный элемент просмотра списка TListViewer  и  уп-
        равляющий объект блока списка TListBox.  В следующем разделе опи-
        сывается более специализированный отображаемый элемент  списка  -
        средство просмотра разметки.

             В данном разделе описываются следующие задачи:

             - работа со средствами просмотра списка;

             - использование управляющих элементов блока списка.



         B.Pascal 7 & Objects/TV#1   - 266 -

                     Работа со средствами просмотра списков
        ─────────────────────────────────────────────────────────────────

             Фактически, вам никогда не потребуется  создавать  экземпляр
        TListViewer, но  управляющий  элемента  блока списка Turbo Vision
        наследует большую часть своего поведения из абстрактного средства
        просмотра списка, и вероятно, что вы захотите создать собственные
        средства просмотра списков.

             Абстрактное средство просмотра списка TListViewer имеет  все
        необходимое для просмотра и выбора из списка,  кроме самого спис-
        ка. То есть оно знает,  как выводить на экран в отображаемом эле-
        менте список элементов,  выполнять прокрутку этого списка,  выби-
        рать элементы и т.д.,  но ничего не знает об  элементах,  которые
        нужно выводить  на экран.  Вместо этого оно определяет ряд вирту-
        альных методов,  которые вы можете переопределять  для  настройки
        общего объекта для конкретных списков.

             Простейшим примером рабочего средства просмотра списка явля-
        ется управляющий элемент блока списка,  который использует в  ка-
        честве своего списка объект набора (обычно строковый набор).  Вы-
        водимый вами список может быть любым списком, например, массивом.

             Чтобы использовать объекты  средства  просмотра  списка,  вы
        должны понимать следующие задачи:

             - построение средства просмотра списка;

             - получение текста элемента списка;

             - реакция на выбор в списке.

                      Построение средства просмотра списка
        ─────────────────────────────────────────────────────────────────

             Построить средство просмотра списка  достаточно  просто.  По
        умолчанию средство  просмотра списка воспринимает четыре парамет-
        ра: ограничивающий прямоугольник,  число столбцов  для  вывода  и
        указатели на два объекта полосы прокрутки.

             constructor TListViewer.Init(var Bounds: TRect;
                ANumCols: Integer; AHScrollBar, AVScrollBar: PScrollBar);

             Когда вы строите  используемое  средство  просмотра  списка,
        производное от  TListViewer,  то  можете для некоторых приложений
        переопределить конструктор.    Рассмотрим,    например,    объект
        TFileList, который обеспечивает двухколоночный  список  файлов  в
        файловом диалоговом блоке в модуле StdDlg.  Конструктор TFileList
        воспринимает только два параметра - ограничивающий  прямоугольник
        и  одну полосу прокрутки (поскольку всегда содержит два столбца и
        nil в качестве вертикальной полосы прокрутки).



         B.Pascal 7 & Objects/TV#1   - 267 -

                        Получение текста элемента списка
        ─────────────────────────────────────────────────────────────────

             TListViewer предусматривает метод с  именем  GetText.  Метод
        Draw средства просмотра списка вызывает метод GetText для каждого
        элемента, который нужно вывести на экран, передавая номер элемен-
        та. Когда  вы  создаете средство просмотра списка и снабжаете его
        списком, то отвечаете за переопределение метода GetText для возв-
        рата строки, которую требуется выводить в списке.

             Предположим, например,  что  вы  строите  средство просмотра
        списка для вывода списка членов небольшого клуба.  Ваш список со-
        держит массив  записей,  а каждая запись состоит из информации об
        одном из членов, например:

             type
               TMemberInfo = record
                  FirstName, LastName: string[25];      { имя и фамилия }
                  PhomeNumber: string[20];              { телефон }
                      .
                      .
                      .
               end;

             var
               MemberArray: array[0..10] of TMemberInfo;

             Для вывода на экран списка в виде "фамилия,  имя" вы  должны
        переопределить GetText:

             function TMemberList.GetText(Item: Integer;
                                          MaxLen: Integer): String;
             begin
               with MemberArray[Item] do
                   GetText := Copy(LastName + ', ' + FirstName,
                                   1, MaxLen);
             end;



         B.Pascal 7 & Objects/TV#1   - 268 -

                            Реакция на выбор в списке
        ─────────────────────────────────────────────────────────────────

             Когда пользователь выбирает  элемент  в  средстве  просмотра
        списка путем двойного щелчка кнопкой "мыши" или перемещения фоку-
        са с помощью клавиш стрелок и  нажатия  клавиши  пробела,  объект
        средства просмотра списка передает своему окну-владельцу оповеща-
        ющее командное событие с командой  cmListItemSelected,  передавая
        его адрес в поле InfoPtr.  Все другие объекты,  которым требуется
        знать о том, какой элемент выбрал пользователь, могут затем опро-
        сить средство просмотра списка, на какой элемент переместился фо-
        кус.

             Например, чтобы получить строку ввода,  в которой  выводится
        текущий выбранный  в  средстве  просмотра  списка элемент, методу
        HandleEvent нужно ответить на оповещение cmListItemSelected  (как
        показано в следующем примере).  Следующий фрагмент программы взят
        из файла PICKLIST.PAS,  который вы можете найти на дистрибутивных
        дисках:

             procedure TPickLine.HandleEvent(var Event: TEvent);
             begin
               inherited HandleEvent(Event); { выполнить как обычную
                                               строку ввода }
               if Event.Command = cmListItemSelected then
                                    { отследить командное оповещение }
               begin
                 with PListBox(Event.InfoPtr)^ do { связаться с
                                               оповестителем ... }
                   Data^ := GetText(Focused, 30); { ... и получить
                                               выделенный текст }
                   DrawView;                 { обновить строку ввода }
                   ClearEvent(Event);        { указать, что событие
                                               было обработано }
               end;
             end;

             Отметим, что управляющие элементы  не  получают  оповещающих
        сообщений по умолчанию. Вам нужно разрешить прием оповещающих со-
        общений, включив оповещения в маску событий управляющего  элемен-
        та:

             R.Assign(5, 2, 35, 3);
             Control := New(PPickLine, Init(R, 30));
             Control^.EventMask := Control^.EventMask or evBroadcast;
             Insert(Control);



         B.Pascal 7 & Objects/TV#1   - 269 -

                Использование управляющих элементов блока списка
        ─────────────────────────────────────────────────────────────────

             Объект блока   списка   TListBox   -  это  полезный  потомок
        TListViewer, который хранит список элементов в строковом  наборе.
        Во многих  случаях  вы  можете использовать заданный по умолчанию
        объект блока списка без модификаций.  Если у вас есть список, ко-
        торый не хранит свою  информацию в виде простых строк,  то вы мо-
        жете создать другие виды блока списка.

             Чтобы использовать заданный по умолчанию объект блока  спис-
        ка, сделайте следующее:

             - постройте список строк;
             - постройте блок списка;
             - присвойте список блоку;
             - задайте и считайте значения управляющих элементов.

                             Построение списка строк
        ─────────────────────────────────────────────────────────────────

             По умолчанию объекты блока списка  ожидают  использования  в
        качестве списков элементов строковых наборов. Поле Field указыва-
        ет на соответствующий список типа  PCollection,  хотя  вы  можете
        присвоить блоку списка любой вид набора.

             Однако, если вы используете что-то отличное от набора строк,
        то нужно переопределить метод GetText блока списка  для  возврата
        строки на основе заданного в наборе элемента.  Например, если ваш
        набор содержит числа,  то метод GetText переопределяется для пре-
        образования чисел  в строки,  так что блок списка сможет выводить
        их на экран.



         B.Pascal 7 & Objects/TV#1   - 270 -

                             Построение блока списка
        ─────────────────────────────────────────────────────────────────

             Построение объекта блока списка требует трех параметров: ог-
        раничивающего прямоугольника,  числа столбцов в блоке и указателя
        на вертикальную полосу прокрутки:

             constructor TListBox.Init(var Bounds: TRect; ANumCols: Word;
                                       AScrollBar: PScrollBar);

             Список блока списка  не  является  частью  конструктора.  Вы
        строите только часть, касающуюся элемента просмотра. Присваивание
        списка - это отдельный шаг.

                        Присваивание списка блоку списка
        ─────────────────────────────────────────────────────────────────

             После создания отображаемого элемента блока списка вы можете
        присвоить его списку элементов. Объекты блока списка имеют вирту-
        альный метод NewList, который позволяет вам в любое время присво-
        ить блоку списка список. NewList уничтожает любой уже присвоенный
        список, а затем назначает в качестве текущего списка новый набор,
        настраивая диапазон блока списка и перемещая фокус на первый эле-
        мент в списке.

             constructor TPickWindow.Init;
             var
               R: TRect;
               Control: PView;         { общий указатель для управляющих
                                         элементов }
               ScrollBar: PScrollBar;  { указатель на полосу прокрутки
                                         блока списка }
             begin
               R.Assign(0, 0, 40, 15); { назначение границ окна }
               inherited Init(R, 'Окно списка выбора'); { построение
                                         окна }
               Options := Options or ofCentered; { центрировать окно }
               R.Assign(5, 2, 35, 3);  { границы для вывода строки }
               Control := New(PPickLine, Init(R, 30)); { построение
                                         строки }
               Control^.EventMask := Control^.EventMask or evBroadCast;
               Insert(Control);        { включить строку ввода }
               R.Assign(4, 1, 13, 2);  { границы для метки }
               Insert(New(PLabel, Init(R, 'Выбран:', Control))));
                                       { включить метку }
               R.Assign(34, 5, 35, 11); { границы для полосы
                                         прокрутки }
               New(ScrollBar, Init(R)); { построение полосы прокрутки }
               Insert(ScrollBar);      { включить полосу прокрутки }
               R.Assign(5, 5, 34, 11); { границы для блока списка }
               Control := New(PListBox, Init(R, 1, ScrollBar));
                                       { построение блока списка }
               Insert(Control);        { включение блока списка }

         B.Pascal 7 & Objects/TV#1   - 271 -

               PListBox(Control)^.NewList(New(PCityColl, Init));
                                       { присваивание списка }
               R.Assign(4, 4, 12, 5);  { границы для метки }
               Insert(New(PLabel, Init(R, 'Элементы:', Control)));
                                       { включение метки }
               R.Assign(15, 12, 25, 14);  { границы для командной
                                         кнопки }
               Insert(New(PButton, Init(R, '~Q~uit', cmQuit,
                                        bfDefault)));
             end;

                   Примечание: Построение  блока  списка  и  присваивание
              списка реализует программа PICKLIST.PAS.

                  Установка и считывание значений блока списка
        ─────────────────────────────────────────────────────────────────

             Запись данных для установки или считывание блока списка пре-
        доставляется в виде двух частей - указателя на набор,  содержащий
        элементы блока  списка,  и  числа,  указывающего номер выбранного
        элемента. Например, вы можете определить тип записи:

             type
               TListBoxRec = record
                 Items: PStringCollection;
                 Selected: Integer;
              end;

             По умолчанию SetData для TListBox  вызывает  метод  NewList,
        передавая для  замены существующего списка указатель списка строк
        из записи данных, а затем устанавливает поле Focused в выделенный
        (имеющий фокус) элемент из записи.

                                   Вывод схемы
        ─────────────────────────────────────────────────────────────────

             Для вывода схем Turbo Vision  предусматривает  два  полезных
        объекта. Один  из них - это абстрактное средство просмотра схемы,
        а другой   выводит   схему   разветвленных   узлов.   Взаимосвязь
        абстрактного отображаемого элемента TOutlineViewer и используемо-
        го управляющего элемента TOutline аналогично взаимоотношению абс-
        трактных объектов TListViewer и TListBox.  TOutlineViewer опреде-
        ляет все поведение,  необходимое для вывода схемы,  но ничего  не
        знает о  выводимых  элементах.  TOutline - это специализированное
        средство просмотра схемы,  которое выводит строки в разветвленном
        дереве узлов.

             Чтобы использовать средства просмотра схемы, вы должны пони-
        мать следующие моменты:

             - основное поведение отображаемого элемента схемы;

             - специфические задачи схемы.

         B.Pascal 7 & Objects/TV#1   - 272 -


                      Основные моменты использования схемы
        ─────────────────────────────────────────────────────────────────

             Аналогично блоку списка,  большая часть поведения отображае-
        мого элемента схемы реализуется автоматически и выполняется мето-
        дами, наследуемыми из абстрактного объектного типа просмотра схе-
        мы. Основные действия включат в себя:

             - графическую иерархию;
             - расширение и сжатие;
             - итераторы;
             - поведение при установке фокуса и выборе;
             - обновление.



         B.Pascal 7 & Objects/TV#1   - 273 -

                              Графическая иерархия
        ─────────────────────────────────────────────────────────────────

             Средство просмотра схемы знает о том,  как выводить три вида
        графических линий для  представления  иерархических  взаимосвязей
        между элементами схемы. Переопределив метод GreateGraph, вы може-
        те изменить способ вывода схемы на экран с помощью этой графики.

                               Расширение и сжатие
        ─────────────────────────────────────────────────────────────────

             Пользователь может скрывать и раскрывать отдельные детали от
        элементов с подэлементами с помощью "мыши" или клавиатуры.  В не-
        которых случаях  желательно  настраивать  вывод  под  управлением
        программы, вызывая для этого методы Adjust и ExpandAll.

                               Итерация элементов
        ─────────────────────────────────────────────────────────────────

             Отображаемые элементы  схемы имеют методы итератора с именем
        FirstThat и ForEach,  которые работают аналогично соответствующим
        методам TGroup.  Средства просмотра схемы применяют итераторы для
        внутреннего использования,  но вы можете найти для  них  в  своем
        приложении другое использование.

                    Поведение при перемещении фокуса и выборе
        ─────────────────────────────────────────────────────────────────

             Когда элемент в схеме получает фокус, обработчик событий вы-
        зывает метод с именем Focused.  Когда пользователь выбирает  эле-
        мент, обработчик событий вызывает метод Selected.  Если при изме-
        нении фокуса или выбора пользователя вам нужно выполнить  конкре-
        тные действия, вы можете переопределить эти методы.

                                Обновление схемы
        ─────────────────────────────────────────────────────────────────

             При изменении информации в схеме  вам  нужно  вызвать  метод
        Update. Update  обеспечивает вывод в отображаемом элементе макси-
        мального числа линий и синхронизацию полос прокрутки с выводимыми
        данными.

                   Использование отображаемых элементов схемы
        ─────────────────────────────────────────────────────────────────

             Чтобы использовать отображаемые элементы  схемы,  вы  должны
        понимать следующие задачи:

             - создание дерева схемы;
             - построение дерева схемы;
             - получение выбранного узла;
             - отмена схемы.

         B.Pascal 7 & Objects/TV#1   - 274 -


                              Создание дерева схемы
        ─────────────────────────────────────────────────────────────────

             Чтобы вывести на экран схему,  вы должны иметь для схемы де-
        рево элементов.  Дерево аналогично связанному  списку,  но  имеет
        ветви,  так что каждый узел в дереве содержит не только указатель
        на следующий элемент в списке,  но также  возможные  подэлементы.
        Эти подэлементы  называются дочерними узлами,  а узел с дочерними
        узлами называется родительским или порождающим узлом. Началом де-
        рева схемы является корневой узел, не имеющий родительского узла.
        Объект Outline выводит на экран дерево,  состоящее из узлов  типа
        TNode.

             TNode - это простейшая запись.  Она  содержит  указатель  на
        следующий узел на том же уровне,  текстовую строку, которая выво-
        дится в схеме, и указатель на первый из его дочерних узлов, и бу-
        левский флаг, указывающий, является ли эти порожденные узлы види-
        мыми.

             Чтобы создать узел,  вызовите функцию NewNode. NewNode выде-
        ляет узел,  заданный строкой и указателями на список дочерних уз-
        лов, и следующий узел.  Чтобы построить дерево узлов,  нужно  ис-
        пользовать вложенные вызовы NewNode.

                     Построение отображаемого элемента схемы
        ─────────────────────────────────────────────────────────────────

             Построить отображаемый  элемент  схемы  достаточно   просто.
        Конструктор воспринимает только четыре параметра:  ограничивающий
        прямоугольник,  вертикальную  и горизонтальную полосы прокрутки и
        указатель на корневой узел дерева схемы.

                           Получение выделенного узла
        ─────────────────────────────────────────────────────────────────

             Поле Foc объекта отображаемого элемента схемы содержит цело-
        численный номер, показывающий, насколько далеко от вершины распо-
        ложен текущий элемент,  имеющий фокус. Если Foc равно 0, то фокус
        находится на  корне.  Метод GetNode воспринимает целое значение и
        возвращает указатель на  узел  в  этой  позиции.  Таким  образом,
        GetNode(Foc) возвращает выделенный (имеющий фокус) узел.

                                  Отмена схемы
        ─────────────────────────────────────────────────────────────────

             Деструктор TOutline берет на себя функции по уничтожению со-
        ответствующего дерева схемы перед уничтожением объекта отображае-
        мого элемента.  Узлы,  распределенные с помощью  NewNode,  должны
        уничтожаться вызовом    DisposeNode.    TOutline.Done    вызывает
        метод DisposeNode(Root),  который рекурсивно уничтожает весь спи-

         B.Pascal 7 & Objects/TV#1   - 275 -

        сок.

                    Считывание данных, вводимых пользователем
        ─────────────────────────────────────────────────────────────────

             Объекты строки ввода позволяют пользователю набирать  и  ре-
        дактировать отдельные  строки текста.  Чтобы получить более одной
        строки ввода,  используйте управляющий элемент  поля  примечания,
        который описывается  в Главе 15 "Редактор и текстовые управляющие
        элементы".

             Объекты строки ввода полностью  поддерживают  редактирование
        текста пользователем  с помощью "мыши" и клавиатуры,  вырезание и
        вставку с помощью буфера вырезанного текста (если он  имеется)  и
        различные виды проверки допустимости данных. В данном разделе по-
        ясняются основные  моменты  использования  управляющих  элементов
        строки ввода.  Проверка допустимости описывается в Главе 13 "Про-
        верка допустимости объектов".

             Чтобы использовать управляющий  элемент  строки  ввода,  вам
        нужно:

             - построить отображаемый элемент строки ввода;
             - устанавливать и считывать значение управляющего элемента;
             - манипулировать значениями управляющих элементов.

                  Построение управляющих элементов строки ввода
        ─────────────────────────────────────────────────────────────────

             Построение управляющих элементов строки ввода требует  зада-
        ния только двух параметров:  ограничивающего прямоугольника отоб-
        ражаемого элемента и максимальной длины строки ввода:

             constructor TInputLine.Init(var Bounds: TRect;
                                         AMaxLen: Integer);

             Строка ввода выделяет для максимальной строки пространство в
        динамически распределяемой памяти и устанавливает на  эту  память
        поле Data. Вы можете работать с Data^, как с обычной строкой. Ес-
        ли строка полностью не помещается в отображаемом элементе,  поль-
        зователь  может  для  прокрутки  текста  в  строке  ввода щелкать
        "мышью" на стрелках влево и вправо полосы прокрутки. Заметим, что
        размер  отображаемого  элемента должен допускать эти два дополни-
        тельных символа.

                   Установка значений и считывание строк ввода
        ─────────────────────────────────────────────────────────────────

             Запись данных  для  установки  и  считывания значения строки
        ввода представляет собой строку. Размер строки должен совпадать с
        максимальным размером текста строки ввода. Таким образом, если вы
        строите управляющий элемент строки ввода  с  максимальной  длиной
        10, запись данных должна иметь тип string[10].

         B.Pascal 7 & Objects/TV#1   - 276 -


                         Манипулирование строками ввода
        ─────────────────────────────────────────────────────────────────

             Отдельными полями объекта строки ввода вы можете манипулиро-
        вать непосредственно.  Например,  вы  можете  изменить содержимое
        текстовой строки,  на которую указывает Data,  хотя она не должна
        превышать длину,  заданную в MaxLen. MaxLen никогда не должна из-
        меняться после построения объекта,  поскольку конструктор исполь-
        зует MaxLen для освобождения выделенной Data памяти.

             Вы можете  также  непосредственно  изменить CurPos - позицию
        курсора в строке,  и FirstPos - индекс первого  элемента  строки,
        выводимого в  отображаемом  элементе  (который изменяется по мере
        прокрутки текста пользователем).  Изменять поля SelStart и SelEnd
        изменять не следует. Если вам нужно изменить выбранный текст, ис-
        пользуйте метод SelectAll.

                            Использование протоколов
        ─────────────────────────────────────────────────────────────────

             Протоколы позволяют пользователю легко вызвать в строку вво-
        да  предыдущие  записи.  Сам  управляющий  элемент протокола типа
        THistory - это небольшой отображаемый элемент, расположенный пос-
        ле  строки ввода.  Когда пользователь щелкает на списке протокола
        "мышью",  объект протокола выводит на экран список предыдущих за-
        писей   в   средстве   просмотра   протокола  в  окне  протокола.
        THistoryViewer и THistoryWindow обрабатываются объектом протокола
        автоматически,  поэтому  вам  не требуется работать с ними непос-
        редственно.

             Стандартный объект  приложения  инициализирует  протокольную
        систему в процессе собственной инициализации, когда вызывает про-
        цедуру InitHistory. После этого вы можете привязать списки прото-
        кола к любым строка ввода вашего приложения.

             Чтобы использовать списки протокола, вам нужно понимать сле-
        дующие задачи:

             - определение списка протокола;
             - построение отображаемого элемента протокола.

         B.Pascal 7 & Objects/TV#1   - 277 -


                          Определение списков протокола
        ─────────────────────────────────────────────────────────────────

             Для подсистемы протокола  приложения  резервируется  область
        памяти в  блоке протокола.  Список протокола состоит из строковых
        элементов и соответствующих числовых идентификаторов в блоке про-
        токола.

             Когда пользователь  щелкает  "мышью" в отображаемом элементе
        протокола для вывода на экран протокола для заданной строки  вво-
        да, Turbo Vision просматривает блок протокола в поиске всех запи-
        сей, связанных с конкретным идентификатором протокола для  данной
        строки ввода и выводит их в окне протокола.



         B.Pascal 7 & Objects/TV#1   - 278 -

                           Управление блоком протокола
        ─────────────────────────────────────────────────────────────────

             Протокол действует как список с дисциплиной FIFO (первым по-
        шел - первым вышел).  При наличии места в блоке протокола к блоку
        добавляются новые элементы. Когда блок заполняется, наиболее ста-
        рые элементы протокола освобождают место для новых.

             Так как все списки протокола совместно используют один и тот
        же блок, часто используемый список протокола вызывает прокрутку в
        блоке элементов из других списков.  Если в приложении вы собирае-
        тесь использовать множество различных  списков  протокола,  перед
        инициализацией приложения     увеличьте    значение    переменной
        HistorySize. HistorySize определяет размер блока протокола.

                   Примечание: Переменные  блока  протокола  и процедуры,
              которые с ними работают, содержатся в модуле HistList.

             Вместе с  объектами  приложения вы можете сохранять и считы-
        вать свои объекты приложения в потоке.  Процедуры StoreHistory  и
        LoadHistory берут на себя заботу обо всех деталях.

                   Построение отображаемого элемента протокола
        ─────────────────────────────────────────────────────────────────

             Построение отображаемого элемента протокола требует указания
        только трех параметров: ограничивающего прямоугольника, указателя
        на соответствующую строку ввода и идентификатора списка  протоко-
        ла.

             constructor THistory.Init(var Bounds: TRect;
                                   ALink: PInputLine; AHistoryuID: Word);

             Связанной строкой ввода является обычно строка,  примыкающая
        к отображаемому элементу протокола. Идентификатор протокола - это
        число,  которое вы хотите связать с вводимыми в строке ввода эле-
        ментами. Различные строки ввода с помощью одного и того же номера
        идентификатора могут  совместно использовать один и тот же список
        протокола.  Если вы хотите обеспечить,  чтобы каждая строка ввода
        имела собственный список протокола,  убедитесь,  что используются
        уникальные идентификаторы протокола.

             После построения и включения отображаемого элемента протоко-
        ла, управление списком протокола и связь  его  с  соответствующей
        строкой ввода выполняется автоматически.  Список протокола посто-
        янный. Если вы уничтожите объект  протокола  и  построите  другой
        отображаемый элемент протокола с тем же идентификатором,  все ра-
        нее введенные в протокол элементы сохранятся там,  пока в резуль-
        тате прокрутки не выйдут из списка протокола.

         B.Pascal 7 & Objects/TV#1   - 279 -

                           Метки управляющих элементов
        ─────────────────────────────────────────────────────────────────

             Задание меток объектов с помощью TLabel выполняет две  функ-
        ции. Они обеспечивают описание другого управляющего элемента, та-
        кого как группа кнопок с зависимой фиксацией, и позволяют пользо-
        вателю выбирать управляющие элементы с помощью "мыши" или клавиа-
        туры без воздействия на выбранный управляющий элемент.

             Помеченные объекты всегда служат образцами других  управляю-
        щих элементов. Например, если в диалоговом окне у вас есть строка
        ввода, то нет указания того,  набор каких данных предполагается в
        не имеющей метки строке. Объекты меток обеспечивают идентифициру-
        ющий текст для другого управляющего элемента и позволяют  пользо-
        вателю выбирать  соответствующий управляющий элемент путем выбора
        метки. Если вы просто хотите вывести на экран в окне или в диало-
        говом  окне  некоторый  текст,  используйте  вместо  метки объект
        TStaticText или TParamText.

             Чтобы использовать объекты меток, вы должны понимать следую-
        щее:
             - построение объектов меток;
             - установка фокуса;
             - назначение символов сокращений.

                            Построение объектов меток
        ─────────────────────────────────────────────────────────────────

             Конструктор объектов  меток  очень  прост.  Он  воспринимает
        только три  параметра:  ограничивающий  прямоугольник,  текстовую
        строку для метки и указатель на  помеченный  управляющий  объект.
        Как показано в следующем примере,  типичный конструктор для метки
        следует за конструктором для соответствующего  управляющего  эле-
        мента:

             constructor TYourDialog.Init(var Bounds: TRect;
                                          ATitle: TTitleStr);
             var
               R: TRect;
               Control: PView;
             begin
               inherited Init(Boundfs, ATitle);
               R.Assigne(10, 2, 40, 3);
               Control := New(PInputLine, Init(R, 30));
                                    { построение управляющего элемента }
               Insert(Control);     { включение управляющего элемента }
               R.Assign(1, 2, 10, 3);
               Insert(New(PLabel, Init(R, 'Flavor:', Control)));
                                     { привязка метки }
             end;

         B.Pascal 7 & Objects/TV#1   - 280 -

             Заметим, что присваивать объект метки переменной не требует-
        ся, поскольку включение его в диалоговое окно делает его  отобра-
        жаемым подэлементом, который при вызове деструктора будет уничто-
        жаться объектом диалогового окна.

                      Выбор управляющих элементом с метками
        ─────────────────────────────────────────────────────────────────

             Сами метки никогда не получают фокус ввода,  поскольку поль-
        зователь не может реально взаимодействовать с меткой. Когда поль-
        зователь щелкает  "мышью"  на  метке или выбирает эту метку с по-
        мощью клавиши-сокращения, соответствующий управляющий элемент по-
        лучает фокус,  а соответствующая метка выводится как активная.  В
        итоге, если  пользователь  выбирает  соответствующий  управляющий
        элемент, передавая ему фокус,  то соответствующая метка принимает
        оповещение cmReceivedFocus,  распознает,  что оно пришло от соот-
        ветствующего управляющего элемента,  и снова выводится как актив-
        ная.

             Таким образом,  метки и соответствующие управляющие элементы
        всегда совместно выводятся как выбранные или невыбранные. С точки
        зрения пользователя они представляют собой единый блок.

                          Назначение клавиш-сокращений
        ─────────────────────────────────────────────────────────────────

             При присваивании  текста в объекте метки вы можете вывести с
        подсветкой символ, используемый в качестве сокращения. Будьте ак-
        куратны и  назначения  нескольких управляющих элементов с одним и
        тем же сокращением,  так как  при  нажатии  пользователем  клави-
        ши-сокращения будет выбираться только первый элемент в Z-последо-
        вательности.

         B.Pascal 7 & Objects/TV#1   - 281 -

─────────────────────────────────────────────────────────────────────────
                     ГЛАВА 13. Проверка допустимости данных
        ─────────────────────────────────────────────────────────────────

             Turbo Vision  представляет  вам  несколько  гибких  способов
        проверки допустимости информации,  набираемой пользователем в уп-
        равляющем элементе редактирования,  путем связи объектов проверки
        допустимости с  объектами  управляющих  элементов редактирования.
        Использование объектов проверки допустимости облегчает добавление
        механизма  проверки допустимости к существующим приложениям Turbo
        Vision или для изменения способа проверки в поле его данных.

             Данная глава  охватывает следующие темы,  относящиеся к про-
        верке допустимости:

             * Три вид проверки допустимости данных.
             * Использование объектов проверки допустимости.
             * Как работает проверка допустимости.

             Проверка допустимости обрабатывается  методом  Valid  интер-
        фейсных  объектов.  В любой момент вы можете проверить содержимое
        любого конкретного управляющего элемента редактирования или экра-
        на данных, вызвав метод Valid объекта, но Turbo Vision предусмат-
        ривает также механизм автоматизации проверки допустимости данных.
        В большинстве случаев проверка допустимости данных практически не
        требует от программиста никаких усилий.

                      Три вида проверки допустимости данных
        ─────────────────────────────────────────────────────────────────

             Существует три  различных типа проверки допустимости данных,
        и Turbo  Vision поддерживает их по-разному.  Этими  тремя  видами
        являются:

             * Фильтрация ввода.
             * Проверка допустимости каждого элемента.
             * Проверка допустимости полных экранов.

             Заметим, что  эти  методы  не являются взаимно-исключающими.
        Ряд стандартных средств проверки допустимости могут комбинировать
        в одном механизме проверки допустимости различные методы.

             Важно запомнить,  что проверка допустимости выполняется объ-
        ектом проверки допустимости,  а не объектом управляющего элемента
        редактирования. Если вы уже создали для особого назначения специ-
        ализированный управляющий  элемент  редактирования,  то  возможно
        сдублировали  возможность,  встроенную в управляющие элементы ре-
        дактирования и их средства проверки допустимости.

             В разделе данной главы "Как работают средства  проверки  до-

         B.Pascal 7 & Objects/TV#1   - 282 -

        пустимости" описываются различные способы, с помощью которых объ-
        екты управляющего элемента редактирования автоматически  вызывают
        объекты проверки допустимости.

                                Фильтрация ввода
        ─────────────────────────────────────────────────────────────────

             Простейший способ обеспечения включения в поле только допус-
        тимых данных состоит в обеспечении ввода пользователем только до-
        пустимых данных. Например, числовое поле ввода может быть ограни-
        чено вводом пользователем только цифровых данных.

             Объект фильтра проверки допустимости Turbo  Vision представ-
        ляет общий механизм, ограничивающий вид символов, которые пользо-
        ватель может  вводить  в данном управляющем элементе редактирова-
        ния. Объекты проверки допустимости рисунков могут также контроли-
        ровать форматирование  и  типы  символов,  которые может набирать
        пользователь.

                       Проверка допустимости каждого поля
        ─────────────────────────────────────────────────────────────────

             Иногда удобно  гарантировать, чтобы пользователь обеспечивал
        для конкретного поля допустимый ввод перед переходом к следующему
        полю. Этот подход часто называют "проверкой допустимости по табу-
        ляции", поскольку переход в новое поле обычно выполняется по кла-
        више Tab.

             В качестве примера можно привести приложение, которое выпол-
        няет поиск в базе данных,  где пользователь вводит в поле некото-
        рые виды ключевой информации, а приложение отвечает на это считы-
        ванием соответствующей записи и фильтрацией  остальных  полей.  В
        таком случае вашему приложению перед действием по клавише  требу-
        ется проверка,  что пользователь набрал в этом ключевом поле пра-
        вильную информацию.

                      Проверка допустимости полных экранов
        ─────────────────────────────────────────────────────────────────

             Проверить допустимость полных экранов вы можете  тремя  раз-
        личными способами:

             * Проверкой допустимости режимных окон.

             * Проверкой допустимости при изменении фокуса.

             * Проверкой допустимости по запросу.

                       Проверка допустимости режимных окон
        ─────────────────────────────────────────────────────────────────

             Когда пользователь закрывает режимное окно, оно перед закры-
        тием автоматически проверяет допустимость всех своих  подобластей

         B.Pascal 7 & Objects/TV#1   - 283 -

        просмотра (если закрывающей командой не была cmCancel).  Для про-
        верки допустимости  всех  подобластей  окно  вызывает метод Valid
        каждой подобласти,  и если каждый из них возвращает True, то окно
        можно  закрыть.  Если  любая  из  подобластей возвращает значение
        False, то окно закрыть нельзя.

             Пока пользователь  не обеспечит допустимые данные,  режимное
        окно с недопустимыми данными можно только отменить.

                   Проверка допустимости при изменении фокуса
        ─────────────────────────────────────────────────────────────────

             Как и для любого другого отображаемого элемента,  вы  можете
        изменить флаг параметров ofValidate.  Если вы устанавливаете без-
        режимное окно ввода данных,  то можете задать для  него  проверку
        допустимости подэлементов при потере им фокуса,  например,  когда
        пользователь выбирает другое окно с помощью "мыши". Задание флага
        ofValidate окна предотвращает перемещение к другому окну, которое
        может выполнять действия с введенными в данном окне ввода данными
        до того как вы их проверите.

                        Проверка допустимости по запросу
        ─────────────────────────────────────────────────────────────────

             В любой момент вы можете указать окну на необходимость  про-
        верки всех  его  подокон путем вызова метода Valid.  Valid по су-
        ществу спрашивает  окно "Если сейчас будет дана команда закрытия,
        являются ли все поля допустимыми?" Метод Valid обычно  вызывается
        с  параметром cmClose.  Окно вызывает методы Valid всех своих до-
        черних окон в Z-последовательности и возвращает  True,  если  все
        они возвращают значение True.

             Вызов Valid не обязывает вас фактически закрывать окно. Нап-
        ример, вы можете вызвать Valid(cmClose) , когда пользователь "на-
        жимает" командную кнопку Save (Сохранение),  обеспечивая проверку
        допустимости данных перед их сохранением.

             Вы можете проверить любое окно (режимное или безрежимное)  и
        в любое  время.  Однако  автоматическую проверку допустимости при
        закрытии имеют только режимные окна.  Если вы используете  безре-
        жимные окна ввода данных,  то нужно обеспечить,  чтобы приложение
        перед выполнением действий с введенными  данными  вызывало  метод
        Valid окна.

              Использование механизма проверки допустимости данных
        ─────────────────────────────────────────────────────────────────

             Использование объекта проверки допустимости данных с  управ-
        ляющим элементом редактирования требует двух шагов:

             * Построение объекта проверки допустимости.

             * Присваивание  объекта  проверки  допустимости управляющему

         B.Pascal 7 & Objects/TV#1   - 284 -

               элементу редактирования.

             После того,  как вы построите объект проверки допустимости и
        свяжите его с управляющим элементом редактирования, вам не потре-
        буется взаимодействовать с ним непосредственно.  Управляющий эле-
        мент редактирования знает,  когда вызывать методы проверки допус-
        тимости и в какие моменты.

                    Построение объектов проверки допустимости
        ─────────────────────────────────────────────────────────────────

             Так как объекты проверки допустимости не являются интерфейс-
        ными объектами,  их конструкторам  требуется  только  информация,
        достаточная для установки критерия проверки допустимости.  Напри-
        мер, объект проверки допустимости числового диапазона воспринима-
        ет два параметра - минимальное и максимальное значения в допусти-
        мом диапазоне:

             constructor TRangeValidator.Init(AMin, AMax: Integer);

                       Добавление к управляющим элементам
                  редактирования средств проверки допустимости
        ─────────────────────────────────────────────────────────────────

             Каждый управляющий элемент редактирования имеет поле с  име-
        нем Validator,  установленное  по умолчанию в nil,  которое может
        указывать на объект проверки допустимости. Если вы не присваивае-
        те объекта полю Validator,  то управляющий элемент  строки  ввода
        ведет  себя  так,  как  описано в Главе 12.  После присваивания с
        поValidator объекта  проверки  допустимости  управляющий  элемент
        строки  ввода автоматически проверяется им при обработке основных
        событий и при самом вызове для проверки допустимости.

             Обычно, как  показано  ниже,  объект  проверки  допустимости
        строится и присваивается в одном операторе:

             .
             .  { создание трехсимвольной строки ввода }
             .
             InputLine := New(PInputLine, Init(R, 3));
             InputLine^.SetValidator(New(PRangeValidator,
                                         Init(100, 999)));
             Insert(InputLine);     { включение в окно-владельца }
             .
             .
             .

                       Как работает проверка допустимости
        ─────────────────────────────────────────────────────────────────

             В Turbo  Vision предусмотрено несколько видов объектов  про-
        верки допустимости,  которые  должны охватывать большинство ваших
        потребностей по проверке данных.  Из абстрактных  типов  проверки

         B.Pascal 7 & Objects/TV#1   - 285 -

        допустимости вы  можете  также  построить свои собственные произ-
        водные типы.

             В данном разделе освещаются следующие темы:

             * Виртуальные методы объекта проверки допустимости.

             * Стандартные типы объекта проверки допустимости.

                      Методы объекта проверки допустимости
        ─────────────────────────────────────────────────────────────────

             Каждый объект проверки допустимости наследует от абстрактно-
        го объектного типа TValidator  четыре  важных  метода.  Различным
        образом  переопределяя  эти методы,  наследующие объекты проверки
        допустимости выполняют свои конкретные задачи по  проверке.  Если
        вы собираетесь модифицировать стандартные объекты проверки допус-
        тимости или написать собственные объекты  проверки  допустимости,
        то нужно понимать, что делает каждый из этих методов и как их ис-
        пользуют строки ввода.

             Этими четырьмя методами являются следующие:

             * Valid

             * IsValid

             * IsValidInput

             * Error

             Единственными методами,  вызываемыми вне  объекта,  являются
        Valid и IsValidInput.  Error и IsValid - единственные методы, вы-
        зываемые другими методами объекта проверки допустимости.

                          Проверка допустимости данных
        ─────────────────────────────────────────────────────────────────

             Основным внешним  интерфейсом  с объектами проверки допусти-
        мости данных является метод Valid. Аналогично методу Valid интер-
        фейсных объектов, Valid представляет собой булевскую функцию, ко-
        торая возвращает значение True,  если переданная ей строка содер-
        жит допустимые данные. Один из компонентов метода Valid управляю-
        щего элемента строки ввода является вызов метода Valid с передан-
        ным ему текущим текстом управляющего элемента строки ввода.

             При использовании  средств проверки допустимости с управляю-
        щими элементами  строки  ввода  вам никогда не требуется вызывать
        или переопределять метод Valid объекта проверки допустимости.  По
        умолчанию  Valid  возвращает  True,  если  возвращает  True метод
        IsValid. В противном случае для уведомления пользователя об ошиб-
        ке и возврата значения False вызывается Error.


         B.Pascal 7 & Objects/TV#1   - 286 -

                             Проверка полной строки
        ─────────────────────────────────────────────────────────────────

            Объекты проверки  допустимости  содержат  виртуальный   метод
        IsValid, который  воспринимает в качестве единственного аргумента
        строку и возвращает True,  если  строка  представляет  допустимые
        данные. IsValid - это метод,  который выполняет фактическую  про-
        верку допустимости,  так что если вы создаете собственные объекты
        проверки допустимости, то почти всегда переопределяете IsValid.

             Заметим, что метод IsValid не вызывается вами явно.  Исполь-
        зуйте для вызова IsValid метод Valid,  так  как  для  уведомления
        пользователя в  случае  возврата  методом  IsValid значения False
        Valid вызывает метод Error. Не путайте также проверку допустимос-
        ти сообщением об ошибке.

                      Проверка допустимости нажатий клавиш
        ─────────────────────────────────────────────────────────────────

             Когда объект управляющего элемента  редактирования  получает
        имеющее  для  него значение событие нажатия клавиши,  он вызывает
        метод IsValidInput объекта проверки  допустимости.  По  умолчанию
        методы IsValid всегда возвращают True.  Это означает, что воспри-
        нимаются все нажатия клавиш. Однако, наследующие объекты проверки
        допустимости  могут переопределять метод IsValidInput,  чтобы от-
        фильтровывать нежелательные нажатия клавиш.

             Например, средства проверки допустимости диапазона,  которые
        используются для числового ввода, возвращают из IsValidInput True
        только для цифр и символов '+' и '-'.

             IsValidInput воспринимает  два параметра.  Первый параметр -
        это параметр-переменная,  содержащая текущий текст ввода.  Второй
        параметр - это булевское значение,  указывающее, следует ли перед
        попыткой проверки допустимости применять к строке ввода  дополне-
        ние или заполнение. TPictureValidator - это единственный из стан-
        дартных объектов проверки допустимости, использующий второй пара-
        метр.

                         Сообщение о недопустимых данных
        ─────────────────────────────────────────────────────────────────

             Виртуальный метод Error уведомляет пользователя,  что содер-
        жимое управляющего элемента редактирования не прошло проверку до-
        пустимости. Стандартные  объекты  проверки  допустимости  в общем
        случае представляет простой блок сообщения,  уведомляющий пользо-
        вателя, что  содержимое ввода недопустимо,  и описывающее,  каким
        должен быть правильный ввод.

             Например, метод Error для  проверки  допустимости  диапазона
        создает блок сообщения,  указывающий,  что значение в управляющем
        элементе редактирования не находится между указанными минимальным
        и максимальным значениями.

         B.Pascal 7 & Objects/TV#1   - 287 -


             Хотя большинство  объектов проверки допустимости переопреде-
        ляют Error,  вам не следует вызывать его  непосредственно.  Метод
        Error вызывается  методом  Valid,  если  IsValid возвращает False
        (что является единственным моментом,  когда  необходимо  вызывать
        Error).

                   Стандартные средства проверки допустимости
        ─────────────────────────────────────────────────────────────────

             Turbo  Vision включает в себя шесть стандартных типов объек-
        тов проверки  допустимости,  включая  абстрактный объект проверки
        допустимости и следующие пять специальных типов таких объектов:

             * Фильтрация.

             * Проверка диапазона.

             * Проверка допустимости с просмотром.

             * Проверка допустимости с просмотром строк.

             * Проверка допустимости с просмотром шаблонов.

                    Абстрактный объект проверки допустимости
        ─────────────────────────────────────────────────────────────────

             Абстрактный тип TValidator  служит базовым  типом  для  всех
        объектов проверки допустимости, но сам по себе он не делает ниче-
        го полезного.  По существу,  TValidator - это объект проверки до-
        пустимости, для  которого  всегда допустим любой ввод:  IsValid и
        IsValidInput возвращают True,  а Error не выполняет никаких функ-
        ций.  Наследующие  типы переопределяют IsValid и/или IsValidInput
        для фактического определения того, какие значения являются допус-
        тимыми.

             Если никакие из других объектный типов проверки допустимости
        не годятся  в  качестве  исходных,  то  вы  можете   использовать
        TValidator  в  качестве отправной точки собственных объектов про-
        верки допустимости.

                                   Фильтрация
        ─────────────────────────────────────────────────────────────────

             Фильтрующие объекты проверки допустимости - это простая реа-
        лизация средств проверки допустимости,  при  которой  проверяется
        только  набираемый  пользователем ввод.  Конструктор фильтрующего
        объекта проверки допустимости воспринимает один параметр -  набор
        допустимых символов:

             constructor TFilterValidator.Init(AValidChars: TCharSet);

             TFilterValidator переопределяет  IsValidInput  для  возврата

         B.Pascal 7 & Objects/TV#1   - 288 -

        True только в том случае, если все символы в текущей строке ввода
        содержатся в наборе символов,  переданных конструктору. Управляю-
        щие элементы редактирования включают символы только в том случае,
        если IsValidInput возвращает True,  так что нет необходимости пе-
        реопределять IsValid.  Поскольку  символы  проходят  через фильтр
        ввода, полная строка допустима по определению.

             Потомки TFilterValidator,  такие как TRAngeValidator,  могут
        сочетать фильтрацию ввода с другими проверками завершенной  стро-
        ки.

                               Проверка диапазона
        ─────────────────────────────────────────────────────────────────

             Объект проверки  допустимости диапазона TRangeVaidator - это
        потомок TFilterValidator, которые воспринимают только числа и до-
        бавляют к  итоговым  результатам проверку диапазона.  Конструктор
        воспринимает два параметра, определяющие минимальное и максималь-
        ное допустимое значение:

             constructor TRangeValidator.Init(AMin, AMax: Integer);

             Объект проверки  допустимости  диапазона сам строит числовое
        средство проверки-фильтрации,   воспринимающее    только    цифры
        '0'..'9' и  символы  плюса и минуса.  Таким образом,  наследуемый
        IsValidInput обеспечивает  отфильтровывание  только  цифр.  Затем
        TRangeValidator переопределяет  IsValid,  чтобы он возвращал True
        только если введенные числа находятся в допустимом диапазоне, оп-
        ределяемом в  конструкторе.  Метод  Error выводит блок сообщения,
        указывающий, что введенное значение находится вне диапазона.

                       Проверка допустимости с просмотром
        ─────────────────────────────────────────────────────────────────

             Абстрактный объект  проверки   допустимости   с   просмотром
        TLookupValidator обеспечивает основу для общего типа объекта про-
        верки допустимости,  который для определения допустимости сравни-
        вает введенное значение со списком воспринимаемый элементов.

             TLookupValidator -  это абстрактный тип,  который никогда не
        используется сам по себе,  но служит важным изменением и дополне-
        нием к стандартному объекту проверки допустимости.

                   Примечание: Пример  работы  такого  объектного типа вы
              можете найти в разделе по преобразованию строк.

             Новый метод,  вводимый объектом TLookupValidator  называется
        Lookup. По умолчанию Lookup возвращает значение False, но при об-
        разовании производного абстрактного объекта проверки допустимости
        c просмотром  вы можете переопределить Lookup для сравнения пере-
        данной строки со списком и возвращать True,  если строка содержит
        допустимую запись.


         B.Pascal 7 & Objects/TV#1   - 289 -

             TLookupValidator переопределяет  IsValid  для  возврата True
        только если Lookup также возвращает  True.  В  наследующих  типах
        проверки  допустимости с просмотром вам следует переопределять не
        IsValid, а Lookup.

                                 Просмотр строк
        ─────────────────────────────────────────────────────────────────

             Рабочий пример объекта проверки допустимости с  преобразова-
        нием представляет TStringLookupValidator, сравнивающий переданную
        из управляющего элемента редактирования  строку  с  элементами  в
        списке строк.  Если переданная строка содержится в списке,  метод
        объекта проверки  допустимости  с  просмотром  строки  возвращает
        True. Конструктор  воспринимает только один параметр - список до-
        пустимых строк:

             constructor TStringLookupValidator.Init(AString:
                                                      PStringCollection);

             Чтобы после построения объекта проверки допустимости с прос-
        мотром использовать другой список строк,  передайте новый  список
        методу NewStringList объекта проверки допустимости (который унич-
        тожает старый список и задает новый).

             TStringLookupValidator переопределяет методы Lookup и Error,
        так что Lookup возвращает True, если переданная строка содержится
        в наборе строк, а Error выводит на экран блок сообщения, указыва-
        ющий, что строка отсутствует в списке.

                        Проверка допустимости по шаблону
        ─────────────────────────────────────────────────────────────────

             Объекты проверки  допустимости с шаблоном сравнивают строки,
        набранные пользователем,  с шаблоном, описывающим формат допусти-
        мого ввода.  Применяемые  шаблоны совместимы с теми,  которые ис-
        пользуются для контроля ввода в реляционной базе  данных  Paradox
        фирмы Borland.  При  построении  объекта проверки допустимости по
        шаблону используется два параметра: строка, содержащая образ шаб-
        лона, и  булевское значение,  указывающее,  нужно ли заполнять по
        шаблону литеральные строки.

             constuctor TPXPictureValidator.Init(const APic: String;
                                               AAutoFill: Boolean);

             TPPXictureValidator переопределяет   Error,  IsValidInput  и
        IsValid и добавляет новый метод  Picture.  Изменения  в  Error  и
        IsValid просты:  Error выводит на экран блок сообщения, указываю-
        щий,  какой формат должна иметь строка, а IsValid возвращает True
        только если True возвращается функцией Picture, позволяя получать
        новые производные типы проверки допустимости по шаблону путем пе-
        реопределения только метода Picture.  IsValidInput проверяет сим-
        волы по мере набора их пользователем, допуская только те символы,
        которые  разрешены  в шаблоне формата,  и возможно дополняя лите-

         B.Pascal 7 & Objects/TV#1   - 290 -

        ральные символы из шаблона.

             Метод Picture  пытается сформатировать заданную строку ввода
        в соответствии с шаблоном формата и возвращает  значение,  указы-
        вающее степень успеха: полный, неполный или ошибка.

         B.Pascal 7 & Objects/TV#1   - 291 -

─────────────────────────────────────────────────────────────────────────
                        ГЛАВА 14. Палитры и выбор цветов
        ─────────────────────────────────────────────────────────────────

              Никто не  может сказать,  какой из цветов является "наилуч-
        шим" для экрана компьютера.  Вместо того,  чтобы жестко  задавать
        цвета для элементов экрана,  Turbo Vision позволяет программистам
        и пользователям изменять значения отображаемых элементов.  Данная
        глава охватывает два средства Turbo Vision, которые вы должны по-
        нимать для работы с цветами - палитры  цветов  и  объекты  выбора
        цветов.

                           Использование палитр цветов
        ─────────────────────────────────────────────────────────────────

             Вместо задания цвета каждого отображаемого элемента в  вашем
        приложении Turbo  Vision  использует  для отображения всех цветов
        всех элементов палитру цветов  в  объекте  приложения.  Например,
        когда вы создаете строку меню,  вам не нужно сообщать ей, в каком
        цвете вы хотите ее вывести. Она получает нужную информацию из па-
        литры цветов приложения.  Если вы изменяете этот цвет,  помещая в
        палитру другую информацию,  то будет изменяться цвет каждого меню
        в прикладной программе. Если вы хотите получить единственный эле-
        мент, цвет которого отличается от всех  других  меню,  вы  можете
        отобразить его в другую запись палитры,  после чего он будет спе-
        циальным, не влияя на другие цвета.

             Единственный случай,  когда вам придется позаботиться о  па-
        литрах цветов,  это написание методов Draw. Draw - это единствен-
        ный метод, который помещает информацию на экран.

             Остальная часть этой главы охватывает следующие темы:

             - что такое палитры цветов;
             - использование цветов по умолчанию;
             - изменение цветов, задаваемых по умолчанию;
             - определение новых цветов;
             - определение палитр для новых отображаемых элементов.

                            Что такое палитры цветов?
        ─────────────────────────────────────────────────────────────────

             При написании для отображаемого элемента Turbo Vision метода
        Draw вам не нужно задавать фактический цвет, который он будет ис-
        пользовать. Вместо  этого  вы  вызываете метод GetColor,  который
        запрашивает владельца отображаемого элемента,  какой цвет он дол-
        жен иметь.  Таким образом,  отображаемый элемент должен знать,  о
        каком виде цветов он должен запрашивать своего владельца.

             Палитра для отображаемого элемента содержит записи для  каж-

         B.Pascal 7 & Objects/TV#1   - 292 -

        дой части отображаемого элемента, которая выводится своим цветом.
        Например, палитра объекта окна имеет запись для рамки, когда окно
        активно, другую  запись  для  рамки неактивного окна,  запись для
        пиктограммы рамки,  двух  полос прокрутки и две записи для текста
        прокрутки.  Как вы увидите, ни одна из этих записей на самом деле
        не является цветом, а указывает, где найти цвет.

                             Пример простой палитры
        ─────────────────────────────────────────────────────────────────

             Перед тем  как  рассматривать  более сложные палитры цветов,
        рассмотрим простейшую. Палитра TScroller выглядит следующим обра-
        зом:
             CScroller = #6#7;

             Палитры цветов фактически хранятся в строках Паскаля, поэто-
        му они могут быть гибкими массивами переменной длины. Таким обра-
        зом, CScroller представляет собой двухсимвольную строку,  которую
        вы можете посчитать за две позиции палитры.

             Формат палитры TScroller определяется следующим образом:

             { Палитра          }
             { 1 = Нормальный   }
             { 2 = Подсвеченный }

             Однако, полезнее рассмотреть его со следующей точки зрения:

                         1   2
                       ┌───┬───┐
             CScroller │ 6 │ 7 │
                       └───┴───┘
                         │   │
                         │   └───────── Выделенный текст
                         └───────────── Нормальный текст

             Рис. 14.1 Палитра цветов TScroller.

             Это означает, что объект прокрутки способен выдавать изобра-
        жение двух видов текста: нормального и выделенного. Цвет каждого,
        заданный  по  умолчанию,  определяется  позициями в палитре.  При
        изображении нормального (обычного) текста метод Draw  должен  ис-
        пользовать первую  запись  палитры,  что означает,  что требуется
        цвет,  указанный в первой позиции палитры.  Для изображения выде-
        ленного текста будет используется вторая запись палитры.

                            Получение цветов палитры
        ─────────────────────────────────────────────────────────────────

             Чтобы получить  атрибут  цвета,  заданный  записью  палитры,
        отображаемый элемент  использует свой виртуальный метод GetColor.
        Этот метод воспринимает единственный параметр -  номер  записи  в
        палитре, и возвращает атрибут цвета для этой записи.  Чтобы полу-

         B.Pascal 7 & Objects/TV#1   - 293 -

        чить цветовой атрибут  нормального  текста,  метод  Draw  объекта
        прокрутки вызывает GetColor(1).

                                 Атрибуты цветов
        ─────────────────────────────────────────────────────────────────

             Атрибуты цветов,  используемые Turbo Vision, это те же стан-
        дартные байты видеоатрибутов, которые используются всеми текстами
        DOS, описанными на Рис.  14.2.  Младшие четыре бита  представляют
        фоновый цвет, следующие четыре бита представляют основной цвет, а
        следующие три бита - фоновый цвет. Старший бит - это атрибут мер-
        цания.
               7   6   5   4   3   2   1   0  <─ бит
             ┌───┬───┬───┬───┬───┬───┬───┬───┐
             │ B │ b │ b │ b │ f │ f │ f │ f │
             └───┴───┴───┴───┴───┴───┴───┴───┘

             Рис. 14.2 Отображение атрибутов цветов.

             Единственное место,  где вы можете найти в Turbo Vision  эти
        атрибуты - это палитра приложения. Все другие палитры представля-
        ют собой индексы в других палитрах,  которые в итоге указывают на
        запись палитры  приложения.  Это  отображение цветов поясняется в
        следующем разделе.

                            Отображение цветов палитр
        ─────────────────────────────────────────────────────────────────

             Записи палитры отображаемого элемента на самом деле не явля-
        ются цветами,  а представляют собой индексы в палитре цветов вла-
        дельца. Это важный пункт:  отображение цветов не имеет ничего об-
        щего с наследованием,  а относится к владению. Когда вы включаете
        отображаемый элемент  в группу,  его цвет определяется этой груп-
        пой, и так далее. Включение в другой вид группы (например, в окно
        вместо диалогового  окна)  может  в итоге совершенно изменить его
        цвет.

             Имейте в виду,  что при нормальном использовании вам  совсем
        не нужно думать об отображении цветов или о том, какого цвета бу-
        дет отображаемый элемент. Когда вы пишете методы Draw, то получа-
        ете цвета  палитры  отображаемого элемента путем вызова GetColor,
        так что вам не нужно беспокоиться о том,  как GetColor возвращает
        атрибут.



         B.Pascal 7 & Objects/TV#1   - 294 -

                    Простое использование отображения цветов
        ─────────────────────────────────────────────────────────────────

             Чтобы понимать, как GetColor возвращает цвет из палитры цве-
        тов, полезно  посмотреть,  что происходит при вызове метода.  Ис-
        пользуемый по умолчанию метод TScroller - это метод,  наследуемый
        из TView.  Он отображает весь текст в цвете, указанным первой за-
        писью палитры. Метод TView.Vierw показан в следующем примере:

             procedure TView.Draw;
             var B: TDrawBuffer;
             begin
               MoveChar(B, ' ', GetColor(1), Size.X);
                                                 { заполнить пробелами }
               WriteLine(0, 0, Size.X, Size.Y, B);
                         { заполнить весь отображаемый элемент линиями }
             end;

             Предположим на время, что объект прокрутки включен в обычное
        голубое окно, которое, в свою очередь, включено в объект приложе-
        ния. Отображение цветов соответствует цепочке принадлежности.


         B.Pascal 7 & Objects/TV#1   - 295 -


             Метод Draw получает цвет текста, первую запись объекта прок-
        рутки, вызывая метод GetColor(1).  GetColor воспринимает свой па-
        раметр и использует его в качестве индекса палитры. Первая запись
        в палитре содержит номер 6. 6 - это не цветовой атрибут, а индекс
        палитры. Поскольку  отображаемый  элемент  знает,  что  он должен
        отображаться посредством палитры владельца,  чтобы  найти  шестую
        запись в палитре владельца, он вызывает метод GetColor владельца.
        На Рис.  14.3 показана палитра TWindow и отображение  нормального
        цвета объекта прокрутки.

              ┌───────────────────────────── Рамка пассивна
              │   ┌───────────────────────── Рамка активна
              │   │   ┌───────────────────── Пиктограмма рамки
              │   │   │   ┌───────────────── Страница полосы прокрутки
              │   │   │   │   ┌───────────── Элементы управления полосой
              │   │   │   │   │              прокрутки
              │   │   │   │   │   ┌───────── Нормальный текст объекта
              │   │   │   │   │   │          прокрутки
              │   │   │   │   │   │   ┌───── Выбранный текст объекта
              │   │   │   │   │   │   │      прокрутки
              │   │   │   │   │   │   │   ┌─ Зарезервированный
              1   2   3   4   5   6   7   8
            ┌───┬───┬───┬───┬───┬───┬───┬───┐
            │ 8 │ 9 │ 10│ 11│ 12│ 13│ 14│ 15│ CBlueWindow
            └───┴───┴───┴───┴───┴─┬─┴───┴───┘
              ┌───────────────────┘
            ┌─┴─┬───┐
            │ 6 │ 7 │   CScroller
            └───┴───┘
              │   └─────────────────────── Выделенный текст
              └─────────────────────────── Нормальный текст

             Рис. 14.3 Отображение палитры элемента прокрутки в окно.

             Это процесс вызова методов GetColor владельцев отображаемого
        элемента продолжается,  пока не достигает отображаемого элемента,
        не имеющего владельца - объекта приложения.

             В палитре TWindow шестой позицией является число 13, которое
        служит указателем по палитре владельца окна  (оперативной  облас-
        ти),  которая,  в свою очередь, указывает на позицию в палитре ее
        владельца,  прикладной программы.  Объект TDeskTop имеет  палитру
        nil (нулевую), что означает, что она ничего не изменяет - ее мож-
        но представить себе как "прямую" или "явную" палитру,  в  которой
        первая позиция обозначается числом 1, вторая - числом 2 и т.д.


         B.Pascal 7 & Objects/TV#1   - 296 -


             Прикладная программа имеет большую палитру цветов,  содержа-
        щую позиции для всех элементов,  которые вы могли бы  вставить  в
        программу Turbo Vision.

             Приложение имеет палитру,  достаточно большую,  чтобы содер-
        жать записи всех элементов,  которые можете включить в приложение
        Turbo Vision. Ее 13-м элементом является $1E. Приложение заверша-
        ет цепочку (оно не имеет владельца, поэтому отображение палитр на
        нем заканчивается).  Рис.  14.4  описывает  отображение  элемента
        прокрутки через окно и оперативную область в приложение.

              1   2   3   4   5   6   7   8   9   10  11  12  13
            ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐ . . .
            │$71│$70│$78│$74│$20│$28│$24│$17│$1F│$1A│$31│$31│$1E│
            └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴─┬─┘ CColor
                                                              │
            ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬─┴─┐ . . .
            │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │ 10│ 11│ 12│ 13│
            └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴─┬─┘ nil
                                                              │
                                  ┌───────────────────────────┘
            ┌───┬───┬───┬───┬───┬─┴─┬───┬───┐
            │ 8 │ 9 │ 10│ 11│ 12│ 13│ 14│ 15│ CBlueWindow
            └───┴───┴───┴───┴───┴─┬─┴───┴───┘
              ┌───────────────────┘
            ┌─┴─┬───┐
            │ 6 │ 7 │   CScroller
            └───┴───┘
              │
              └─────────────────────────── GetColor(1)

             Рис. 14.4 Отображение нормального цвета текста  прокручивае-
        мого элемента.

             Теперь у вас осталось значение $1E,  которое является байтом
        признака текста, соответствующим цвету фона 1 и цвету изображения
        $E (или 14),  в результате чего вы получите желтые символы на го-
        лубом фоне.  Однако, вы не должны использовать терминологию "жел-
        тый на синем",  а указать, что текст должен быть изображен в нор-
        мальном цвете для текста в окне.



         B.Pascal 7 & Objects/TV#1   - 297 -

                              Алгоритм отображения
        ─────────────────────────────────────────────────────────────────

             Для выполнения  отображения цветов GetColor использует неко-
        торые сложные алгоритмы на ассемблере.  В следующем примере пока-
        зан эквивалентный метод на Паскале,  который более ясно показыва-
        ет, как происходит отображение цветов.

             function TView.NotGetColor(Color: Byte): Byte;
             var
               P: Palette;
               Curr: PView;
             begin
               Curr := @Self;       { начать с текущего элемента }
               While Curr <> nil do { продолжать, пока не nil }
               begin
                 P := Curr^.GetPalette; { получить палитру }
                 if P <> nil then   { если отображаемый элемент
                                      имеет палитру ...}
                    Color := Byte(P^(Color)); { ... получить индекс в
                                      палитре владельца }
                 Curr := Curr^.Owner; { указатель на отображаемый
                                      элемент владельца }
               end;
               NotGetColor := Color; { возвращает последний
                                      найденный цвет }
             end;

                  Переопределение цветов, заданных по умолчанию
        ─────────────────────────────────────────────────────────────────

             Очевидным способом изменения цветов является  изменение  па-
        литры. Если  вам  не нравится цвет обычного текста вашего объекта
        прокрутки, то вашим первым побуждением будет изменить  позицию  1
        (позиция цвета  нормального  текста) в палитре объекта прокрутки,
        например, с 6 на 5.  Нормальный текст объекта прокрутки будет за-
        тем отображен в окне в цветовой гамме элементов управления линей-
        кой прокрутки (голубой на синем по умолчанию).  Не забудьте:  5 -
        это не цвет! Вы указали лишь, что цвет нормального текста объекта
        прокрутки должен повторять цвет  полос  прокрутки,  расположенных
        вокруг него!

             Что же вам надо сделать,  если вы не хотите иметь  сочетание
        цветов желтый на голубом? Измените позицию палитры для нормально-
        го текста в  окне  в  TApplication.  Т.к.  эта  палитра  является
        последней, отличной от nil, то позиции в палитре прикладной прог-
        раммы будут появляться во всех видах в окне.

                   Примечание: Атрибуты цвета выводятся только в  объекте
              приложения,  поэтому это единственное место,  где вы можете
              изменить их.

         B.Pascal 7 & Objects/TV#1   - 298 -

                 Палитры - централизованная информация о цветах
        ─────────────────────────────────────────────────────────────────

             Централизованное управление атрибутами цветов из одного мес-
        та имеет определенный смысл. По-видимому, вы хотели бы, чтобы ва-
        ши  окна  выглядели похожими.  И конечно же не хотели бы отдельно
        задавать цвет каждого из них. Если вы позднее перемените свое на-
        мерение  (или  разрешите пользователям настройку цветов),  то вам
        придется изменять позиции для каждого окна.

             Кроме того,  объект прокрутки или другой  внутренний  объект
        может  не  заботиться о своей расцветке,  если он помещен не в то
        окно,  в которое вы ранее намеревались его  поместить.  Если  вы,
        например,  поместите объект прокрутки в окно диалога вместо окна,
        то он не будет (по умолчанию) иметь  ту  же  расцветку,  а  будет
        иметь расцветку нормального текста в окне диалога.

                            Изменение палитры цветов
        ─────────────────────────────────────────────────────────────────

             Для изменения палитры видимого элемента вам следует  переоп-
        ределить  его  метод GetPalette.  Чтобы создать новый тип объекта
        прокрутки,  изображение которого будет  выдаваться  с  расцветкой
        рамки  окна,  а не с расцветкой нормального текста,  объявление и
        реализация объекта должны выглядеть следующим образом:

             type
               TMyScroller = object(TScroller)
                 function GetPalette: PPalette; virtual;
               end;
             function TMyScroller.GetPalette: PPalette;
             const
               CMyScroller = #1#7;
               PMyScroller: string[Length(CMyScroller)] = CMyScroller;
             begin
               GetPalette := @PMyScroller;
             end;
             Единственное внесенное в TMyScroller изменение - это измене-
        ние первой записи в палитре объекта прокрутки с #6 на #1. Другими
        словами,  нормальный текст элемента прокрутки отображается вместо
        шестой  записи (нормальный текст прокрутки) в первую запись в па-
        литре окна (пассивная рамка).

             Имейте в  виду,  что  константа  палитры  является строковой
        константой, т.к. Turbo Vision использует тип String для представ-
        ления  палитр.  Это обеспечивает более простое оперирование с па-
        литрами,  т.к.  все строковые и подобные им функции  также  могут
        быть использованы с палитрами.

                   Примечание: Типы  объектов  TPalette и String являются
              полностью взаимозаменяемыми.

         B.Pascal 7 & Objects/TV#1   - 299 -

                               Расширение палитры
        ─────────────────────────────────────────────────────────────────

             При создании нового производного типа вам иногда нужно опре-
        делить новую для новых визуальных элементов запись палитры.  Нап-
        ример, вы можете создать новый вид  элемента  прокрутки,  который
        распознает не только нормальный и подсвеченный текст,  но и неко-
        торые другие виды выделенного текста.

             Расширение палитры требует трех шагов:

             - добавления элементов в палитру отображаемого элемента;

             - обеспечения наличия необходимых записей палитры в  объект-
               ных типах-владельцах;

             - пересмотр метода Draw для использования нового цвета.

                            Добавление записи палитры
        ─────────────────────────────────────────────────────────────────

             Расширить палитру отображаемого элемента достаточно  просто.
        Так как палитра представляет собой строку, то вы добавляете в ко-
        нец существующей палитры столько записей, сколько требуется.

             При добавлении новой записи палитры  нужно  рассмотреть  два
        случая:

             - использование  цвета,  который уже существует в другой па-
               литре;

             - создание нового вида цветового элемента.

                        Использование существующего цвета
        ─────────────────────────────────────────────────────────────────

             Использование уже существующего цвета - это простейший путь,
        поскольку вам не требуется изменять палитру владельца.  Например,
        чтобы третья  запись  элемента прокрутки использовала цвет полосы
        прокрутки окна владельца (четвертую запись в палитре окна), к су-
        ществующей палитре элемента прокрутки добавляется #4:

             const
                CMyScroller = CScroller + #4;

             Поскольку при этом используются цвета,  о которых уже  знает
        окно-владелец, вы можете пойти дальше и переписать метод Draw для
        использования третьего цвета элемента прокрутки.

                             Добавление нового цвета
        ─────────────────────────────────────────────────────────────────

             Если вы  хотите,  чтобы  палитра вашего нового отображаемого

         B.Pascal 7 & Objects/TV#1   - 300 -

        элемента использовала цвет, еще не определенный в палитре отобра-
        жаемого элемента-владельца, в палитру отображаемого элемента так-
        же нужно добавить новый элемент, но вместо указания на существую-
        щую запись вы указываете новую запись, которую добавили в отобра-
        жаемый элемент владельца.  Например, вы можете указать на девятую
        запись в палитре окна:

             function TMyScroller.GetPalette: PPalette;
             const
               CMyScroller = CScroller + #9;  { добавить к существующей
                                                палитре }
               P: string[Length(CMyScroller)] = CMyScroller;
             begin
               GetPalette := @P;              { ссылка на типизированную
                                                новую палитру }
             end;

             Суть в том,  что объект окна имеет только 8 записей, так что
        вам нужно  переопределить  метод  GetPalette  окна-владельца  для
        возврата палитры с новым девятым элементом.

                     Добавление записей в палитры владельцев
        ─────────────────────────────────────────────────────────────────

             Каждый раз когда вы создаете отображаемый  элемент,  который
        обращается к большему числу записей, чем палитра его отображаемо-
        го элемента-владельца имеет по умолчанию, убедитесь, что вы также
        расширили палитру отображаемого элемента-владельца.  Доступ к не-
        существующим записям палитры дает неопределенные результаты.

             Расширение палитры окна для новой палитры элемента  прокрут-
        ки, показанное в предыдущем примере, несколько более сложное, чем
        расширение палитры отображаемого  элемента  прокрутки,  поскольку
        фактически существует  три стандартных палитры окна - для голубо-
        го, серого и бирюзового окон.  Следующий пример  показывает,  как
        добавить ко всем трем палитрам девятую запись:

             function TMyWindow.GetPalette;
             const
               CMyBlueWindow = CBlueWindow + #64; { добавление девятой
                                                    записи }
               CMyCyanWindow = CBlueWindow + #65;
               CMyGrayWindow = CBlueWindow + #66;
               P: array[wpBlueWindow..wpGrayWindow] of
                     string[Length(CMyBlueWindow)] =
                          (CBlueWindow, CCyanWindow, CGrayWindow);
             begin
               GetPalette := @P[Palette]; { возврат на базе поля
                                            Palette }
             end;

             В зависимости от цветовой схемы окна,  эта новая девятая за-
        пись указывает на 64, 65 и 66 запись в палитре приложения. Но это

         B.Pascal 7 & Objects/TV#1   - 301 -

        снова новые записи:  используемая по умолчанию палитра приложения
        содержит только 63 записи, так что вам нужно также добавить новые
        записи в палитру приложения.

             Однако, в отличие от палитры окна, палитра приложения содер-
        жит фактически три различных палитры - одну для  цветной,  другую
        для черно-белой,  а третью - для монохромных систем. Поэтому, как
        показано в следующем примере,  модификация палитры  приложения  в
        этом  случае означает добавление к каждой из трех палитр трех но-
        вых записей.

             function TMyApplication.GetPalette: PPalette;
             const
               CMyColor = CColor + #$25#$50#$0F;
               CMyBlackWhite = CBlackWhite + #$0F#$0F#$0F;
               CMyMonochrome = CMonochrome + #$0F#$0F#$7F;
               P: array[apColor..apMonochrome] of string[Length(CMyColor)]
                        = (CMyColor, CMyBlackWhite, CMyMonochrome);
             begin
               GetPalette := @P[Palette]; { возврат на базе поля
                                            Palette }
             end;

             Третья запись объекта прокрутки  теперь  представляет  собой
        дополнительный цвет.   Если   вы  используете  этот  новый  метод
        GetPalette, применяя CMyColor с доступом к  девятому  элементу  в
        палитре владельца,  то убедитесь,  что владелец использует расши-
        ренную палитру,  и что приложение использует соответствующие рас-
        ширения. Если  вы пытаетесь получить доступ к девятому элементу в
        палитре из 8 элементов, то результат будет неопределенным.

                           Переписывание методов Draw
        ─────────────────────────────────────────────────────────────────

             После того как у вас будет палитра,  содержащая дополнитель-
        ные записи, вы можете переписать свой метод Draw, используя преи-
        мущества нового  цвета.  В  примере данной главы TMyScroller.Draw
        может теперь передавать GetColor любое значение в диапазоне  1..3
        и получить  допустимый  цвет.  Передача  любого  другого значения
        возвращает ошибочный атрибут, мерцающий белым на красном.

                         Изменение цветов пользователями
        ─────────────────────────────────────────────────────────────────

             Модуль ColorSel  Turbo  Vision обеспечивает диалоговое окно,
        которое вы можете включить в  свое  приложение,  чтобы  позволить
        пользователям изменять  цвета  палитры приложения.  Данный раздел
        описывает:

             - использование диалогового окна выбора цветов;

             - сохранение и восстановление цветов.


         B.Pascal 7 & Objects/TV#1   - 302 -

                           Использование TColorDialog
        ─────────────────────────────────────────────────────────────────

             Диалоговое окно  выбора цветов TColorDialog дает пользовате-
        лям ваших программ простой доступ к  палитре  цветов  приложения,
        что дает им возможность определить,  какие виды элементов они хо-
        тят изменить.  Передавая списки групп цветов и цветовых элементов
        в диалоговом  окне,  вы можете управлять тем,  какие элементы они
        могут изменять.

             Использование диалогового окна выбора цвета  предусматривает
        два шага:

             - определение групп цветов и элементов;

             - выполнение диалогового окна выбора цветов.

                     Определение цветовых групп и элементов
        ─────────────────────────────────────────────────────────────────

             Цветовые элементы - это просто имена,  которые вы даете раз-
        личным записям  палитры цветов.  Группы цветов представляют собой
        связанные списки элементов цветов, которые, в свою очередь, имеют
        имена. Функции Turbo Vision ColorItem и ColorGroup облегчают соз-
        дание таких списков.  Кроме того, модуль ColorSel предусматривает
        функции, которые возвращают список стандартных элементов, так что
        вам требуется только определить новые отображаемые  элементы  или
        расширить палитры     существующих.     Одна    такая    функция,
        MenuColorItems, которая определяет цветовые элементы для всех за-
        писей палитры, связанной с отображаемыми элементами меню, показа-
        на в в следующем примере.

             function MenuColorItems(const Next: PColorItem):
                                                         PColorItem;
             begin
               MenuColorItems :=
                    ColorItem('Normal',              2, { нормальный }
                    ColorItem('Disabled',            3, { запрещенный }
                    ColorItem('Shortcut',            4, { оперативная
                                                          клавиша }
                    ColorItem('Selected',            5, { выделенный }
                    ColorItem('Selected disabled',   6, { выделенный
                                                          запрещенный }
                    ColorItem('Shortcut selected',   7, { выделенная
                                                          оперативная
                    Next))))));                           клавиша }
             end;

             Как показано в следующем примере, комбинирую списки цветовых
        элементов,  вы можете создать список групп цветов и  передать  их
        затем конструктору диалогового окна выбора цвета.

             D := New(PColorDialog, Init('',

         B.Pascal 7 & Objects/TV#1   - 303 -

                    ColorGroup('Destop',        DesktopColorItem(nil),
                                { оперативная область }
                    ColorGroup('Menu',          MenuColorItem(nil),
                                { меню }
                    ColorGroup('Dialog Boxes',
                                { диалоговые окна }
                               DialogBoxColorItem(dpGrayDialog, nil)),
                    nil)))));

                           Выполнение диалогового окна
        ─────────────────────────────────────────────────────────────────

             После определения  групп  цветовых  элементов  вы  передаете
        конструктору TColotDialog этот список  и палитру для модификации.
        Часто вместо  передачи конструктору палитры Часто вместо передачи
        конструктору палитры при выполнении диалогового окна палитра  пе-
        редается ему в виде записи. Например, чтобы модифицировать палит-
        ру, используемую в данный момент в приложении, нужно сделать сле-
        дующее:;

             if ExecuteDialog(D, Application^.GetPalette) <> cmCancel
             then
               begin
                 DoneMemory;        { уничтожить все буферы групп }
                 ReDraw;            { отобразить приложение с новой
                                      палитрой }
             end;

                       Сохранение и восстановление цветов
        ─────────────────────────────────────────────────────────────────

             Приложение Turbo Vision сохраняет текущее  состояние  диало-
        гового окна выбора цвета в переменной ColorIndexes.  Чтобы сохра-
        нить текущие выбранные пользователем цвета, вы вызываете процеду-
        ру SaveIndexes.  Для восстановления предыдущего состояния вызыва-
        ется LoadIndexes. Обе указанные процедуры воспринимают единствен-
        ный параметр, задающие содержащий индексы цветов поток.

             Использование LoadIndexes  и StoreIndexes показано в примере
        программы TVDemo.



         B.Pascal 7 & Objects/TV#1   - 304 -

─────────────────────────────────────────────────────────────────────────
              ГЛАВА 15. Редактор и текстовые отображаемые элементы
        ─────────────────────────────────────────────────────────────────

             Для работы с текстом в вашем приложении Turbo Vision предус-
        матривает два вида объектов.  Текстовые отображаемые элементы до-
        пускают гибкий вывод текста,  в то время  как  объекты  редактора
        позволяют пользователю  вводить  и  модифицировать текст.  Данная
        глава охватывает следующие вопросы использование текстовых  отоб-
        ражаемых элементов:

             - базовый текстовый отображаемый элемент;
             - "немой" терминальный отображаемый элемент;
             - базовый текстовый редактор;
             - редактор примечаний;
             - файловый редактор;
             - буфер вырезанного текста редактора;
             - окно редактирования.

                    Что такое текстовый отображаемый элемент?
        ─────────────────────────────────────────────────────────────────

             Текстовые отображаемые  элементы  -  это   простые   потомки
        TScroller, связывающие устройство текстового файла с прокручивае-
        мым отображаемым элементом.  Turbo Vision определяет  абстрактное
        текстовое устройство в типе TTextDevice, который добавляет вирту-
        альные методы для считывания строк из текстового файла  и  записи
        строк в  этот  файл.  Тип TTextDevice сам по себе не представляет
        ничего полезного,  и создавать его экземпляры не требуется, но он
        обеспечивает  основу  для  более  полезных текстовых отображаемых
        элементов,   например,   терминального   отображаемого   элемента
        TTterminal.

               Использование терминального отображаемого элемента
        ─────────────────────────────────────────────────────────────────

             Терминальный отображаемый элемент определен типом  TTerminal
        и является  единственным типом текстового отображаемого элемента,
        предусмотренным в Turbo Vision.  Он обеспечивает  для  устройства
        текстового файла  прокручиваемый  отображаемый элемент с доступом
        типа "только запись". Возможно, вы найдете терминальные отобража-
        емые элементы наиболее полезными для целей отладки или отслежива-
        ния содержимого файла.

             Большая часть поведения терминального отображаемого элемента
        реализуется автоматически.  Если  вы знакомы с работой с устройс-
        твами текстовых файлов,  то иметь дело с TTerminal вам будет нет-
        рудно.

         B.Pascal 7 & Objects/TV#1   - 305 -


             Использование терминального  отображаемого  элемента предус-
        матривает три шага:

             - построение терминального отображаемого элемента;

             - присваивание текстового устройства;

             - запись в терминальный отображаемый элемент.

             Заметим, что хотя вы можете выполнять чтение из терминально-
        го отображаемого элемента, он всегда возвращает пустую строку.

                 Построение терминального отображаемого элемента
        ─────────────────────────────────────────────────────────────────

             Построение терминального отображаемого элемента лишь  слегка
        отличается от  построения других прокручиваемых отображаемых эле-
        ментов. Кроме ограничивающего прямоугольника и параметров  полосы
        прокрутки, конструктор воспринимает параметр типа Word,  задающий
        размер терминального буфера.

                               Управление буфером
        ─────────────────────────────────────────────────────────────────

             Фактическое управление  текстовым  буфером выполняет для вас
        TTerminal. Когда вы задаете размер буфера, TTerminal выделяет за-
        данное число байт в виде массива символов с завершающим нулем ти-
        па TTerminalBuffer.  Все записываемые в терминальный отображаемый
        элемент символы помещаются в этот буфер. При достижении конца бу-
        фера терминальный отображаемый элемент автоматически снова  пере-
        ходит к началу буфера,  отслеживая точку начала выводимого на эк-
        ран текста.

             TTerminal содержит несколько методов,  которые вы можете ис-
        пользовать для  определения  статуса  буфера.  Булевская  функция
        CanInsert указывает, приведет ли вставка заданного числа символов
        к выбрасыванию из буфера верхней строки. QueEmpty показывает, со-
        держит ли буфер какие-либо символы.  CalcWidth  возвращает  длину
        самой длинной строки в буфере.

                       Присваивание текстового устройства
        ─────────────────────────────────────────────────────────────────

             Перед тем как терминальный отображаемый элемент сможет взаи-
        модействовать с текстовым устройством,  вам нужно присвоить отоб-
        ражаемому элементу текстовое устройство.  Turbo Vision предусмат-
        ривает процедуру AssignDevice,  которая делает для вашего тексто-
        вого отображаемого элемента то же,  что делает  процедура  Assign
        для текстового файла.  Она связывает заданный файл с терминальным
        отображаемым элементом.  Это означает, что все последующие опера-
        ции ввода или вывода с текстовым файлом приведут к чтению из тер-
        минального отображаемого элемента или записи в него.

         B.Pascal 7 & Objects/TV#1   - 306 -


             Например, имея терминальный отображаемый элемент Terminal  и
        текстовый файл  TermText,  вы  присваиваете текстовому устройству
        терминальный отображаемый элемент:

             AssignDevice(TermText, Terminal);

                   Запись в терминальный отображаемый элемент
        ─────────────────────────────────────────────────────────────────

             Запись в терминальный отображаемый элемент аналогична записи
        на любое устройство  текстового  файла.  Вы  можете  использовать
        стандартные  процедуры  Write  и Writeln.  После вызова для связи
        устройства текстового файла с терминальный отображаемым элементом
        процедуры AssignDevice  весь вывод на устройство текстового файла
        появляется в терминальном отображаемом элементе.

             Заметим, что как и в  случае  любого  устройства  текстового
        файла для открытия файла вам нужно вызывать процедуру Rewrite или
        Reset. После  этого  вы  можете  вызывать  процедуры  Write   или
        Writeln, задавая идентификатор текстового устройства, например:

             AssignDevice(TermText, Terminal);
             Rewrite(TermText);
             Writeln(TermText, 'Это выводится в отображаемом элементе');

             Простая программа  следующего  примера перехватывает события
        "мыши" и записывает  координаты  щелчков  "мыши"  в  терминальном
        отображаемом элементе в окно.  Ту же программу вы найдете в файле
        TERMTEST.PAS на ваших дистрибутивных дисках.

             program TermTest;

             uses Objects, Views, App, Drives, TextView;

             type
               PTermWin = ^TTermWin;
               TTermWin = object(TWindow)
                   TermText: Text;
                   Terminal: PTerminal;
                   constructor Init;
                   procedure HandleEvent(var Event: TEvent); virtual;
               end;
               TTermApp = object(TApplication)
                 constructor Init;
               end;

             constructor TTermWin.Init;
             var
               R: TRect;
               HScrollBar, VScrollBar: PScrollBar;
             begin
               Desktop^.GetExtent(R);

         B.Pascal 7 & Objects/TV#1   - 307 -

               inherited Init(R, 'Terminal test window', wmNoNumber);
               R.Grow(-1, -1);
               HScrollBar := StandardScrollBar(sbHorizontal or
                                                    sbHandleKeyboard);
               Insert(HScrollBar);
               VScrollBar := StandardScrollBar(sbVertical or
                                                    sbHandleKeyboard);
               Invert(VScrollbar);
               New(Terminal, Init(R, HScrollBar, VScrollBar, 8192));
               if Application^.ValidView(Terminal) <> nil then
               begin
                 AssignDevice(TermText, Terminal);
                 Rewrite(TermText);
                 Invert(Terminal);
               end;
             end;

             procedure TTermWin.HandleEvent(var Event: TEvent);
             begin
               if Event.What and evMouseDown <> 0 then
               begin
                 if Event.Buttons and mbLeftButton <> 0 then
                      Write(TermText', 'Left  ')  { левая }
                 else Write(TermText', 'Right  ')  { правая }
                 Writeln(TermText,  '(', Event.Where.X, ',',
                                              Event.Where.Y, ')',);
               end;
               inherited HandleEvent(Event);
             end;

             constructor TTermApp.Init;
             var TextWin: PTermWin;
             begin
               inherited Init;
               New(TextWin, Init);
               if ValidView(TextWin) <> nil then InsertWindow(TextWin);
             end;

             var TermApp: TTermApp;
             begin
               TermApp.Init;
               TermApp.Run;
               TermApp.Done;
             end.

                         Использование объекта редактора
        ─────────────────────────────────────────────────────────────────

             Turbo Vision определяет объектный тип редактора TEditor, ре-
        ализующий небольшой и быстрый 64-килобайтовый редактор с поддерж-
        кой "мыши", операций с буфером вырезанного текста, отменой, авто-
        отступом и режимами замены, привязкой клавиш WordStar и функциями
        поиска/замены.

         B.Pascal 7 & Objects/TV#1   - 308 -


             В данном разделе поясняется следующее:

             - как работает редактор;

             - использование меню Edit;

             - привязка клавиш WordStar;

             - параметры редактора;

             - поиск и замена;

             - использование индикаторов и полос прокрутки.

                              Как работает редактор
        ─────────────────────────────────────────────────────────────────

             Вникать во внутреннюю работу объекта редактора вам обычно не
        требуется.  В наиболее общих случаях, таких как файловый редактор
        и   поле   примечания   в  окне,  используются  два  типа-потомка
        TFileEditor и TMemo. Оба они описываются в данной главе.

             TEditor реализует редактор с "буферным промежутком". Это оз-
        начает, что  он  записывает  свой  текст двумя частями с разрывом
        между ними.  Текст перед курсором записывается в начало буфера, а
        текст после курсора - в конец.  Пробел между ними называется про-
        межутком.

             Вставляемые в редакторе символы попадают в начало  промежут-
        ка. Удаляемые  символы остаются в буфере,  но в конце промежутка.
        Редактор поддерживает отмену вставки и удаления, отслеживая число
        удаляемых и вставляемых символов.  При запросе на отмену редактор
        удаляет вставленные символы, перемещает удаленные символы в нача-
        ло промежутка и позиционирует курсор после ранее удаленного текс-
        та.



         B.Pascal 7 & Objects/TV#1   - 309 -

                                  Работа буфера
        ─────────────────────────────────────────────────────────────────

             Чтобы увидеть,  как работает буфер, посмотрите на Рис. 15.1,
        где показан   буфер   редактора   с   вновь   набранным   текстом
        'abcdefghijkxxxopqrstuvwxyz'

                                                            CurPtr
                                                            v
                                                            │<──GapLen─>│
        ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
        │a│b│c│d│e│f│g│h│i│j│k│x│x│x│o│p│q│r│s│t│u│v│w│x│y│z│ │ │ │ │ │ │
        └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
        │<─────────────────────BufLen──────────────────────>│           │
        │<──────────────────────────────BufSize────────────────────────>│

             Рис. 15.1 Буфер со вставленным текстом.

             BufSize - это размер буфера, который задается при построении
        объекта редактора. CurPtr указывает позицию курсора, GapLen - это
        длина промежутка, а BufLen - общее число символов в буфере. Сумма
        GapLen и  BufLen  всегда равна BufSize.  Если вы поместите курсор
        непосредственно после символов 'xxx',  то буфер  будет  выглядеть
        следующим образом:

                                    CurPtr
                                    v
                                    │<──GapLen─>│
        ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
        │a│b│c│d│e│f│g│h│i│j│k│x│x│x│ │ │ │ │ │ │o│p│q│r│s│t│u│v│w│x│y│z│
        └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
        │<──────────────────────────────BufSize────────────────────────>│
        │<─────────────────────────>│     +     │<─────────────────────>│
                                      = BufLen

             Рис. 15.2 Буфер после перемещения курсора.

             Заметим, что промежуток перед  курсором  сохраняется,  давая
        возможность быстро вставлять символы без перемещения текста.



         B.Pascal 7 & Objects/TV#1   - 310 -

                                 Удаление текста
        ─────────────────────────────────────────────────────────────────

             Пользователь может удалять текст,  нажимая перед ним клавишу
        Backspace, удалять  символы перед курсором с помощью клавиши Del,
        либо выделять блок текста и нажимать Del.  Ваша  программа  может
        удалить выделенный блок с помощью вызова метода DeleteSelect.

             Если вы удаляете 'xxx' с помощью клавиши Backspace, редактор
        перемещает символы к концу промежутка,  и курсор  перемещается  в
        обратном направлении.  В поле delCount записывается число удален-
        ных  символов.  Состояние буфера после удаления 'xxx' показано на
        Рис. 15.3.

                              CurPtr
                              v
                              │<─────GapLen────>│
        ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
        │a│b│c│d│e│f│g│h│i│j│k│ │ │ │ │ │ │x│x│x│o│p│q│r│s│t│u│v│w│x│y│z│
        └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
                                          │<───>│ DelCount
        │<────────────────────────BufSize──────────────────────────────>│
        │<─────────────────────────>│     +     │<─────────────────────>│
                                       = BufLen

             Рис. 15.3 Буфер после удаления 'xxx'.

                                 Вставка текста
        ─────────────────────────────────────────────────────────────────

             Вставка текста обычно является  результатом  нажатий  клавиш
        или вставки  текста из буфера вырезанного текста.  Редактор имеет
        два управляющих  вставкой  метода  -  InsertText  и   InsertFrom.
        InsertText воспринимает  заданное  число символов и включает их в
        буфер.  InsertFrom вставляет выделенный текст из заданного буфера
        объекта редактора. Оба метода вставки вызывают метод вставки ниж-
        него уровня InsertBuffer, но вы не должны вызывать его непосредс-
        твенно.


         B.Pascal 7 & Objects/TV#1   - 311 -


             Когда вы вставляете символы, для определения числа удаляемых
        с помощью отмены символов редактор увеличивает значение  счетчика
        вставки InsCount.  Если вы наберете 'lmn',  то буфер выглядит как
        показано на Рис. 15.4.

                                    CurPtr
                                    v
                                    │<──GapLen─>│
        ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
        │a│b│c│d│e│f│g│h│i│j│k│l│m│n│ │ │ │x│x│x│o│p│q│r│s│t│u│v│w│x│y│z│
        └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
                     InsCount │<───>│     │<───>│ DelCount
        │<───────────────────────BufSize──────────────────────────────>│
        │<─────────────────────────>│     +     │<─────────────────────>│
                                       = BufLen

             Рис. 15.4 Буфер после вставки 'lmn'.

             Число вставленных символов записывается в InsCount.

                              Отмена редактирования
        ─────────────────────────────────────────────────────────────────

             Объекты редактирования имеют  ограниченную  функцию  отмены,
        обратиться к  которой  пользователь обычно может через меню Edit,
        которое вызывает метод Undo объекта редактирования.

             Если вы запрашиваете отмену,  редактор удаляет 'lmn' и пере-
        мещает символы 'xxx' на то место,  где они находились, восстанав-
        ливая тот вид буфера, который представлен на Рис. 15.5.

                                    CurPtr
                                    v
                                    │<──GapLen─>│
        ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
        │a│b│c│d│e│f│g│h│i│j│k│x│x│x│ │ │ │ │ │ │o│p│q│r│s│t│u│v│w│x│y│z│
        └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
        │<──────────────────────────────BufSize────────────────────────>│
        │<─────────────────────────>│     +     │<─────────────────────>│
                                      = BufLen

             Рис. 15.5 Буфер после отмены.

             Метод Undo может отменять операции между перемещениями  кур-
        сора. После  перемещения программой или пользователем курсора все
        изменения редактирования будут восприняты. Из-за перемещения про-
        межутка вся информация отмены теряется.  Заметим,  что информация
        отмены занимает место в буфере, что может помешать вставке текста
        пользователем. Перемещение курсора освобождает это место.


         B.Pascal 7 & Objects/TV#1   - 312 -

                                Работа с блоками
        ─────────────────────────────────────────────────────────────────
             Выделение или отметка блока текста всегда  происходит  перед
        курсором или после него.  Поля SelStart и SelEnd указывают начало
        и конец выделения.  Обычно пользователи выделяют текст с  помощью
        "мыши" или клавиатуры,  но ваша программа может устанавливать вы-
        деление с помощью SelSelection, что также перемещает курсор.

             Вставка текста в редактор с помощью нажатия  клавиши  или  с
        помощью InsertText  заменяет выделенный текст включаемым текстом.
        При отсутствии выделения текст просто вставляется в позиции  кур-
        сора.

                             Использование меню Edit
        ─────────────────────────────────────────────────────────────────
             Все объекты редактирования знают как отвечать  на  несколько
        стандартных команд   меню  редактирования  Edit:  cmCopy,  cmCut,
        cmClear, cmPaste  и  cmUndo.  Команды  вырезания,  копирования  и
        очистки работают с выделенным в редакторе текстом. Команда встав-
        ки вставляет в  позиции  курсора  содержимое  буфера  вырезанного
        текста. Команда  отмены  отменяет  все изменения редактирования с
        момента последнего перемещения курсора.

             Другие команды редактирования, такие как поиск и замена, об-
        рабатываются окном-владельцем объекта редактора,  которое выводит
        на экран диалоговое окно редактирования,  выводящее  пользователю
        подсказки  и запросы для ввода текста для поиска и замены и пара-
        метров.  Затем владелец вызывает с  соответствующими  параметрами
        метод Search редактора.

                           Обновление активных команд
        ─────────────────────────────────────────────────────────────────
             В каждый момент времени допустимы не все команды  редактиро-
        вания. Например,  бессмысленно посылать команду cmCut при отсутс-
        твии выделенных для вырезания  символов.  Объекты  редактирования
        содержат метод UpdateCommands,  который разрешает и запрещает ко-
        манды на основе текущего состояния редактора и буфера вырезанного
        текста. Он вызывается при изменении состояния редактора.

             Команды поиска,  замены  и повторного поиска активны всегда,
        хотя команды вырезания,  копирования и вставки зависят  от  того,
        выделил ли пользователь текст.  Команда Undo активна только в том
        случае, если пользователь имеет вставленный или  удаленный  после
        последнего перемещения курсора текст.

                            Привязка клавиш редактора
        ─────────────────────────────────────────────────────────────────
             По умолчанию объекты редактора связывают команды со  многими
        знакомыми вам по IDE последовательностями клавиш, аналогичных ис-
        пользуемым в редакторе WordSrtar,  включая перемещение курсора  и
        удаление  текста.  Основным исключением являются команды работы с

         B.Pascal 7 & Objects/TV#1   - 313 -

        блоками.

             Вы можете изменить эту привязку клавиш,  переопределив метод
        ConvertEvent, которые транслируют определенные события клавиатуры
        в командные события.

                                Работа с блоками
        ─────────────────────────────────────────────────────────────────

             Так как TEditor не использует постоянные блоки, он моделиру-
        ет блочные команды, копируя текст в буфер вырезанного текста и из
        него. Например,  команды Ctrl+K Ctrl+C начинают выделение текста.
        Ctrl+K Ctrl+K копирует текст в буфер вырезанного изображения. Это
        достаточно близко  моделирует  команды WordStar.  Вы можете также
        выделить блок текста,  нажав клавишу Shift и одну из клавиш пере-
        мещения курсора.

                               Параметры редактора
        ─────────────────────────────────────────────────────────────────

             Объекты редактора предусматривают несколько параметров,  ко-
        торые можно выбирать с помощью булевских полей:

             * CanUndo указывает, будет ли редактор записывать информацию
               отмены. Так как информация отмены временно "отбирает" мес-
               то у вставки,  вы можете посчитать, что ее запрет даст не-
               которые преимущества.  Для редакторов  буфера  вырезанного
               текста CanUndo всегда устанавливается в значение False.

             * Overwrite указывает,  будет ли редактор находится в режиме
               вставки или замены.

             * AutoIndent определяет, будет ли нажатие клавиши Enter при-
               водить  к тому,  что редактор переходит на новой строке на
               позицию первого непробельного  символа  предыдущей  строки
               или в самую левую позицию. Это удобно использовать для ре-
               дактирования исходного кода.


         B.Pascal 7 & Objects/TV#1   - 314 -


             Для определения отдельных параметров, которые применяются ко
        всем редакторам  в  приложении  объекты редактора также использую
        битовую переменную   модуля   Editors   с   именем   EditorFlags.
        EditorFlags управляет созданием файлов резервных копий и парамет-
        рами замены. Биты переменной EditorFlags показаны на Рис. 15.6.

            msb                           lsb
            ╔═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╗
            ╚═╧═╧═╧═╧═╧═╧═╧╤╧═╧═╧═╧╤╧╤╧╤╧╤╧╤╝
                           │       │ │ │ │ └─── efCaseSensitive   = $0001
                           │       │ │ │ └───── efWhoWordsOnly    = $0002
                           │       │ │ └─────── efPromptOnReplace = $0004
                           │       │ └───────── efReplaceAll      = $0008
                           │       └─────────── efDoReplace       = $0010
                           └─────────────────── efBackupFiles     = $0100


             Рис. 15.6 Битовые флаги редактора.

             Биты редактора говорят сами за себя.  Если вам нужны подроб-
        ности, см. Главу 19 "Справочник по Turbo Vision".

                                 Поиск и замена
        ─────────────────────────────────────────────────────────────────

             Операции поиска  и  замены обрабатываются при реакции на ко-
        манду. Например,  вместо непосредственного вызова  метода  поиска
        текста пользователь генерирует команду cmFind,  на которую объект
        редактора реагирует выводом соответствующего диалогового  окна  с
        подсказкой для ввода параметров поиска и замены.

             Аналогично, команда   cmReplace  вызывает  вывод  редактором
        подсказки для ввода текста для поиска и замены,  а также парамет-
        ров. Используемыми в этих операциях диалоговыми блоками управляет
        функция EditorDialogs.

                         Использование полей примечаний
        ─────────────────────────────────────────────────────────────────

             Объект примечания  -  это специальное расширение объекта ре-
        дактора, предназначенное для использование в качестве управляюще-
        го элемента диалогового окна. Оно не имеет специальных возможнос-
        тей редактирования, но добавляет определенные средства, необходи-
        мые для использования в качестве управляющего элемента:

             - палитры, которые отображаются в диалоговое окно;

             - методы GetData, SetData и DataSize.



         B.Pascal 7 & Objects/TV#1   - 315 -

                                Цвета примечания
        ─────────────────────────────────────────────────────────────────

             Большинство объектов редактора используют стандартную палит-
        ру  элемента прокрутки - желтые символы на белом фоне.  Поскольку
        объекты примечания обычно существуют только в  диалоговых  окнах,
        они отображаются в более естественную цветовую комбинацию черного
        на бирюзовом.

                     Действие по типу управляющего элемента
        ─────────────────────────────────────────────────────────────────

             Чтобы действовать как управляющий элемент, объекты редактора
        должны делать две вещи, которые другие редакторы делать не могут:

             - перемещения между полями по табуляции;
             - считывание значений из записи данных и их запись.

                               Обработка табуляции
        ─────────────────────────────────────────────────────────────────

             Обычно объект редактора обрабатывает символы Tab, вставляя в
        текст табуляцию.  Поскольку примечания действуют как  управляющий
        элемент в диалоговом окне, они перехватывают клавиатурные события
        с кодом символа kbTab и обеспечивают для окна нормальное  поведе-
        ние при табуляции,  перемещая фокус на следующее поле. Все другие
        события объекты примечания передают обработчику событий, наследу-
        емому из TEditor.

                         Установка и считывание значений
        ─────────────────────────────────────────────────────────────────

             Управляющие элементы должны устанавливать свои  значения  из
        записи данных  и считывать их обратно в эту запись.  Объект TMemo
        определяет три метода,  необходимых для обработки такой передачи:
        DataSize, GetData и SetData.

             DataSize возвращает размер буфера редактирования,  плюс раз-
        мер слова длины.  GetData и SetData интерпретируют запись  данных
        аналогично длинной строке, рассматривая первые два байта как дли-
        ну текста, а остальные байты как текст примечания.

             Запись данных для поля примечания должна иметь две записи. В
        следующем примере показано простое диалоговое окно с единственным
        управляющим элементом - полем примечания.

             { заметим, что ABufSize - это та же передаваемая конструкто-
               ру редактора команда, что и максимальный размер буфера }
             type
               TDialogData = record
                   MemoLength: Word;
                   MemoText: array[0..ABufSize] of Char;
               end;

         B.Pascal 7 & Objects/TV#1   - 316 -


                         Использование редакторов файлов
        ─────────────────────────────────────────────────────────────────

             Редактор файлов - это объект редактора, связанный с конкрет-
        ным текстовым файлом. Он не имеет дополнительных функций редакти-
        рования, но добавляет следующие средства:

             - загрузку и сохранения файлов;
             - гибкие буферы.

             Использование файлового  редактора требует только одного из-
        менения в конструкторе редактора,  но для  лучшего  использование
        объектов редакторов  файлов  вы должны понимать некоторые концеп-
        ции. Эта глава охватывает следующие темы:

             - построение редактора файла;
             - работа с файлами;
             - работа с буферами.

                           Построение редактора файлов
        ─────────────────────────────────────────────────────────────────

             Конструктор файлового редактора почти идентичен конструктору
        обычного редактора, но вместо задания в качестве последнего пара-
        метра размера  буфера вы передаете имя файла,  который хотите ре-
        дактировать. Редактор файлов будет устанавливать свой собственный
        буфер (как описывается ниже в разделе "Работа с буферами").

             Файловый редактор сохраняет имя текущего файла в поле с име-
        нем FileName.  Если вы передаете в качестве  имени  файла  пустую
        строку, то  редактор  файлов предполагает,  что вы создаете новый
        файл.

             Если в  глобальной  переменной  EditorFlags  установлен  бит
        efBackupFiles, редактор файлов автоматически сохраняет копию пос-
        ледней сохраненной версии редактируемого  файла  (с  расширением,
        измененным на .BAK).

         B.Pascal 7 & Objects/TV#1   - 317 -

                                Работа с файлами
        ─────────────────────────────────────────────────────────────────

             Очевидным различием файлового редактора и  стандартного  ре-
        дактора является тот факт, что редактор файлов должен обслуживать
        соответствующий файл.  В основном при  построении  и  уничтожении
        объекта это происходит прозрачно, но если вы хотите настроить по-
        ведение объекта, вам потребуется некоторое знание деталей по сле-
        дующим темам:

             - загрузка файла;

             - сохранение файла;

             - обеспечение сохранения изменений.

                                 Загрузка файла
        ─────────────────────────────────────────────────────────────────

             Когда вы передаете конструктору файлового редактора имя фай-
        ла,  объект проверяет, представляет ли это имя допустимый файл, а
        затем вызывает метод LoadFile для назначения буфера и  считывания
        содержимого этого файла в буфер редактора. Если файл для редакто-
        ра слишком велик,  или редактор не может выделить буфер достаточ-
        ного размера,  то редактор файлов выводит диалоговое окно "Out of
        memory" ("Нет памяти"), а LoadFile возвращает значение False.

             В общем случае в любой другой момент  вызывать  LoadFile  не
        следует. Если  вы хотите загрузить в редактор файлов другой файл,
        то уничтожить существующий редактор и построить вместо  него  но-
        вый. Этим  обеспечивается допустимость связи между именами файлов
        и буферами редакторов и правильное управление буферной памятью.

                                Сохранение файла
        ─────────────────────────────────────────────────────────────────

             Кроме команд редактирования, понятных всем объектам редакто-
        ра, файловые  редакторы  реагируют  две  дополнительные  команды:
        cmSave и  cmSaveAs.  В  ответ  на  эти команды обработчик событий
        TFileEditor вызывает методы Save и SaveAs  соответственно.  Метод
        UpdateCommands объекта  TFileEditor  вызывает  наследуемый  метод
        UpdateCommands, а затем разрешает cmSave и cmSaveAs.

             Основное отличие между Save и SaveAs в том, что Save предпо-
        лагает сохранение текущего буфера редактирование в файле под име-
        нем FileName, а SaveAs подразумевает, что вы хотите назначить но-
        вый файл.  Если  FileName  - это пустая строка,  то Save вызывает
        SaveAs для присваивания файлу нового имени.

             Фактическое сохранение  текста  файла  выполняется   методом
        SaveFile SaveFile  никогда  не  следует вызывать непосредственно.
        Пользуйтесь  вместо  этого  методами  Save  и  SaveAs.   Если   в
        EditorFlags  установлен бит efBackupFile,  SaveFile берет на себя

         B.Pascal 7 & Objects/TV#1   - 318 -

        сохранение копий файлов, а затем записывает содержимое буфера ре-
        дактора в файл с именем FileName.

                        Обеспечение сохранения изменений
        ─────────────────────────────────────────────────────────────────

             Если пользователь или другой объект пытаются закрыть  редак-
        тор файла,  в  котором  еще  не сохранены изменения (то есть поле
        Modified) имеет значение True), то метод Valid файлового редакто-
        ра выводит  пользователю  диалоговое окно с предупреждением,  что
        модификации нуждаются в изменении или игнорировании.  Затем поль-
        зователь может  либо сохранить изменения,  либо отменить закрытие
        редактора (возвращая в методе Valid False).

                                Работа с буферами
        ─────────────────────────────────────────────────────────────────

             Файловым редакторам  требуется в их работе с буферами что-то
        более гибкое,  чем большинству редакторов, поэтому вместо выделе-
        ния  памяти для буферов файлового редактора в динамически распре-
        деляемой области Turbo Vision пространство буфера  редактирования
        файла над динамически распределяемой областью памяти.  Это позво-
        ляет увеличивать размер буферов редактирования файлов,  сокращать
        и перемещать их. Большая часть работы с буферами происходит авто-
        матически, но вы должны задать, сколько памяти вы хотите зарезер-
        вировать в своем приложении.

             Заметим, что  то  что вы задаете - это размер обычно динами-
        чески распределяемой области памяти Паскаля, и для ваших файловых
        редакторов вся остальная память остается доступной.  Этим обеспе-
        чивается то, что ваше приложение всегда получает необходимый объ-
        ем памяти, а файловые редакторы совместно используют остальное.

                            Задание памяти для буфера
        ─────────────────────────────────────────────────────────────────

             В модуле  Editor  описана  глобальная  переменная  с  именем
        MaxHeapSize, которую  вы можете установить,  если ваше приложение
        использует файловые редакторы.  По  умолчанию  MAxHeapSize  имеет
        значение 640К.  Это означает,  что динамически распределяемая об-
        ласть памяти вашего приложения получает всю доступную  память,  и
        для буферов редактора файла доступной памяти не остается.

             Если вы используете редактор файла, не зарезервировав память
        для буфера,  это приведет к сбою программы и, возможно, зависанию
        системы.

              При работе с переменной MaxHeapSize вы должны учитывать два
        момента:

             * Она задает размер динамически распределяемой области памя-
               ти вашего приложения в 16-байтовых параграфах.  Память все
               этого объема недоступна в остальной части вашего  приложе-

         B.Pascal 7 & Objects/TV#1   - 319 -

               ния,  поэтому  убедитесь  в выделении достаточного объема.
               Например, установка MaxHeapSize в значение 4096 резервиру-
               ет  для динамически распределяемой области памяти приложе-
               ния 64К,  а все остальное остается для  буферов  файлового
               редактора.

             * Вы  должны установить значение MaxHeapSize перед распреде-
               лением какой-либо памяти в динамически распределяемой  об-
               ласти.  Надежнее всего сделать это в первом оператор конс-
               труктора объекта  приложения  перед  вызовом  наследуемого
               конструктора:

                  consctuctor TMyApp.Init;
                  begin
                     MaxHeapSize := 4096;  { должно следовать первым }
                     inherited Init;       { это распределяет память }
                  end;

                      Обслуживание буферов редактора файла
        ─────────────────────────────────────────────────────────────────

             У вас никогда не должно возникать необходимости в  самостоя-
        тельной работе с буфером файлового редактора. TFileEditor переоп-
        ределяет виртуальные методы DoneBuffer,  InitBuffer и  SetBufSize
        для обеспечения того, что редактор использует вместо пространства
        динамически распределяемой области пространство файлового буфера.

             Буферы файлового редактора выделяются с 4-килобайтовых  при-
        ращением. То  есть,  когда  LoadFile запрашивает для своего файла
        буфер, он передает в SetBufSize  размер  буфера,  и  производится
        попытка выделить  именно это число байта с округлением до ближай-
        шей 4-килобайтовой границы. Если размер промежутка редактора сок-
        ращается до  нуля,  то буфер файла  наращивается при наличии дос-
        тупной памяти по 4К.

                     Использование буфера вырезанного текста
        ─────────────────────────────────────────────────────────────────

             Все объекты  редакторов Turbo Vision поддерживают вырезание,
        копирование и вставку из буфера вырезанного изображения (текста),
        но  для использования данных средств вы должны создать объект бу-
        фера вырезанного текста.  В качестве редактора буфера вырезанного
        текста можно использовать любой редактор,  но чаще всего это неи-
        менованный файловый редактор в окне редактирования,  так  что  вы
        можете легко выводить и редактировать буфер вырезанного текста.

             Использование буфера вырезанного текста требует в вашем при-
        ложении только двух дополнительных шагов:

             - построения редактора буфера вырезанного текста;

             - присваивания редактора переменной Clipboard.


         B.Pascal 7 & Objects/TV#1   - 320 -

                 Построение редактора буфера вырезанного текста
        ─────────────────────────────────────────────────────────────────

             В качестве  буфера  вырезанного  текста приложения вы можете
        использовать любой объект редактора Turbo Vision,  но нужно обес-
        печить доступность  буфера  вырезанного текста в любой момент.  В
        общем случае это означает наличие отдельного редактора,  выделен-
        ного для буфера вырезанного текста.  Использование для буфера вы-
        резанного текста файлового редактора дает вам преимущество гибко-
        го размера и позволяет избежать необходимости постоянного выделе-
        ния большой части динамически распределяемой области памяти ваше-
        го приложения.

                        Присваивание переменной Clipboard
        ─────────────────────────────────────────────────────────────────

             Модуль Editors  описывает  глобальную  переменную  с  именем
        Clipboard типа  PEditor,  которой ваше приложение должно присваи-
        вать редактор буфера вырезанного текста,  если вы собираетесь ис-
        пользовать операции с буфером вырезанного текста. Если они знают,
        что работают с буфером вырезанного текста, файловые редакторы ве-
        дут себя несколько по-другому,  и операции вырезания, копирования
        и вставки допустимому объекту редактора не присваиваются.

             Следующий пример показывает типичное создание  буфера  выре-
        занного текста и присваивание его редактора переменной Clipboard.

             type
               TMyApp = object(TApplication)
                  ClipWindow: PEditWindow;
                  constructor Init;
                     .
                     .
                     .
                end;

             constructor TMyApp.Init;
             begin
               MaxHeapSize := 4096;      { допускает для файловых
                                           редакторов использование 64К }
               inherited Init;           { построение приложения }
               New(ClipWindow, Init(R, '', wmNoNumber)); { построить
                                           окно }
               if ValidView(CLipWindow) <> nil then { если это
                                           допустимое окно }
               Clipboard := ClipWindow^.Editor; { создать редактор
                                           буфера вырезанного текста }
             end;

                          Использование окна редактора
        ─────────────────────────────────────────────────────────────────

             Окно редактора (типа  TEditWindow)  -  это  оконный  объект,

         B.Pascal 7 & Objects/TV#1   - 321 -

        спроектированный для размещения файлового редактора. Оно изменяет
        свой заголовок для вывода имени редактируемого файла и устанавли-
        вает  для редактора полосы прокрутки и индикатор прокрутки.  Окно
        редактора сохраняет указатель на соответствующий редактор в  поле
        Editor.

                            Построение окна редактора
        ─────────────────────────────────────────────────────────────────

             Построение окна редактора в точности  аналогично  построению
        любого другого окна,  за исключением того, что второй  передавае-
        мый конструктору параметр - это имя редактируемого файла. Заголо-
        вок окна отражает редактируемый файл:  это 'Clipboard',  если ре-
        дактором является редактор буфера вырезанного текста  приложения,
        или 'Untitled',  если имя файла представляет собой пустую строку.
        В противном случае это полное имя маршрута файла.

                       Другие соглашения по окну редактора
        ─────────────────────────────────────────────────────────────────

             Имеется только два других момента,  когда окно редактора ве-
        дет себя отлично от простого окна. Это его поведение при закрытии
        и реакция на команду оповещения.

             При указании  на  закрытие  окно редактора будет закрываться
        аналогично любому другому окну (включая вызов  метода  Valid  для
        всех своих отображаемых подэлементов), если только окно не содер-
        жит буфер вырезанного текста.  В последнем случае оно не закрыва-
        ется, а становится скрытым. Это позволяет вам редактировать буфер
        вырезанного текста в окне, не теряя его каждый раз, когда вы зак-
        рываете окно.

             Окна редактора  реагируют  на командное событие  оповещения,
        которое обычным окнам обрабатывать не нужно.  Когда имя  файла  в
        редакторе изменяется (обычно после операции Save As),  окно полу-
        чает событие оповещения с командой UpdateTitle,  которая  предуп-
        реждает окно, что оно нуждается в новом отображении и включении в
        рамку нового имени файла.



         B.Pascal 7 & Objects/TV#1   - 322 -

─────────────────────────────────────────────────────────────────────────
                                ГЛАВА 16. Наборы
        ─────────────────────────────────────────────────────────────────

             Программисты, работающие  на  языке  Паскаль,  обычно тратят
        очень много времени на создание кода по манипулированию и обеспе-
        чению структур данных, таких как связанные списки и массивы с ди-
        намической установкой размеров.  И очень часто один и тот же  код
        имеет  тенденцию  к  повторному переписыванию и отладке.

             Что касается традиционного языка Паскаль, он лишь предостав-
        ляет  вам встроенные типы записи и массива.  Все другие структуры
        остаются на ваше усмотрение.

             Например, если вы собираетесь хранить данные в  массиве,  то
        обычно вам нужно написать код для создания массива,  импорта дан-
        ных в массив,  получение данных массива для обработки, и, возмож-
        но, вывода данных на устройство ввода-вывода. Позднее, когда пот-
        ребуется новый тип элемента массива, вы начинаете все сначала.

             Было бы замечательно, если бы тип массива поставлялся вместе
        с кодом, обрабатывающего бы многие из тех операций, которые обыч-
        но выполняются с массивом.  Это был бы тип массива, который можно
        было бы расширять без нарушения первоначального кода. Все это яв-
        ляется целью создания типа Turbo  Vision TCollection. Это объект,
        который хранит наборы указателей и обладает  набором  методов  по
        манипулированию ими.

                                 Объекты наборов
        ─────────────────────────────────────────────────────────────────

             Будучи объектами и тем самым имея встроенные методы,  наборы
        обладают двумя дополнительными чертами, которые имеют отношение к
        обычным массивам языка Паскаль - это динамическое установка  раз-
        меров и полиморфизм.

                     Динамическая установка размеров наборов
        ─────────────────────────────────────────────────────────────────

             Размер стандартного массива в стандартном Паскале фиксирует-
        ся во время компиляции.  Хорошо, если вы точно знаете, какой раз-
        мер должен иметь ваш массив,  но это может быть не столь хорошо к
        тому моменту, когда кто-нибудь будет запускать на вашу программу.
        Изменение размера массива требует изменения исходного кода и  пе-
        рекомпиляции.

             Однако, для наборов вы устанавливаете  только  их  начальный
        размер, который динамически увеличивается в процессе работы прог-
        раммы, для  размещения в нем всех нужных данных.  Это делает ваше
        приложение в его скомпилированном виде значительно более  гибким.
        Тем не менее, следует иметь в виду, что набор не может сжиматься,
        поэтому следует быть аккуратным  и  не  делать  его  неоправданно
        большим.


         B.Pascal 7 & Objects/TV#1   - 323 -

                               Полиморфизм наборов
        ─────────────────────────────────────────────────────────────────

             Второй аспект,  по которому массивы могут ограничивать  ваше
        приложение,  состоит  в  том,  что  каждый элемент массива должен
        иметь один и тот же тип,  и этот тип должен  быть  определен  при
        компиляции  кода.

             Наборы обходят это ограничение использованием нетипизирован-
        ных указателей. Это сказывается не только на быстроте и эффектив-
        ности,  но наборы могут состоять из объектов (и даже не из объек-
        тов) разного типа и размера.  Набору не нужно знать  что-либо  об
        объектах,  которые он обрабатывает.  Он просто организует связь с
        ними в случае необходимости.

                             Проверка типа и наборы
        ─────────────────────────────────────────────────────────────────

             Наборы ограничивают  традиционную мощную проверку типа языка
        Паскаль. Это означает, что можете поместить нечто в набор и когда
        запрашиваете  это назад,  компилятор уже не может проверить ваших
        предположений относительно объекта. Вы можете поместить нечто как
        PHedgehog (еж),  а прочитать назад как PSheep (овца), и набор ни-
        как не сможет насторожить вас.

             Как программист,  работающий на языке Паскаль, вы вполне оп-
        равданно будете нервничать по поводу результатов.  Проверка типов
        языка Паскаль в конце концов сберегает несколько часов при поиске
        некоторых достаточно иллюзорных ошибок. Поэтому вы должны принять
        во внимание следующее предупреждение. Вы даже представить себе не
        можете насколько трудно бывает искать ошибки несоответствия типа,
        поскольку обычно эту работу за вас выполнял  компилятор!  Однако,
        если вы обнаружите, что ваша программа сбивается или зацикливает-
        ся,  тщательно проверьте хранимые типы объектов и считываемые  из
        наборов.

             Объединение в набор элементов, не являющихся объектами
        ─────────────────────────────────────────────────────────────────

             Вы даже можете добавить в набор нечто, что вообще не являет-
        ся объектом,  но это также может явиться серьезным предметом оза-
        боченности.  Наборы ожидают получения нетипизированных указателей
        незаданного типа на нечто.  Но некоторые методы TCollection пред-
        назначены специально для работы с наборами элементов, производных
        от  TObject.  Это  касается  методов  доступа  к потоку PutItem и
        GetItem, и стандартной процедуры FreeItem.

             Например, это означает,  что вы можете хранить PChar в набо-
        ре,  но при попытке послать этот набор в поток,  результаты будут
        не столь успешными,  если вы не перепишете стандартные методы на-
        бора GetItem и PutItem.  Аналогично, при попытке освобождения на-
        бора будет сделана попытка удаления каждого  элемента  с  помощью
        FreeItem. Например, это делает TStrCollection.

         B.Pascal 7 & Objects/TV#1   - 324 -


             Если вам удастся преодолеть все эти трудности,  вы обнаружи-
        те,  что наборы (и построенные вами производные наборов) являются
        быстрыми, гибкими и надежными структурами данных.

                                 Создание набора
        ─────────────────────────────────────────────────────────────────

             Создание набора столь же просто, как и создание типа данных,
        которые вы хотите в нем хранить.  Предположим,  что вы - консуль-
        тант,  и вам нужно хранить и искать номер счета,  фамилию и номер
        телефона каждого из ваших клиентов. Сначала определим тип объекта
        клиента (TClient),  который будет хранится в наборе (не  забудьте
        определить тип указателя для каждого нового типа объекта):

             type
               PClient=^TClient;
               TClient=object(TObject)
                 Account, Name, Phone: PChar;
                 constructor Init(NewAccount, NewName, NewPhone: PChar);
                 destructor Done; virtual;
                 procedure Print; virtual;
               end;

             Затем реализуем методы Init и Done для размещения и удаления
        данных о клиенте и метод Print для отображения данных о клиенте в
        виде таблицы.  Обратите внимание,  что  поля  объекта  имеют  тип
        PChar, поэтому память выделяется только для той части строки, ко-
        торая действительно используется.  Функции  StrNew  и  StrDispose
        очень эффективно обрабатывают динамические строки.

             constructor TClient.Init(NewAccount, NewName,
                                      NewPhone: PChar);
             begin
               Account := StrNew(NewAccount);
               Name    := StrNew(NewName);
               Phone    := StrNew(NewPhone);
             end;

             destructor TClientDone;
             begin
                StrDispose(Account);
                StrDispose(Name);
                StrDispose(Phone);
             end;

             procedure TClient.Print;
             begin
               Writeln( ' ',
                Account, '':10 - StrLen(Account),
                Name, '':20 - StrLen(Name),
                Phone, '':16 - StrLen(Phone));
             end;

         B.Pascal 7 & Objects/TV#1   - 325 -


             TClient.Done будет автоматически вызываться для каждого кли-
        ента при удалении всего набора.  Сейчас вы просто инициируете на-
        бор для хранения ваших клиентов и вставляете в него записи о кли-
        ентах. Основное тело  программы  (COLLECT1.PAS)  будет  выглядеть
        следующим образом:

             var
               ClientList: PCollection;
             begin
               ClientList:=New(PCollection, Init(10,5));
               with ClientList^ do
               begin
                Insert(New(PClient, Init('91-100', 'Anders, Smitty',
                 '(406) 111-2222')));
                Insert(New(PClient, Init('90-167', 'Smith, Zelda',
                 '(800) 555-1212')));
                Insert(New(PClient, Init('90-177', 'Smitty, John',
                 '(406) 987-4321')));
                Insert(New(PClient, Init('90-160', 'Johnson, Agatha',
                 '(302) 139-8913')));
              end;
              PrintAll(ClientList);
              SearchPhone(ClientList, '(406)');
              Dispose(ClientList, Done);
             end.

                   Примечание: Процедуры  PrintAll  и  SearchPhone  будут
              рассмотрены позднее.

             Обратите внимание,  насколько  просто  было построить набор.
        Первый оператор размещает новый экземпляр  TCollection  с  именем
        ClientList с начальным размером на 10 клиентов.  В случае необхо-
        димости размещения более 10 клиентов в ClientList, его размер бу-
        дет увеличиваться каждый раз на 5 клиентов.  Следующие два опера-
        тора создают новый объект клиента и вставляют его в набор.  Вызов
        Dispose  в конце операции освобождает весь набор клиентов.

             Нигде не нужно было сообщать набору,  какой вид данных пред-
        полагается хранить - для этого просто используется указатель.

                                Методы итератора
        ─────────────────────────────────────────────────────────────────

             Вставка и удаление элемента не являются единственными общими
        операторами набора.  Очень часто вы будете писать циклы  for  для
        просмотра всех объектов набора с целью отображения данных или вы-
        полнения некоторых вычислений.  В других случаях вы будете искать
        первый или последний элемент набора,  который удовлетворяет неко-
        торому критерию поиска.  Для этих целей у наборов имеется три ме-
        тода итератора:  ForEach,  FirstThat  и  LastThat.  Каждый из них
        воспринимает указатель на процедуру или функцию в качестве своего
        единственного параметра.

         B.Pascal 7 & Objects/TV#1   - 326 -


                                Итератор ForEach
        ─────────────────────────────────────────────────────────────────

             ForEach воспринимает указатель на процедуру. Процедура имеет
        один  параметр,  который является указателем на хранимый в наборе
        элемент.  Для каждого элемента набора ForEach вызывает  процедуру
        один раз, в той последовательности, в которой элементы появляются
        в наборе.  Процедура PrintAll в Collect1 показывает пример итера-
        тора FoeEach.

             procedure PrintAll(C: PCollection); { печать информации по
                                          всем клиентам }
              procedure CallPrint(P: PClient); far; { локальная
                                          процедура }
              begin
                with P^ do
                 Writeln(Account^, '':20-Length(Account^), { вывод инфор-
                                          мации о клиенте }
                    Name^, '':20-Lenght(Name^),
                    Phone^, '':20-Lenght(Name^)),
              end;                      { конец локальной процедуры }
             begin {Print}
               Writeln;
               Writeln;
               Writeln('Client list:');
               C^.ForEach(@CallPrint);  { распечатка PrintClient для
                                          каждого элемента в C }
             end;

             Для каждого элемента набора, переданного в качестве парамет-
        ра  в  PrintAll,  вызывается   вложенная   процедура   CallPrint.
        CallPrint  просто  распечатывает  информацию об объекте клиента в
        отформатированных колонках.

                   Примечание: Итераторы должны вызывать локальные проце-
             дуры far.

             Вам нужно быть аккуратным с сортировкой процедур, которые вы
        вызываете итераторами. Для того, чтобы быть вызванной итератором,
        процедура  (в  данном  примере,  CallPrint) должна быть локальной
        процедурой (вложенной в тот же блок) и не может быть функцией или
        методом объекта, хотя данный пример показывает, что процедура мо-
        жет вызвать метод.  Она также должна описываться как дальняя про-
        цедура директивой far или директивой компилятора {$F+}.  Наконец,
        процедура должна воспринимать в качестве единственного  параметра
        указатель на элемент набора в качестве своего единственного пара-
        метра.

                         Итераторы FirstThat и LastThat
        ─────────────────────────────────────────────────────────────────

             Кроме возможности  приложения  процедуры  к каждому элементу

         B.Pascal 7 & Objects/TV#1   - 327 -

        набора,  часто бывает очень нужно найти конкретный элемент набора
        на  основании  некоторого критерия.  Это является предназначением
        итераторов FirstThat и LastThat.  Как это следует из их имен, они
        просматривают набор в противоположных направлениях до момента на-
        хождения первого элемента набора,  который удовлетворяет критерию
        булевской функции, переданной в качестве элемента.

             FirstThat и  LastThat  возвращают  указатель  на первый (или
        последний) элемент, который удовлетворяет условию поиска. Предпо-
        ложим, что в приведенном ранее примере списка клиентов, вы не мо-
        жете вспомнить номер счета клиента или не помните точно написание
        имени клиента.  К счастью, вы точно помните, что это был ваш пер-
        вый клиент из штата Монтана.  Следовательно,  вы можете организо-
        вать  поиск первого клиента с кодом штата 406 (поскольку ваш спи-
        сок клиентов ведется хронологически). Данная процедура использует
        метод FirstThat, который и сделает всю работу:

             procedure SearchPhone(C: PCollection; PhoneToFind: PChar);

              function PhoneMatch(Client: PClient: PClient): Boolean;
                  far;
              begin
               PhoneMatch := Pos(PhoneToFind, Client^.Phone^) <> 0;
              end;

             var
               FoundClient: PClient;
             begin
              FoundClient := C^.FirstThat(@PhoneMatch);
              if FoundClient = nil then
                Writeln('Такому требованию не отвечает ни один клиент')
              else
               with FoundClient^ do
                Writeln('Найден клиент:', Account^, '  ', Name^, '  ',
                        Phone^);
             end;

             Снова обратите внимание на то,  что PhoneMatch вложена и ис-
        пользует удаленную модель вызова. В этом случае эта функция возв-
        ращает  True  только при совпадении номера телефона клиента и за-
        данного образца поиска.  Если в наборе нет объекта, который соот-
        ветствовал  бы  критерию  поиска,  FirstThat возвращает указатель
        nil.
             Запомните: ForEach вызывает определенную пользователем  про-
        цедуру, а FirstThat и LastThat каждая вызывает определенную поль-
        зователем булевскую функцию.  В любом случае определенная пользо-
        вателем процедура  или функция передают указатель на объект набо-
        ра.

                             Отсортированные наборы
        ─────────────────────────────────────────────────────────────────

             Иногда вам бывает нужно, чтобы ваши данные были определенным

         B.Pascal 7 & Objects/TV#1   - 328 -

        образом отсортированы.  Turbo  Vision имеет специальный тип набо-
        ра,  который  позволяет  вам упорядочить свои данные произвольным
        образом. Это тип TSortedCollection.

             TSortedCollection является производным от TCollection и  ав-
        томатически сортирует задаваемые ему объекты.  При добавлении но-
        вого элемента он автоматически проверяет  набор  на  дублирование
        ключей.  Булевское поле Duplicates контролирует разрешение дубли-
        рования ключей.  Если для поля  Duplicates  установлено  значение
        False (по умолчанию),  то новый элемент добавляется к набору, за-
        меняя существующий член с тем же самым  ключом.  Если  Duplicates
        имеет значение True, то новый член просто вставляется в набор.

             TSortedCollection - это набор абстрактного типа. Для его ис-
        пользования вы должны сначала решить, какой тип данных вы собира-
        етесь собирать и определить два метода, отвечающих вашим конкрет-
        ным требованиям сортировки.  Для этого вам  нужно  создать  новый
        тип,  производный  от TSortedCollection.  В данном случае назовем
        его TClientCollection.


             Ваш TClientCollection уже знает, как делать всю реальную ра-
        боту с набором. Он может вставить (Insert) запись о новом клиенте
        и  удалять  (Delete) существующие записи - он унаследовал эти ос-
        новные черты поведения от TCollection.  Все что нужно  сделать  -
        это научить TClientCollection, какое поле использовать в качестве
        ключа сортировки и как сравнивать двух клиентов при решении  воп-
        роса о том, какой из них должен стоять в наборе выше другого. Это
        делается переписыванием методов KeyOf и Compare и  реализации  их
        следующим образом:

             PClientCollection = ^TClientCollection;
             TClientCollection = object(TSortedCollection)
               function KeyOf(Item: Pointer): Pointer; virtual;
               function Compare(Key1, Key2: Pointer): Integer; virtual;
             end;

             function TClientCollection.KeyOf(Item: Pointer): Pointer;
             begin
               KeyOf := PClient(Item)^.Account;
             end;

             function TClientCollection.Compare(Key1, Key2: Pointer):
                      Integer;
             begin
               if PString(Key1)^ < PString(Key2) then
                 Compare := 0;            { возвращает 0, если равно }
               else if PString(Key1)^ < PString(Key2)^ then
                 Compare := -1;           { возвращает -1, если первым
                                            следует Key1 }
               else
                 Compare := 1;            {  в противном случае

         B.Pascal 7 & Objects/TV#1   - 329 -

                                             возвращает 1, первым
                                            следует Key2 }
             end;

                   Примечание: Так  как  ключи являются нетипизированными
              указателями, для них нужно выполнять приведение типа.

             KeyOf определяет, какое поле или поля используются в качест-
        ве ключей сортировки.  В данном случае  это  поле  клиента  Name.
        Compare воспринимает два ключа сортировки и определяет,  какой из
        них должен идти первым в  соответствии  с  правилами  сортировки.
        Compare возвращает -1,  0 или 1 в зависимости от того, Key1 мень-
        ше,  равен или больше Key2,  соответственно. В данном примере ис-
        пользуется  сортировка  по  алфавиту (для букв верхнего и нижнего
        регистра) ключевой строки (Name).

             Обратите внимание на то, что ключи, возвращаемые KeyOf и пе-
        редаваемые в Compare являются нетипизированными указателями, поэ-
        тому  до  их разыменования и передачи в PString.

             Это практически все,  что вам нужно определить! Теперь, если
        вы   переопределите   ClientList   как  PClientCollection  вместо
        PCollection (сменив объявление var и вызов New), то легко сможете
        распечатать ваших клиентов в алфавитном порядке (см. пример прог-
        раммы COLLECT2.PAS):

             var
               ClientList: PClientCollection;
                .
                .
             begin
               ClientList := New(PClientCollection, Init(10,5));
                .
                .
             end.

             Обратите внимание и на то, как легко будет сменить сортиров-
        ку списка клиентов по номеру счета на сортировку  по  имени.  Все
        что  вам  нужно сделать,  это сменить метод KeyOf на возврат поля
        Account на поле Name.

                                  Наборы строк
        ─────────────────────────────────────────────────────────────────

             Многим программам  требуется  работать  с   отсортированными
        строками. Для этих целей Turbo  Vision предоставляет набор специ-
        ального назначения   TStrCollection   (он   совпадает   с   типом
        TStringCollection, определенным для хранения строк Паскаля).  Об-
        ратите внимание,  что  элементы  TStrCollection - это не объекты.
        Они представляют  собой указатели на строки,  заканчивающиеся ну-
        лем. Поскольку наборы строк происходят от TSortedCollection, мож-

         B.Pascal 7 & Objects/TV#1   - 330 -

        но хранить и дублированные строки.

             Использовать наборы строк несложно.  Просто определяется пе-
        ременная указателя для хранения набора  строк.  Разместим  набор,
        задав  его начальный размер и приращение для роста при добавлении
        новых строк (см. программу COLLECT3.PAS):

             var
              WordList: PCollection;
              WordRead: PChar;
                .
                .
                .
             begin
              WordList := New(PStrCollection, Init(10, 5));
                .
                .
                .

             WordList первоначально  рассчитан  для  хранения  10 строк с
        последующим приращением по 5 строк.  Все что вам нужно сделать  -
        это вставить несколько строк в набор. В данном примере слова счи-
        тываются из текстового файла и вставляются в набор:

             repeat
                .
                .
                .
              if GetWord(WordRead, WordFile)^ <> #0 then
               WordList^.Insert(NewStr(WordRead));
                .
                .
                .
              until WordRead = '';
                .
                .
                .
              Dispose(WordList, Done);

             Обратите внимание, что функция NewStr используется для копи-
        рования считанных слов, и адрес скопированной строки передается в
        набор.  При использовании набора вы всегда передаете ему контроль
        над данными  набора.  Он позаботится об освобождении данных после
        работы. Он при этом делает то, что происходит при вызове Dispose:
        удаляется  каждый  элемент  набора, и  затем  удаляется сам набор
        WordList.

                            Пересмотренные итераторы
        ─────────────────────────────────────────────────────────────────

             Метод ForEach  просматривает весь набор,  элемент за элемен-
        том, и выполняет над каждым из них заданную процедуру. В предыду-
        щем  примере процедуре PrintWord передавался указатель строки для

         B.Pascal 7 & Objects/TV#1   - 331 -

        ее отображения.  Обратите внимание,  что процедура PrintWord вло-
        женная (или локальная).  Она работает в другой процедуре,  Print,
        которой передается указатель на TstrCollection.  Print использует
        метод  итератора ForEach для передачи каждого элемента своего на-
        бора в процедуру PrintWord.

             procedure Print(C: PCollection);

              procedure PrintWord(P: PString); far;
              begin
                Writeln(P^);                 { вывести строку }
              end;
             begin                           { печать }
               Writeln;
               Writeln;
               C^.ForEach(@PrintWord);       { вызов PrintWord }
             end;

             PrintWord должен  выглядеть как уже знакомая процедура.  Она
        просто берет указатель строки и передает  его  значение  Writeln.
        Обратите внимание  на  директиву  far  после  описания PrintWord.
        PrintWord не может быть методом, это просто процедура. Кроме того
        это должна быть вложенная процедура. Print надо рассматривать как
        некую оболочку вокруг процедуры,  которая выполняет некоторую ра-
        боту над каждым элементом набора (может быть отображает или моди-
        фицирует данные). Вы можете иметь несколько аналогичных PrintWord
        процедур,  но  каждая из них должна быть вложена в Print и должна
        быть дальней процедурой (использовать директиву far или {$F+}).

                               Нахождение элемента
        ─────────────────────────────────────────────────────────────────

             Отсортированные наборы (и следовательно наборы строк)  имеют
        метод Search,  который  возвращает  индекс  элемента с конкретным
        значением ключа. Но как найти элемент в неотсортированном наборе?
        Или когда  критерий  поиска  не использует сам ключ?  Конечно же,
        следует использовать FirstThat и LastThat.  Вы просто определяете
        булевскую  функцию  для проверки нужного вам критерия и вызываете
        FirstThat.

                             Полиморфические наборы
        ─────────────────────────────────────────────────────────────────

             Как вы уже видели,  что наборы могут динамически хранить лю-
        бой тип данных и они обладают множеством методов, которые помога-
        ют вам организовывать эффективный доступ к данным. В действитель-
        ности сам TCollection определяет 23 метода.  Когда вы используете
        наборы в ваших программах,  вы будете удивлены скоростью их рабо-
        ты:  они разработаны с максимальной гибкостью и  реализованы  для
        использования с максимальной скоростью.

             Теперь пришло  время  рассмотреть реальные возможности набо-
        ров,  элементы могут обрабатываться полиморфически.  Это  значит,

         B.Pascal 7 & Objects/TV#1   - 332 -

        что  вы не просто можете хранить определенный тип объекта в набо-
        ре;  вы можете хранить несколько разных  типов  объектов,  взятых
        произвольно из вашей иерархии объектов.

             Если вы рассмотрите приведенные примеры наборов,  вы  можете
        заметить, что все элементы каждого набора были одно и того же ти-
        па.  Мы имели дело со списком строк в котором каждый элемент  был
        строкой.  Мы  также занимались списком клиентов.  Но наборы могут
        хранить любые производные от TObject объекты,  и вы можете произ-
        вольно смешивать эти объекты.  Естественно, что вы желаете, чтобы
        эти объекты имели нечто общее.  На самом деле вам нужно,  чтобы у
        них был общий абстрактный объект-предок.

             В качестве примера рассмотрим программу,  которая помещает в
        набор  три различных графических объекта.  Затем итератор ForEach
        используется для просмотра набора и отображения каждого  объекта.

             Данный пример использует модуль Graph и драйверы BGI, поэто-
        му убедитесь,  что  в  текущем  каталоге  или по маршруту модулей
        (Options│Directories│Unit Directory)  при  компиляции   находится
        GRAPH.TPU. При запуске программы измените его на каталог,  содер-
        жащий драйверы .BGI,  или модифицируйте вызов InitGraph, задав их
        расположение (например, C:\TP\BGI).

             Сначала определяется    абстрактный    объект-предок    (см.
        программу COLLECT4.PAS).

             type
               PGraphObject = ^TGraphObject;
               TGraphObject = object(TObject)
                 X,Y: Integer;
                 constructor Init;
                 procedure Draw; virtual;
             end;

             Из этого описания вы можете видеть,  что каждый  графический
        объект  может  инициализировать  себя (Init) и отобразить себя на
        графическом экране (Draw). Теперь определим точку, круг и прямоу-
        гольник как производные от этого общего предка:

             PGraphPoint = ^TGraphPoint;
             TGraphPoint = object(TGraphObject)
               procedure Draw; virtual;
             end;

             PGraphCircle = ^TGraphCircle;
             TGraphCircle = object(TGraphObject)
               Radius: Integer;
               constructor Init;
               procedure Draw; virtual;
             end;

             PGraphRect = ^TGraphRect;

         B.Pascal 7 & Objects/TV#1   - 333 -

             TGraphRect = object(TGraphObject)
               Width, Height: Integer;
               constructor Init;
               procedure Draw; virtual;
             end;


             Все эти   три   типа   объекта  наследуют  поля  X  и  Y  из
        PGraphObject,  но все они разного размера. PGraphCircle добавляет
        Radius,  а PGraphRect - Width и Height. Приведем исходный код для
        помещения этих фигур в набор:

               .
               .
               .
             GraphicsList := New(PCollection, Init(10,5));
                                           { создать набор }
             for I := 1 to NumToDraw do
             begin
              case I mod 3 of              { создать объект }
               0: P := New(GraphPoint, Init);
               1: P := New(GraphCircle, Init);
               2: P := New(GraphRect, Init);
              end;
              List^.Insert(P);             { добавить в набор }
             end;
               .
               .
               .

             Как вы можете видеть цикл, for вставляет графические объекты
        в  набор  List.  Вы  знаете  только то,  что каждый объект в List
        представляет собой некоторый вид TGraphObject.  После помещения в
        набор у вас уже нет информации о том,  является ли элемент набора
        прямоугольником,  эллипсом или сектором.  Благодаря полиморфизму,
        вам этого и не нужно знать,  поскольку каждый объект содержит все
        данные и код (Draw),  который ему нужен.  Просмотрим набор с  ис-
        пользованием итеративного метода и каждый набор будет сам отобра-
        жать себя:

             procedure DrawAll(C: PCollection);

             procedure CallDraw(P: PGraphObject); far;
              begin
                P^.Draw;               { вызов метода Draw }
              end;

             begin                     { DrawAll }
              C^.ForEach(@CallDraw);   { нарисовать каждый объект }
             end;

             var
              GraphicsList: PCollection;

         B.Pascal 7 & Objects/TV#1   - 334 -

             begin
               .
               .
               .
              DrawAll(GraphicsList);
               .
               .
               .
             end.

             Способность наборов хранить разные, но связанные объекты ос-
        новывается на мощном краеугольном камне объектно-ориентированного
        программирования. В следующей главе вы увидите тот же принцип по-
        лиморфизма, примененный к потокам с равными приоритетами.

                           Наборы и управление памятью
        ─────────────────────────────────────────────────────────────────

             TCollection может динамически расти от  начального  размера,
        установленного Init,  до максимального размера в 16380 элементов.
        Turbo  Vision хранит  максимальный  размер  набора  в  переменной
        MaxCollectionSize.  Каждый  добавляемый  в набор элемент занимает
        четыре байта памяти, т.к. он хранится в виде указателя.

             Ни одна  библиотека  динамических  структур  данных не будет
        полной,  если она не снабжена средствами обнаружения ошибок. Если
        для инициализации набора не хватает памяти,  то возвращается ука-
        затель nil.

             Если не хватает памяти при добавлении элемента в  набор,  то
        вызывается метод TCollection.Error,  и возникает ошибка этапа вы-
        полнения в динамически распределяемой области памяти.  Вы  можете
        переписать  TCollection.Error для организации собственного метода
        информирования или исправления ошибки.

             Вам следует уделить особое внимание доступности динамической
        области памяти,  поскольку у пользователя имеет значительно боль-
        ший контроль над программой  Turbo Vision,  чем над обычной прог-
        раммой языка Паскаль. Если добавлением объектов в набор управляет
        пользователь (например,  открывая новое окно),  то ошибку динами-
        ческой области памяти не так  то  легко  предсказать.  Вы  можете
        предпринять  некоторые  шаги  по защите пользователя от фатальной
        ошибки при выполнении программы либо проверяя память при  исполь-
        зовании набора, либо обрабатывая сбой выполняемой программы таким
        образом, чтобы избежать прекращения ее работы.

         B.Pascal 7 & Objects/TV#1   - 335 -

─────────────────────────────────────────────────────────────────────────
                                ГЛАВА 17. Потоки
        ─────────────────────────────────────────────────────────────────

             Техника объектно-ориентированного программирования  и  Turbo
        Vision  дают  вам  мощные  средства  инкапсуляции кода и данных и
        большие возможности построения взаимосвязанных структур объектов.
        Но что делать,  если стоит простая задача,  например, по хранению
        некоторых объектов на диске?

             Когда-то данные хранились исключительно в записях, и помеще-
        ние данных на диск было тривиальной задачей. Но данные в програм-
        мах Turbo  Vision неразрывно связаны с объектами. Конечно, вы мо-
        жете отделить  данные  от  объекта и записать их в дисковый файл.
        Объединение дает вам значительный шаг в направлении прогресса,  а
        разъединение отбрасывает вас назад.

             Есть ли  в самом объектно-ориентированном программировании и
        Turbo  Vision некоторые средства,  которые могли бы разрешить эту
        проблему? Есть, и это потоки.

             Поток в  Turbo  Vision  -  это набор объектов на их пути ку-
        да-либо:  обычно в файл, EMS, в последовательный порт или некото-
        рое  другое устройство.  Потоки обслуживают операции ввода-вывода
        на уровне объектов, а не на уровне данных. При расширении объекта
        Turbo  Vision  вам  нужно  обеспечить обработку определенных вами
        дополнительных полей.  Все сложные аспекты  обработки  на  уровне
        объектов будут проделаны за вас.

                          Вопрос: объектный ввод-вывод
        ─────────────────────────────────────────────────────────────────

             Поскольку вы пишете программы на языке Паскаль,  то  знаете,
        что до  выполнения  операций  ввода-вывода  с файлом,  вы сначала
        должны сообщить компилятору,  какой тип данных вы будете писать и
        считывать из файла. Файл должен иметь тип, и этот тип должен быть
        установлен во время компиляции.

             Паскаль реализует в этой связи очень удобное правило:  можно
        организовать  доступ  к  файлу  неопределенного  типа  с  помощью
        процедур BlockWrite и BlockRead.  Отсутствие проверки типа возла-
        гает  некоторую  дополнительную  ответственность на программиста,
        хотя позволяет очень быстро выполнять двоичные операции ввода-вы-
        вода.

             Вторая проблема  состоит в том,  что вы не можете непосредс-
        твенно использовать файлы с объектами.  Паскаль не позволяет  вам
        создавать файл с объектным типом.  Объекты могут содержать вирту-
        альные методы,  адреса которых определяются в процессе выполнения
        программы,  поэтому хранение информации о виртуальных методах вне
        программы лишено смысла, еще более бессмысленно считывать эту ин-
        формацию в программу.

             Но эту проблему снова можно обойти.  Вы можете выделить дан-

         B.Pascal 7 & Objects/TV#1   - 336 -

        ные из ваших объектов и записать эту информацию в  какой-то  файл
        некоторого вида,  а  уже позднее восстановить объекты из этих ис-
        ходных данных.  Подобное решение, однако, будет недостаточно эле-
        гантным и существенно усложняет конструирование объектов.

                                  Ответ: потоки
        ─────────────────────────────────────────────────────────────────

             Turbo  Vision позволяет обойти все эти трудности и даже  су-
        лит вам получение некоторых дополнительных выгод. Потоки дают вам
        простое,  но изящное средство хранение данных объекта  вне  вашей
        программы.

                               Полиморфизм потоков
        ─────────────────────────────────────────────────────────────────

             Потоки Turbo  Vision позволяют вам работать с файлами  опре-
        деленного и неопределенного типа:  проверка типа имеется,  но тип
        посылаемого объекта не должен обязательно определяться  во  время
        компиляции.  Смысл в том,  что потоки знают, что они имеют дело с
        объектами, и  поскольку  все  объекты  являются  производными  от
        TObject,  поток может их обработать. В действительности различные
        объекты Turbo  Vision могут также легко записываться  в один  по-
        ток, как и группы идентичных объектов.

                           Потоки обрабатывают объекты
        ─────────────────────────────────────────────────────────────────

             Все что вам нужно сделать - это определить для потока, какие
        объекты ему нужно будет обрабатывать, чтобы он знал, как согласо-
        вывать данные с таблицами  виртуальных  методов.  Затем  без  ка-
        ких-либо усилий вы можете помещать объекты в поток и извлекать их
        из потока.

             Но каким образом один и тот же поток может считывать и запи-
        сывать  такие  разные объекты как TCollection и TDialog,  даже не
        зная в момент компиляции,  какие типы объектов он будет обрабаты-
        вать?  Это  существенно  отличается от традиционных операций вво-
        да-вывода языка Паскаль.  В действительности потоки могут обраба-
        тывать даже новые типы объектов,  которые вообще еще не были соз-
        даны к моменту компиляции потока.

             Ответом на это является так называемая регистрация.  Каждому
        типу  объекта  Turbo  Vision (или любому новому производному типу
        объекта) присваивается уникальный регистрационный номер. Этот но-
        мер записывается в поток перед данными объекта. Затем, при считы-
        вании объекта из потока,  Turbo  Vision сначала берет регистраци-
        онный номер и на его основании узнает,  сколько данных нужно счи-
        тывать и какие таблицы виртуальных методов подключать к данным.



         B.Pascal 7 & Objects/TV#1   - 337 -

                           Смысл использования потоков
        ─────────────────────────────────────────────────────────────────

             На фундаментальном уровне вы можете рассматривать потоки как
        файлы языка Паскаль. В своей основе файл языка Паскаль представля-
        ет собой последовательное устройство ввода-вывода: вы записываете
        в него и считываете из него. Поток - это полиморфическое устройс-
        тво последовательного ввода-вывода, т.е. оно ведет себя, как пос-
        ледовательный файл, но вы можете считывать и записывать различные
        типы объектов в каждый момент времени.

             Потоки (как и файлы Паскаля) можно также просматривать,  как
        устройства ввода-вывода произвольного доступа,  искать определен-
        ное  место в файле,  считывать данные в этой точке или записывать
        данные в эту точку, возвращать позицию указателя файла и т.д. Все
        эти операции можно выполнять с потоками,  и они описаны в разделе
        "Потоки с произвольным доступом".

             Есть два разных аспекта использования потоков,  которыми вам
        нужно овладеть,  и к счастью оба они очень простые.  Первый - это
        установка потока, а второй - считывание и запись файлов в поток.

                                Установка потока
        ─────────────────────────────────────────────────────────────────

             Все что нужно сделать для использования потока - это инициа-
        лизировать  его.  Точный  синтаксис  конструктора Init может быть
        разным,  в зависимости от типа потока,  с которым вы имеете дело.
        Например,  если  вы открываете поток DOS,  вам нужно передать имя
        файла DOS и режим доступа (только  чтение,  только  запись,  чте-
        ние/запись) для содержащего поток файла.

             Например, для инициализации буферизированного потока DOS при
        загрузке набора объектов в программу, все что вам нужно это:

             var
               SaveFile: TBufStream;
             begin
               SaveFile.Init('COLLECT.DTA', stOpen, 1024);
                .
                .

             После инициализации потока все готово к работе.

             TStream это абстрактный механизм потока,  поэтому  вы  будет
        работать не с ним, а с производными от TStream удобными объектами
        потока.  Это будет,  например, TDosStream для выполнения дисковых
        операций  ввода-вывода,  TBufStream  для  буферизованных операций
        ввода-вывода (очень удобен для частых операций считывания или за-
        писи небольших объемов информации на диск) и TEmsStream для пере-
        дачи объектов  в  память EMS (что особенно полезно для реализации
        быстрых ресурсов).

         B.Pascal 7 & Objects/TV#1   - 338 -


             Кроме того,  Turbo Vision реализует индексированные потоки с
        указателем,  указывающим место в потоке. Перемещая этот указатель
        вы можете организовать произвольный доступ в потоке.

                        Чтение из потока и запись в поток
        ─────────────────────────────────────────────────────────────────

             Основной объект потока TStream реализует три главных метода,
        которые вам  нужно четко понимать:  Get,  Put и Error.  Get и Put
        грубо соответствуют процедурам Read и Write, которые вы использу-
        ете в обычных операциях ввода-вывода.  Error - это процедура, ко-
        торая вызывается при появлении ошибок потока.

                                    Метод Put
        ─────────────────────────────────────────────────────────────────

             Давайте сначала рассмотрим процедуру  Put.  Общий  синтаксис
        метода Put следующий:

             SomeStream.Put(PSomeObject);

        где SomeStream - это некоторый производный от TStream объект, ко-
        торый был инициализирован,  а PSomeObject представляет собой ука-
        затель на некоторый производный от TObject объект,  который заре-
        гистрирован с потоком.  Это все, что вам нужно сделать. Поток мо-
        жет из таблицы виртуальных методов PSomeObject узнать,  какой это
        тип объекта (предполагается, что тип зарегистрирован), поэтому он
        знает какой номер идентификатора писать, и сколько после него бу-
        дет данных.

             Специальный интерес для вас,  как для программиста, работаю-
        щего с Turbo  Vision,  состоит в том факте,  что при помещении  в
        поток группы с дочерними окнами, дочерние окна также автоматичес-
        ки помещаются в поток.  Таким образом, запись сложных объектов не
        так уж и сложна, более того, это делается автоматически! Вы може-
        те сохранить  в потоке полное состояние оперативной области.  При
        повторном запуске вашей программы и загрузке диалога будет  выве-
        дено его состояние в момент записи.

                                    Метод Get
        ─────────────────────────────────────────────────────────────────

             Считывание объектов из потока столь же просто.  Все что  вам
        нужно сделать, это вызвать функцию Get:

             PSomeObject := SomeStream.Get;

        где SomeStream  - это инициализированный  поток Turbo  Vision,  а
        PSomeObject - указатель на некоторый тип  объекта  Turbo  Vision.
        Get просто возвращает указатель на нечто,  что он взял из потока.
        Сколько данных было взято и какой тип таблицы виртуальных методов
        (VMT) присвоен данным, определяется не типом PSomeObject, а типом

         B.Pascal 7 & Objects/TV#1   - 339 -

        объекта,  обнаруженным в потоке. Следовательно, если объект в те-
        кущей  позиции SomeStream имеет не совпадающий с PSomeObject тип,
        у вас будет некорректная информация.

             Как и Put,  Get ищет сложные объекты. Следовательно, если вы
        ищите в потоке отображаемый элемент, которое владеет отображаемы-
        ми подэлементами, то они также будут загружены.

                                   Метод Error
        ─────────────────────────────────────────────────────────────────

             И, наконец,  процедура Error определяет что  происходит  при
        возникновении  ошибки  потока.  По умолчанию TStream.Error просто
        устанавливает значение  двух полей в потоке (Status и ErrorInfo).
        Если вы хотите сделать что-либо более  содержательное,  например,
        чтобы  сгенерировать  соответствующее  сообщение  о сбое в работе
        программы или вывести диалоговое окно c сообщением об ошибке, вам
        нужно переопределить процедуру Error.

                                 Закрытие потока
        ─────────────────────────────────────────────────────────────────

             Когда вы закончили использование потока,  вы  вызываете  его
        метод Done, как вы обычно вызывали Close для дискового файла. Как
        и для других объектов Turbo  Vision, это делается следующим обра-
        зом:

             Dispose(SomeStream, Done);

        как для уничтожения объекта потока, так и для его закрытия.

                         Как сделать объекты потоковыми
        ─────────────────────────────────────────────────────────────────

             Все стандартные объекты Turbo  Vision готовы к использованию
        в потоках, и все потоки Turbo  Vision узнают стандартные объекты.
        При изготовлении нового типа объекта, производного от стандартно-
        го объекта, его очень просто подготовить к использованию в потоке
        и известить потоки о его существовании.

                      Методы загрузки и записи Load и Store
        ─────────────────────────────────────────────────────────────────

             Действительное чтение и запись объектов в поток производится
        методами Load и Store.  Каждый объект должен иметь эти методы для
        использования  потока,  поэтому  вы никогда не будете вызывать их
        непосредственно (они вызываются из методов Get и  Put.)  Все  что
        вам  нужно сделать,  это убедиться в том,  что объект знает,  как
        послать себя в поток, когда это потребуется.

             Благодаря объектно-ориентированному программированию это де-
        лается очень просто,  т.к.  большинство механизмов наследуются от
        объекта-предка. Все что должен делать ваш объект, это загружать и

         B.Pascal 7 & Objects/TV#1   - 340 -

        хранить те свои компоненты,  которые вы в него добавляете, об ос-
        тальном позаботится метод предка.  Например,  вы  производите  от
        TWindow  новый  вид окна с именем художника-сюрреалиста Рене Маг-
        ритте, который нарисовал много известных картин с окнами:

             type
              TMagritte = object(TWindow)
                Surreal: Boolean;
                constructor Load(var S: TStream);
                procedure Draw;
                procedure Store(var S: TStream);
              end;

             Все что было добавлено к данным окна -  это  одно  булевское
        поле. Для загрузки объекта вы затем просто считываете стандартный
        TWindow,  а затем считываете дополнительный байт булевского поля.
        Это же относится к записи объекта: вы просто записываете TWindow,
        а затем записываете еще один байт.  Типичные методы Load и  Store
        для производных объектов будут выглядеть следующим образом:

             constructor TMagritte.Load(var S: Stream);
             begin
              inherited Load(S);                        { загрузка типа }
              S.Read(Painted, SizeOf(Boolean));         { чтение
                                                   дополнительных полей }
             end;

             procedure TMagritte.Store(var S: Stream);
             begin
              inherited Store(S);                     { сохранение типа }
              S.Write(Painted, SizeOf(Boolean));      { запись
                                                   дополнительных полей }
             end;

             Вы должны контролировать,  что  записывается  и  загружается
        один и тот же объем данных,  и загрузка данных производится в той
        же  последовательности,  что  и их запись.  Компилятор не покажет
        ошибки.  Если вы будете недостаточно аккуратны,  то могут возник-
        нуть серьезные проблемы. Если вы изменяете поля объекта, то нужно
        изменить и метод Load, и метод Store.

                               Регистрация потока
        ─────────────────────────────────────────────────────────────────

             Кроме определения методов Load и Store для  новых  объектов,
        вы  также  должны зарегистрировать этот новый тип объекта в пото-
        ках. Регистрация - это простой процесс,  который состоит из  двух
        этапов:  сначала определяется запись регистрации потока,  а затем
        она передается глобальной процедуре регистрации RegisterType.

             Для определения записи регистрации  потока  нужно  следовать
        приводимому  ниже  формату.  Запись регистрации потока это запись
        языка Pascal типа TStreamRec,  которая определяется следующим об-

         B.Pascal 7 & Objects/TV#1   - 341 -

        разом:

             PStreamRec = ^TStreamRec;
             TStreamRec = record
                ObjType: Word;
                VmtLink: Word;
                Load: Pointer;
                Store: Pointer;
                Next: Word;
             end;

             По соглашению   всем    регистрационным    записям    потока
        Turbo  Vision присваивается то же имя,  что и соответствующим ти-
        пам объектов,  но начальное "T" заменяется на "R". Следовательно,
        регистрационная запись для TDeskTop будет иметь имя RDeskTop. Та-
        кие абстрактные типы как TObject и TView не имеют регистрационных
        записей,  поскольку их экземпляры вы никогда не будете хранить  в
        потоках.

                         Номера идентификаторов объектов
        ─────────────────────────────────────────────────────────────────

             Вам действительно нужно думать только о поле ObjType записи,
        все остальное делается механически.  Каждому новому определяемому
        вами типу требуется его собственный уникальный идентификатор типа
        в виде числа. Turbo  Vision резервирует регистрационные номера от
        0 до 99 для стандартных объектов,  поэтому  ваши  регистрационные
        номера  будут лежать в диапазоне от 100 до 65535.

             Ответственность за  создание  и  ведение  библиотеки номеров
        идентификаторов для всех ваших новых объектов,  которые будут ис-
        пользоваться  в  потоках  ввода-вывода,  ложиться целиком на вас.
        Нужно сделать эти идентификаторы доступными для пользователей ва-
        ших модулей. Как и для идентификатора меню и определенных пользо-
        вателем сообщений, присваиваемые вами числа могут быть произволь-
        ными,  но они должны быть уникальными и попадать в указанный диа-
        пазон.

                               Автоматические поля
        ─────────────────────────────────────────────────────────────────

             Поле VmtLink это связь с таблицей виртуальных методов объек-
        тов (VMT).  Вы просто задаете его как смещение  типа  вашего объ-
        екта:

             RSomeObject.VmtLink := Ofs(TypeOf(TSomeObject)^);

             Поля Load и Store содержат,  соответственно,  адреса методов
        Load и Store.

             RSomeObject.Load  := @TSomeObject.Load;
             RSomeObject.Store := @TSomeObject.Store;


         B.Pascal 7 & Objects/TV#1   - 342 -

             Значение последнего поля,  Next,  задается RegisterType и не
        требует никакого вмешательства с вашей стороны.  Оно просто обес-
        печивает внутреннее использование скомпонованного списка  регист-
        рационных записей потока.

                              Регистрация на месте
        ─────────────────────────────────────────────────────────────────

             После конструирования регистрационной записи потока вы вызы-
        ваете RegisterType с вашей записью в качестве параметра.  Поэтому
        для регистрации вашего нового объекта TMagritte для его использо-
        вания в потоке вы включаете следующий код:

             const
              RMagritte: TStreamRec = (
                ObjType: 100;
                VmtLink: Ofs(TypeOf(TMagritte)^);
                Load: @TMagritte.Load;
                Store: @TMagritte.Store
              );
             RegisterType(RMagritte);

             Вот и все. Теперь вы можете помещать (Put) экземпляры вашего
        нового типа объекта в любой поток Turbo  Vision и считывать их из
        потоков.

                        Регистрация стандартных объектов
        ─────────────────────────────────────────────────────────────────

             Turbo  Vision определяет  регистрационные записи потоков для
        всех ее  стандартных  объектов.  Кроме того,  каждый модуль Turbo
        Vision определяет процедуру RegisterXXXX,  которая  автоматически
        регистрирует все объекты этого модуля.

                                 Механизм потока
        ─────────────────────────────────────────────────────────────────

             После того, как мы посмотрели на процесс использования пото-
        ков,  следует заглянуть во внутреннюю работу,  которую производит
        Turbo  Vision c вашими объектами с помощью методов Put и Get. Это
        прекрасный  пример взаимодействия объектов и использования встро-
        енных в них методов.

                                   Процесс Put
        ─────────────────────────────────────────────────────────────────

             Когда вы посылаете объект в поток с помощью метода Put,  по-
        ток сначала берет указатель VMT со смещением 0 от объекта и прос-
        матривает список зарегистрированных типов потоков системы с целью
        найти совпадение.  Когда это совпадение найдено,  поток ищет  ре-
        гистрационный номер идентификатора объекта и записывает его в по-
        ток.  Затем поток вызывает метод Store объекта для завершения за-
        писи объекта.  Метод Store использует процедуру потока Write, ко-

         B.Pascal 7 & Objects/TV#1   - 343 -

        торая действительно пишет корректное число байт по месту назначе-
        ния потока.

             Ваш объект не должен ничего знать о потоке - это может  быть
        файл на диске, часть памяти EMS или любой другой вид потока - ваш
        объект просто говорит "запишите меня в поток", и поток делает все
        остальное.

                                   Процесс Get
        ─────────────────────────────────────────────────────────────────

             Когда вы считываете объект из потока с помощью  метода  Get,
        сначала ищется  номер  его  идентификатора,  и просматривается на
        совпадение список  зарегистрированных  типов.  После  обнаружения
        совпадения  регистрационная запись дает потоку местоположение ме-
        тода Load объект и VMT. Затем для чтения нужного объема данных из
        потока вызывается метод Load.

             Вы опять просто говорите потоку,  что нужно взять (Get) сле-
        дующий объект и поместить его в место, определяемое заданным вами
        указателем. Ваш объект даже не беспокоится о том, с каким потоком
        он имеет дело.  Поток сам беспокоится о считывании нужного объема
        данных  из  потока с помощью метода объекта Load,  который в свою
        очередь опирается на метод потока Read.

             Для программиста все это достаточно прозрачно,  но в  то  же
        время вы ясно должны понять, насколько важно зарегистрировать тип
        до проведения каких-либо попыток ввода-вывода с потоком.

                 Обработка указателей объектов со значением nil
        ─────────────────────────────────────────────────────────────────

             Вы можете записать в поток объект nil. Однако, если это сде-
        лать, то в поток запишется слово 0. При считывании идентификатора
        слова 0 поток возвратит указатель nil.  Поэтому 0 считается заре-
        зервированным и не может использоваться в качестве номера иденти-
        фикатора объекта потока.

                         Наборы в потоке: полный пример
        ─────────────────────────────────────────────────────────────────

             В Главе 16,  "Наборы", вы уже видели как наборы могут содер-
        жать разные, но связанные объекты. Это свойство полиморфизма так-
        же применимо и к потокам,  и их можно использовать для записи на-
        боров на диск для последующего обращения,  даже в другой програм-
        ме. Вернемся к примеру COLLECT4.PAS. Что еще нужно добавить в эту
        программу для помещения набора в поток?

             Ответ будет очень простым.  Сначала возьмем  базовый  объект
        TGraphObject  и "научим" его хранить его данные (X и Y) в потоке.
        Для этого нужен метод Store.  Затем определим новый  метод  Store
        для любого производного от TGraphObject объекта, в котором добав-
        ляются  дополнительные  поля  (например,  TGraphCircle  добавляет

         B.Pascal 7 & Objects/TV#1   - 344 -

        RAdius, TGraphRec - Width и Height). Затем построим регистрацион-
        ную запись для каждого типа объекта, который предполагается запи-
        сать,  и  зарегистрируем  все  эти  типы при первом запуске вашей
        программы.  Вот и все.  Остальное будет подобно обычным операциям
        ввода-вывода  в файл:  определяется переменная потока;  создается
        новый поток; одним простым оператором весь набор помещается в по-
        ток, и поток закрывается.

                            Добавление методов Store
        ─────────────────────────────────────────────────────────────────

             Приведем методы   Store.   Обратите   внимание,   что    для
        PGraphEllipse  и PGraphRect не требуются свои собственные методы,
        т.к.  они  не  добавляют  новых   полей   к   унаследованным   от
        PGraphObject:

             type
              PGraphObject = ^TGraphObject;
              TGraphObject = object(TObject)
                   .
                   .
                   .
               procedure Store(var S: Stream); virtual;
             end;

             PGraphCircle = ^TGraphCircle;
             TGraphCircle = object(TGraphObject)
               Radius: Integer;
                   .
                   .
                   .
              procedure Store(var S: Stream); virtual;
             end;

             PGraphRect = ^TGraphRect;
             TGraphRect = object(TGraphObject)
               Width, Height: Integer:
                   .
                   .
                   .
              procedure Store(var S: Stream); virtual;
             end;

             Реализация метода Store вполне очевидна. Каждый объект вызы-
        вает свой унаследованный метод Store,  который хранит все унасле-
        дованные данные. Затем вызывается метод Write для записи дополни-
        тельных данных:

             procedure TGraphObject.Store(var S: TStream);
             begin
               S.Write(Rect, SizeOf(X));
               S.Write(Rect, SizeOf(Y));
             end;

         B.Pascal 7 & Objects/TV#1   - 345 -


             procedure TGraphCircle.Store(var S: TStream);
             begin
               inherited Store(S);
               S.Write(Radius, SizeOf(Radius));
             end;

             procedure TGraphRect.Store(var S: TStream);
             begin
               inherited Store(S);
               S.Write(Width, SizeOf(Width));
               S.Write(Height, SizeOf(Height));
             end;

                   Примечание TGraphObject   не  вызывает  TObject.Store,
              поскольку TObject не содержит данных для записи.

             Обратите внимание,  что метод TStream Write делает  двоичную
        запись. Его первый параметр может быть переменной любого типа, но
        TStream.Write не может узнать размеры этой переменной. Второй па-
        раметр содержит эту информацию, и вы должны придерживаться согла-
        шения относительно использования стандартной функции SizeOf.  Та-
        ким образом, компилятор всегда может гарантировать, что вы всегда
        считываете и записываете нужное количество данных.

                               Записи регистрации
        ─────────────────────────────────────────────────────────────────

             Наш последний шаг состоит в определении константы  регистра-
        ционной записи для каждого производного типа. Хороший прием прог-
        раммирования состоит в следовании соглашению Turbo  Vision  отно-
        сительно использования для имени типа идентификатора,  где вместо
        первой буквы T ставится R.

             Помните о том,  что каждой регистрационной записи присваива-
        ется уникальный номер идентификатора объекта (Objtype). Номера от
        0 до 99 резервируются Turbo  Vision для стандартных объектов. Хо-
        рошо бы отслеживать все номера идентификаторов ваших объектов по-
        тока в некотором центральном месте, чтобы избежать дублирования.

             const
              RGraphPoint: TStreamRec = (
               ObjType: 150;
               VmtLink: Ofs(TypeOf(TGraphPoint)^);
               Load: nil;                      { метод загрузки
                                                 пока отсутствует }
               Store: @TGraphPoint.Store);

              RGraphCircle: TStreamRec = (
               ObjType: 151;
               VmtLink: Ofs(TypeOf(TGraphCircle)^);
               Load: nil;                      { метод загрузки
                                                 пока отсутствует }

         B.Pascal 7 & Objects/TV#1   - 346 -

               Store: @TGraphPoint.Store);

              RGraphCircle: TStreamRec = (
               ObjType: 152;
               VmtLink: Ofs(TypeOf(TGraphRect)^);
               Load: nil;                      { метод загрузки
                                                 пока отсутствует }
               Store: @TGraphRect.Store);

             Вам не нужно регистрационная запись  для  TGraphObject,  так
        как это абстрактный тип, и он никогда не будет помещаться в набор
        или в поток.  Указатель Load каждой регистрационной записи  уста-
        навливается  в  nil,  поскольку  в данном примере рассматривается
        только помещение данных в поток.  В следующем примере методы Load
        будут   определены,   и   изменены  регистрационные  записи  (см.
        программу STREAM2.PAS).

                                   Регистрация
        ─────────────────────────────────────────────────────────────────

             Всегда нужно зарегистрировать каждую из этих записей до про-
        ведения каких-либо операций ввода-вывода с потоком. Самый простой
        способ сделать это состоит в том,  чтобы объединить их все в одну
        процедуру  и вызвать ее в самом начале вашей программы (или в ме-
        тоде Init вашего приложения):

             procedure StreamRegistration;
             begin
               RegisterType(RCollection);
               RegisterType(RGraphPoint);
               RegisterType(RGraphCircle);
               RegisterType(RGraphRect);
             end;

             Обратите внимание,   что    вам    нужно    зарегистрировать
        TCollection (используя его запись RCollection - теперь вы видите,
        что соглашения  о  присваивании  имен упрощают программирование),
        хотя вы и не определили TCollection.  Правило очень простое и за-
        поминаемое: именно  вы отвечаете за регистрацию каждого типа объ-
        екта, который ваша программа будет помещать в поток.

                                 Запись в поток
        ─────────────────────────────────────────────────────────────────

             Нужно следовать  обычной  последовательности  операций  вво-
        да-вывода в файл: создать поток; поместить в него данные (набор);
        закрыть поток. Вам не нужно писать итератор ForEach для помещения
        в поток каждого элемента набора.  Вы просто говорите потоку,  что
        нужно поместить (Put) набор в поток (см. программу STREAM1.PAS):

             var
               GraphicsList:   PCollection;
               GraphicsStream: TBufStream;

         B.Pascal 7 & Objects/TV#1   - 347 -

             begin
              StreamRegistration;    { регистрация всех объектов потока }
               .
               .
               .
              { поместить набор в поток на диске }
              GraphicsStream.Init('GRAPH.SMT', stCreate, 1024);
              GraphicsStream.Put(GraphicsList);        { выходной набор }
              GraphicsStream.Done;                       { сброс потока }
               .
               .
               .
             end.

             В результате создастся  файл на диске, который содержит  всю
        информацию, необходимую  для  "считывания" набора назад в память.
        Когда поток открыт,  и ищется набор, то (см. STREAM2.PAS) восста-
        навливаются  все  скрытые  связи  между набором и его элементами,
        объекты и их таблицы виртуальных методов.  Следующий раздел пояс-
        няет, как помещать в поток объекты, которые содержат связи с дру-
        гими объектами.

                                Как все хранится?
        ─────────────────────────────────────────────────────────────────

             Относительно потоков нужно сделать  важное  предостережение:
        только  владелец объекта должен записывать его в поток.  Это пре-
        достережение  аналогично  традиционному   предостережению   языка
        Паскаль, которое вам должно быть известно: только владелец указа-
        теля может уничтожить его.

             В реальных сложных приложениях множество объектов часто име-
        ют  указатель на конкретную структуру.  Когда возникает необходи-
        мость в выполнении операций ввода-вывода,  вы должны решить,  кто
        "владеет" структурой. Только этот владелец должен посылать струк-
        туру в поток.  Иначе у вас может получиться несколько копий одной
        структуры  в  потоке.  При считывании такого потока будет создано
        несколько экземпляров структуры,  и каждый из первоначальных объ-
        ектов будет указывать на собственную персональную копию структуры
        вместо единственной первоначальной структуры.

                      Экземпляры отображаемых подэлементов
        ─────────────────────────────────────────────────────────────────

             Часто оказывается удобным хранить указатели на группы  отоб-
        ражаемых подэлементов в экземплярах локальных переменных.  Напри-
        мер, диалоговое окно часто хранит указатель на его объекты управ-
        ления в полях с мнемоническими именами для более удобного доступа
        (OKButton или FileINputLine). При включении отображаемого элемен-
        та в группу отображаемых элементов, владелец будет иметь два ука-
        зателя на отображаемый подэлемент,  один - в поле, и еще один - в
        списке отображаемых подэлементов.  Если на это не обратить внима-
        ния, то считывание такого объекта из потока приведет к дублирова-

         B.Pascal 7 & Objects/TV#1   - 348 -

        нию.

             Решение состоит в использовании методов TGroup GetSubViewPtr
        и PutSubViewPtr. При хранении поля, которое является отображаемым
        подэлементом, вместо записи указателя, как если бы это была прос-
        тая переменная, вы вызываете метод PutSubViewPtr, который записы-
        вает ссылку  на  порядковую  позицию  отображаемого подэлемента в
        списке подэлементов группы.  Таким образом,  при загрузке  (Load)
        группы обратно из потока, вы вызываете метод GetSubViewPtr, кото-
        рый гарантирует, что поле и список отображаемых подэлементов ука-
        зывают на один и тот же объект.

             Приведем короткий   пример   использования   GetChildPtr   и
        PutChildPtr в простом окне:

             type
              TButtonWindow = object(TWindow)
                Button: PButton;
                constructor Load(var S: TStream);
                procedure Store(var S: TStream); virtual;
                  .
                  .
                  .
             end;

             constructor TButtonWindow.Load(var S: TStream);
             begin
               inherited Load(S);
               GetSubView(S, Button);
             end;

             procedure TButtonWindow.Store(var S: TStream);
             begin
               inherited Store(S);
               PutSubViewPtr(S, Button);
             end;

             Давайте посмотрим теперь,  чем  метод  Store  отличается  от
        обычного метода Store. После записи окна обычным образом все, что
        нужно сделать - это запись вместо самого поля, как это обычно де-
        лается,  ссылки  на поле Button.  Фактически,  когда вы вызываете
        TWindow.Store, объект командной кнопки записывается как отобража-
        емый подэлемент. Все, что вам нужно сделать кроме этого - это по-
        мещения в поток информации, указывающей, что Button должно указы-
        вать на этот подэлемент. Метод Load делает то же самое в обратном
        порядке,  сначала загружая окно и  его  отображаемые  подэлементы
        (командные  кнопки),  а  затем  восстанавливая  указатель на этот
        отображаемый подэлементов в Button.

              Создание экземпляров братских отображаемых элементов
        ─────────────────────────────────────────────────────────────────

             Аналогичная ситуация  может  возникнуть,  если  отображаемый

         B.Pascal 7 & Objects/TV#1   - 349 -

        элемент имеет поле, указывающее на одного из его "братьев". Отоб-
        ражаемый  элемент называется братом другого отображаемого элемен-
        та,  если они оба принадлежат одной и той же  группе.  Прекрасным
        примером этого является объект прокрутки.  Поскольку объект прок-
        рутки знает о двух полосах прокрутки,  которые  являются  членами
        одного  и того же окна,  которое содержит элемент прокрутки.  Оно
        содержит два поля,  которое указывает на эти отображаемые элемен-
        ты.

             Как и для отображаемых подэлементов,  при чтении  и  записи
        ссылок на братские отображаемые элементы в поток могут возникнуть
        проблемы. Решение   также   будет   аналогичным.   Методы   TView
        PutPeerViewPtr и GetPeerViewPtr предоставляют средства доступа  к
        порядковой  позиции другого отображаемого элемента в списке отоб-
        ражаемых подэлементов объекта-владельца.

             Единственно о чем нужно побеспокоиться,  так это о  загрузке
        ссылок на братские отображаемые элементы, которые еще не загруже-
        ны (т.е. в списке отображаемых подэлементов они идут ниже и, сле-
        довательно, позднее в потоке). Turbo Vision автоматически обраба-
        тывает эту ситуацию,  отслеживая все подобные  будущие  ссылки  и
        разрешая  их  после загрузки всех отображаемых подэлементов.  Вам
        нужно иметь в виду,  что ссылки на братские отображаемые элементы
        не будут действовать,  пока Load не выполнится целиком.  Принимая
        это во внимание,  вы не должны помещать в Load никакой код, кото-
        рый использует отображаемые подэлементы, зависящие от их братских
        отображаемых элементов,  поскольку в этом случае результат  может
        быть непредсказуемым.

                               Копирование потока
        ─────────────────────────────────────────────────────────────────

             TStream имеет метод CopyFrom(S,Count),  который копирует за-
        данное число  байт (Count) из заданного потока S.  Метод CopyFrom
        может быть использован для копирования содержимого одного  потока
        в другой.  Если,  например, вы циклически обращаетесь к дисковому
        потоку, то можете скопировать его в поток EMS для организации бо-
        лее быстрого доступа:

             NewStream := New(TEmsStream, Init(OldStream^.GetSize));
             OldStream^.Seek(0);
             NewStream^.CopyFrom(OldStream, OldStream^.GetSize);

                          Потоки произвольного доступа
        ─────────────────────────────────────────────────────────────────

             До этого  момента  мы работали с потоками как с устройствами
        последовательного доступа:  вы помещали (Put) объекты в конец ва-
        шего потока и считывали их назад (Get) в той же последовательнос-
        ти. Но Turbo  Vision имеет и более мощные средства.  Имеется воз-
        можность  рассматривать  поток  как виртуальное устройство произ-
        вольного доступа.  Кроме методов Get и Put, которые соответствуют
        Read и Write при работе с файлом, потоки обладают средствами про-

         B.Pascal 7 & Objects/TV#1   - 350 -

        ведения операций Seek, FilePos, FileSize и Truncate.

             - Процедура потока Seek перемещает текущий указатель  потока
               к  заданной  позиции  (число  байт от начала потока),  как
               стандартная процедура Seek языка Паскаль.

             - Процедура  GetPos  по  своему  действию  обратна процедуре
               Seek.  Она возвращает значение Longint с текущей  позицией
               потока.

             - Функция GetSize возвращает размер потока в байтах.

             - Процедура Truncate удаляет все данные, которые расположены
               после текущей позиции потока, при этом текущая позиция по-
               тока становится концом потока.

             Поскольку работа  с  этими программами очень удобна,  потоки
        произвольного доступа требуют от вас отслеживать вне  потока  ин-
        декс,  отмечающий  начальную позицию каждого объекта в потоке.  В
        этом случае для хранения индекса вы можете прекрасно использовать
        набор. Фактически,  эти средства используются Turbo Vision в фай-
        лах ресурсов.  Если вы хотите использовать поток  с  произвольным
        доступом, посмотрите, нельзя ли для этого применить файл ресурса.

                   Примечание: Ресурсы описываются в Главе 18 "Ресурсы".

                          Необъектные элементы потоков
        ─────────────────────────────────────────────────────────────────

             В поток  можно  записывать  и элементы,  которые не являются
        объектами,  но для этого следует использовать несколько иной под-
        ход. Стандартные методы потока Get и Put требуют загрузки или за-
        писи объекта, производного от TObject. Если вам нужно создать по-
        ток, который состоит не из объектов, переходите на нижний уровень
        процедур Read и Write,  где в поток записывается или из него счи-
        тывается заданное число байт.  Этот же механизм используют методы
        Get и Put для чтения и записи данных об объектах. Вы просто обхо-
        дите механизм таблицы виртуальных методов (VMT),  который заложен
        в Put и Get.

                  Разработка пользователем собственных потоков
        ─────────────────────────────────────────────────────────────────

             Данный раздел суммирует возможности методов и обработки оши-
        бок потоков Turbo  Vision, чтобы вы знали, что можно использовать
        для создания новых типов потоков.

             Сам TStream является абстрактным объектом и его можно расши-
        рить  для  создания  удобного  типа  потока.  Большинство методов
        TStream являются абстрактными и должны быть  реализованы  как  их
        производные   методы,   основывающиеся   на  абстрактных  методах
        TStream. Полностью реализованы только методы  Error,  Get  и  Put
        объекта TStream.  GetPos, GetSize, Read, Seek, SetPos, Truncate и

         B.Pascal 7 & Objects/TV#1   - 351 -

        Write должны быть переопределены.  Если производный  тип  объекта
        имеет буфер, то должен быть переопределен и метод Flush.

                             Обработка ошибок потока
        ─────────────────────────────────────────────────────────────────

             TStream имеет метод Error(Code,  Info),  который  вызывается
        при  обнаружении  ошибки  потока.  Error  просто присваивает полю
        Status потока значение одной из констант,  приведенных в Главе 21
        "Справочник по Turbo  Vision" в разделе "Константы stXXXX".

             Поле ErrorInfo  не определено,  если значение Status не есть
        stGetError  или  stPutError.  Если  значение  поля  Status  равно
        stGetError, то поле ErrorInfo содержит номер идентификатора пото-
        ка незарегистрированного типа.  Если значение поля  Status  равно
        stPutError,  то поле ErrorInfo содержит смещение в таблице вирту-
        альных методов типа,  который вы пытались поместить в  поток.  Вы
        можете переписать TStream.Error для генерации любого уровня обра-
        ботки ошибок, включая ошибки этапа выполнения.

                                 Версии потоков
        ─────────────────────────────────────────────────────────────────

             Turbo Vision  2.0  поддерживает  ограниченную форму создания
        версий потоков.  Версии позволяют приложениям,  написанным с  по-
        мощью версии 2.0 считывать объекты из потоков, созданных в версии
        1.0. Потоки,  записанные в версии 2.0,  включающие в себя новые и
        измененные в  данной  версии объекты не считываются приложениями,
        написанными в версии 1.0.

                                  Флаги версий
        ─────────────────────────────────────────────────────────────────

            В поле Options в объектах Turbo Vision,  имеющих поля, отлич-
        ные  от  соответствующих  объектов  версии  1.0,  установлен  бит
        ofVersion20. В версии 1.0 это бит не определен.

                           Работа в различных версиях
        ─────────────────────────────────────────────────────────────────

             Конструкторами Load версии 2.0 обработка версий  выполняется
        прозрачно.  После вызова наследуемых конструкторов Load они прос-
        матривают бит ofVersion считанного поля Options.  Затем на основе
        установки  этого бита Load считывает остальную часть объекта (как
        он был записан),  но записывает информацию, как внутренний объект
        версии 2.0.

             Методы Store  версии  2.0  записывают  только объекты версии
        2.0.
             В программах  версии  2.0  вы  без  изменения можете считать
        стандартные объекты,  записанные в приложениях версии  1.0  Turbo
        Vision.

         B.Pascal 7 & Objects/TV#1   - 352 -

─────────────────────────────────────────────────────────────────────────
                              ГЛАВА 18. Ресурсы
        ─────────────────────────────────────────────────────────────────

             Файл ресурсы  -  это объект Turbo Vision,  который сохраняет
        передаваемые в него объекты и затем выполняет их поиск по именам.
        Ваша  программа  т.о.  получает возможность выполнять поиск своих
        объектов в ресурсе,  а не инициализировать их. Вместо того, чтобы
        ваша программа инициализировала объекты,  вы можете иметь отдель-
        ную программу  для  создания  всех  объектов  и  сохранять  их  в
        ресурсе.

             Этот механизм  вполне прост:  файл ресурса действует подобно
        потоку с произвольным доступом.  Доступ к объектам в нем осущест-
        вляется по ключам,  которые представляют собой уникальные строки,
        идентифицирующие ресурсы.

             В отличие от других средств Turbo Vision вам,  вероятно,  не
        потребуется изменять механизм ресурсов. Ресурсы являются мощным и
        гибким средством. Вы должны лишь обучиться ими пользоваться.

                       Преимущества использования ресурсов
        ─────────────────────────────────────────────────────────────────

             Использование файла ресурса имеет ряд преимуществ.

             Использование ресурсов  позволяет   настраивать   прикладные
        программы  без изменения фрагментов программ.  Например,  и текст
        блоков диалога,  и метки пунктов меню,  и цвета отображаемых эле-
        ментов  могут  быть  изменены внутри ресурса,  при этом вид вашей
        прикладной программы изменится без постороннего вмешательства.

             Обычным путем  фрагмент  программы можно сохранить,  помещая
        все методы Init  вашего объекта  в  отдельную  программу.  Методы
        Init  часто бывают весьма сложными,  содержат вычисления и другие
        операции,  упрощающие остальную часть вашего фрагмента программы.
        В вашей прикладной программе имеется также метод Load для каждого
        объекта,  но по сравнению с Init  он достаточно тривиален. Обычно
        с помощью ресурса вы сможете сэкономить от 8 до 10% объема вашего
        программного кода.

             Использование ресурса  упрощает  также  работу с прикладными
        программами, написанными  на  специфических  языках.   Прикладная
        программа выполняет  загрузку  объектов по именам,  которым соот-
        ветствует представляемый ими язык.

             Если вам требуется разработать варианты прикладной программы
        с различными возможностями, вы можете, к примеру, создать два на-
        бора меню, один из которых будет обеспечивать доступ ко всем воз-
        можностям программы,  а другой - к ограниченному набору ее  функ-
        ций. В  этом  случае  вам  совсем не потребуется переписывать ваш
        фрагмент программы,  а также предполагать  случайное  уничтожение
        неверной части  программы.  Вы  можете  полностью реализовать все
        функциональные возможности программы  с  помощью  нового  ресурса

         B.Pascal 7 & Objects/TV#1   - 353 -

        вместо замены всей программы.

             Короче говоря, ресурс изолирует представление объектов в ва-
        шей программе и облегчает ее изменение.

                               Содержимое ресурса
        ─────────────────────────────────────────────────────────────────

             Прежде, чем  более  детально  ознакомиться  с ресурсами,  вы
        должны убедиться, что хорошо разобрались с материалом о потоках и
        наборах, т.к.  и те,  и другие используются в механизме ресурсов.
        Вы можете использовать ресурсы,  не зная их действия,  но если вы
        захотите их изменить каким-либо образом, вы должны знать, что бу-
        дете в них помещать.

             TResourсeFile содержит  как отсортированный строковый набор,
        так и поток.  Строки набора являются ключами к объектам в потоке.
        TResourceFile имеет метод Init,  который имеет входным параметром
        поток, а также метод Get, который имеет входным параметром строку
        и возвращает объект.

                                Создание ресурса
        ─────────────────────────────────────────────────────────────────

             Создание файла  ресурса  представляет  собой  четырехшаговый
        процесс. Вы должны открыть поток,  инициализировать  в  нем  файл
        ресурсов, сохранить  один или несколько объектов с их ключами,  и
        закрыть ресурс.

             Следующий фрагмент  программы  создает простой файл ресурсов
        MY.TVR, содержащий  один  ресурс:  строку  состояния   с   ключом
        'Waldo'.

             program Resourс1;

             uses Drivers, Objects, Views, App, Menus;

             type
               PHaltStream = ^THaltStream;
               THaltStream = object(TBufStream)
                 procedure Error(Code, Info: Integer);virtual;
               end;

             const cmNewDlg = 1001;
             var
               MyRez: TResourceFile;
               MyStrm: PHaltStream;

             procedure THaltStream.Error(Code, Info: Integer);
             begin
               Writeln('Stream error: ', Code, ' (', Info, ')');
               Halt(1);
             end;

         B.Pascal 7 & Objects/TV#1   - 354 -


             procedure CreateStatusLine;
             var
               R: TRect;
               StatusLine: PStatusLine;
             begin
               Assign(0, 24, 80, 25);
               StatusLine := New(PStatusLine, Init(R,
                NewStatusDef(0, $FFFF,
                 NewStatusItem('~Alt-X~ Exit', AltX, cmQuit,
                 NewStatusItem('~F3~ Open', F3Key, cmNewDlg,
                 NewStatusItem('~F5~ Zoom', F5Key, cmZoom,
                 NewStatusItem('~Alt-F3~ Close', AltF3, cmClose,
                 nil)))),
               nil)
               ));
               MyRez.Put(StatusLine, 'Waldo');
               Dispose(StatusLine, Done);
             end;

             begin
               MyStrm := New(PHaltStream, Init('MY.TVR', stCreate, 1024));
               MyRez.Init(MyStrm);
               RegisterType(RStatusLine);
               CreateStatusLine;
               MyRez.Done;
             end.

                                 Чтение ресурса
        ─────────────────────────────────────────────────────────────────

             Выполнить поиск ресурса в файле ресурсов так же просто,  как
        извлечь объект из потока:  вы должны вызвать  функцию  Get  файла
        ресурсов с  нужным  вам ключом ресурса в качестве параметра.  Get
        возвратит указатель на общий объект PObject.

             Созданный в предыдущем примере ресурс строки состояния может
        быть обнаружен и использован  в  прикладной  программе  следующим
        образом:

             program MyApp;

             uses Objects, Drivers, Views, Menus, Dialogs, App;

             var
               MyRez: TResourceFile;

             type
               PMyApp = ^TMyApp;
               TMyApp = object(TApplication)
                 constructor Init;
                 procedure InitStatusLine; virtual;
               end;

         B.Pascal 7 & Objects/TV#1   - 355 -


             constructor TMyApp.Init;
             const
               MyResFileName: FName = 'MY.TVR';
             begin
               MyRez.Init(New(PBufStream, Init(MyRezFileName, stOpen,
                              1024)));
               if MyRez.Stream^.Status <> 0 then Halt(1);
               RegisterType(RStatusLine);
               TApplication.Init;
             end;

             procedure TMyApp.InitStatusLine;
             begin
               StatusLine := PStatusLine(MyRez.Get('Waldo'));
             end;

             var ValdoApp: TMyApp;
             begin
               WaldiApp.Init;
               WaldiApp.Run;
               WaldiApp.Done;
             end.

             При считывании объекта из ресурса вы должны  учитывать  воз-
        можность получения указателя nil. Если имя вашего индекса неверно
        (т.е. в файле нет ресурса с таким ключом), функция Get возвращает
        nil. После отладки программы с ресурсом эта проблема отпадает.

             Вы можете неоднократно считывать объект из ресурса.  Малове-
        роятно, что вы  захотите  проделать  это,  например,  со  строкой
        состояния, но,  например,  пользователь может потребовать многок-
        ратного использования блока диалога в процессе  выполнения  прик-
        ладной программы.  Ресурс многократно выдает объект по  его  зап-
        росу.

             Здесь могут возникнуть потенциальные  проблемы  с  медленным
        вводом-выводом с диска, даже в том случае, если файл ресурсов бу-
        феризован. Вы можете отрегулировать буферизацию вашего диска, или
        скопировать поток в поток ESM, если у вас имеется память EMS.

                                  Списки строк
        ─────────────────────────────────────────────────────────────────

             Кроме стандартного механизма ресурсов Turbo Vision  распола-
        гает  двумя  специализированными  объектами для обработки списков
        строк.  Список строк - это специальный объект доступа к ресурсам,
        который обеспечивает вашей программе доступ к строкам ресурсов по
        номерам (обычно  выраженным  в  виде  констант)  вместо  ключевых
        строк.  Это  дает  возможность  программе  хранить строки в файле
        ресурсов для облегчения их приспособления и интернационализации.

             Например, в интегрированной среде Турбо Паскаля  IDE  объект

         B.Pascal 7 & Objects/TV#1   - 356 -

        списка  строк  используется для выдачи всех сообщений об ошибках.
        Это означает,  что программа может вызвать сообщение об ошибке по
        номеру,  а для различных версий для различных стран в их ресурсах
        будут помещаться соответственно разные строки.

             Объект списка  строк по конструкции не обладает большой гиб-
        костью, но в эксплуатации  он  удобен  и  имеет  высокое  быстро-
        действие.

             Объект TStringList обеспечивает доступ к  строкам.  Создание
        списка строк требует использования объекта TStrListMaker. Регист-
        рационные записи обоих этих объектов будут иметь одинаковый номер
        типа объекта.

             Объект списка  строк  не  имеет  метода  Init.  Единственным
        конструктором у него является метод Load,  т.к.  списки строк су-
        ществуют лишь в файлах  ресурсов.  Таким  же  образом,  поскольку
        список строк  является  в  сущности  только  ресурсом  для чтения
        строк, он имеет функцию Get и не имеет процедуры Put.

                             Создание списков строк
        ─────────────────────────────────────────────────────────────────

             Тип объекта TStrListMaker используется для  создания  списка
        строк в  файле  ресурсов,  который  будет  применяться  вместе  с
        TStringList. В отличие от списка строк,  предназначенного  только
        для чтения  строк,  объект-создатель  списка  строк  предназначен
        только для записи строк. С помощью этого объекта вы можете иници-
        ализировать список строк,  последовательно записать в него строки
        и сохранить полученный список в потоке.
