Отладчик GDB
=============

Отладчиком называется программа, которая выполняет внутри себя другую программу. 
Основное назначение отладчика - дать возможность пользователю в определенной 
степени осуществлять контроль за выполняемой программой, то есть определять, 
что происходит в процессе ее выполнения. Наиболее известным отладчиком для 
Linux является программа GNU GDB. GDB содержит множество полезных возможностей, 
но для простой отладки достаточно использовать лишь некоторые из них.

Когда Вы запускаете программу, содержащую ошибки, обнаруживаемые лишь на стадии 
выполнения, есть несколько вопросов, на которые Вам нужно найти ответ.

*Какое выражение или оператор в программе вызывает ошибку?
*Если ошибка возникает в результате вызова функции, в каком месте программы 
происходит этот вызов?
*Какие значения содержат переменные и параметры программы в определенной 
точке ее выполнения?
*Что является результатом вычисления выражения в определенном месте 
программы?
*Каков действительный порядок выполнения операторов программы?

Эти действия требуют, чтобы пользователь отладчика был в состоянии

*проанализировать данные программы;
*получить трассу - список вызовов функций, которые были выполнены, с 
сортировкой, указывающей кто кого вызывал;
*установить точки останова, в которых выполнение программы 
приостанавливается, чтобы можно было проанализировать данные;
*выполнять программу по шагам, чтобы увидеть, что в действительности происходит.

GDB предоставляет все перечисленные возможности. Он называется отладчиком на 
уровне исходного текста, создавая иллюзию, что Вы выполняете операторы C++ из 
Вашей программы, а не машинный код, в который они действительно транслируются.

Для иллюстрации мы используем систему, которая компилирует программы на C++ в 
исполняемые файлы, содержащие машинный код. В результате этого процесса 
информация об оригинальном коде C++ теряется при трансляции. Отдельный 
оператор C++ обычно преобразуется в несколько машинных команд, а большинство 
имен локальных переменных просто теряется. Информация о именах переменных и 
операторах C++ в Вашей исходной программе не является необходимой для ее 
выполнения. Поэтому, для правильной работы отладчика на уровне исходного 
текста, компилятор должен поместить в программу некоторую дополнительную 
информацию. Обычно ее добавляют к информации, используемой компоновщиком, 
в исполняемый файл.

Чтобы указать компилятору (gcc), что Вы планируете отлаживать Вашу программу, 
и поэтому нуждаетесь в дополнительной информации, добавьте ключ *-g* в опции 
компиляции и компоновки. Например, если Ваша программа состоит из двух файлов 
main.C и utils.C, Вы можете откомпилировать ее командами

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
gcc -c -g -Wall main.C
gcc -c -g -Wall utils.C
gcc -g -o myprog main.ob utils.o
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

или одной командой

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
gcc -g -Wall -o myprog main.o utils.o
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Обе последовательности команд приводят к созданию исполняемого файла myprog.

чтобы выполнить полученную программу под управлением gdb, введите

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
gdb myprog
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Вы увидите командное приглашение GDB:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(gdb)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Это очень простой, но эффективный тексовый интерфейс отладчика. Его вполне 
достаточно, чтобы ознакомиться с основными командами gdb.

Когда GDB запускается, Ваша программа в нем еще не выполняется; Вы должны 
сами сообщить GDB, когда ее запустить. Как только программа приостанавливается 
в процессе выполнения, GDB ищет определенную строку исходной программы с 
вызовом определенной функции - либо строку в программе, где произошел останов, 
либо строку, содержащую вызов функции, в которой произошел останов, либо строку 
с вызовом функции и т.д. Далее используется термин ``текущее окно'', чтобы 
сослаться на точку останова.

Как только возникает командное приглашение, Вы можете использовать следующие 
команды.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
help command
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Выводит краткое описание команды GDB. Просто help выдает список доступных 
разделов справки.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
run command-line-arguments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Запускает Вашу программу с определенными аргументами командной строки. 
GDB запоминает переданные аргументы, и простой перезапуск программы с помощью 
run приводит к использованию этих аргументов.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
where
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Создает трассу - цепочку вызовов функций, произошедших до попадания 
программы в текущее место. Синонимом является команда bt.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
up
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Перемещает текущее окно так, чтобы GDB анализировал место, из которого 
произошел вызов данного окна. Очень часто Ваша программа может войти в
библиотечную функцию - такую, для которой не доступен исходный код, 
например, в процедуру ввода-вывода. Вам может понадобиться несколько команд up, 
чтобы перейти в точку программы, которая была выполнена последней.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
down
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Производит эффект, обратный up.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
print E
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Выводит значение E в текущем окне программы, где E является выражением 
C++ (обычно просто переменной). Каждый раз при использовании этой команды, 
GDB нумерует ее упоминание для будущих ссылок. Например,

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(gdb) print A[i] $2 = -16

(gdb) print $2 + ML $3 = -9
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

сообщает нам, что величина A[i] в текущем окне равна -16, и что при 
добавлении этого значения к переменной ML получится -9.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
quit
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Выход из GDB.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Ctrl-c
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Если программа запущена через оболочку shell, Ctrl-c немедленно прекращает 
ее выполнение. В GDB программа приостанавливается, пока ее выполнение не 
возобновится.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
break place
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Установить точку останова; программа приостановится при ее достижении. 
Простейший способ - установить точку останова после входа в функцию, например

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(gdb) break MungeData Breakpoint 1 at 0x22a4: file main.C, line 16.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Команда break main остановит выполнение в начале программы.

Вы можете установить точки останова на определенную строку исходного кода:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(gdb) break 19 Breakpoint 2 at 0x2290: file main.C, line 19.

(gdb) break utils.C:55 Breakpoint 3 at 0x3778: file utils.C, line 55.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Когда Вы запустите программу и она достигнет точки останова, Вы увидите 
сообщение об этом и приглашение, например

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Breakpoint 1, MungeData (A=0x6110, N=7) at main.c:16

(gdb)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
delete N
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Удаляет точку останова с номером N. Если опустить N, будут удалены все 
точки останова.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cont или continue
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Продолжает обычное выполнение программы.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
step
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Выполняет текущую строку программы и останавливается на следующем 
операторе для выполнения.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
next
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Похожа на step, однако, если текущая строка программы содержит вызов 
функции (так что step должен будет остановиться в начале функции), не входит 
в эту функцию, а выполняет ее и переходит на следующий оператор.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
finish
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Выполняет команды next без остановки, пока не достигнет конца текущей функции.

--------------------------------------------------------------------------------
Вход и выход из GDB

Эта глава посвящена тому, как запустить GDB и как из него выйти. 
Основные принципы:

    введите `gdb' для вызова GDB.
    введите quit или C-d для выхода из него. 

Вызов GDB

Вызывайте GDB путем запуска программы gdb. Начав работу, GDB считывает 
команды с терминала до тех пор, пока вы не скажете ему выйти.

Вы также можете запустить gdb с различными аргументами и ключами, чтобы в 
самом начале лучше настроить среду отлаживания.

Ключи командной строки, описанные здесь, предназначены для охвата различных 
ситуаций; в дейтсвительности, в некоторых средах часть этих ключей может 
быть недоступна.

Чаще всего GDB вызывается с одним аргументом, который определяет 
исполняемую программу:

gdb программа

Вы также можете указать при старте как исполняемую программу, так и 
файл дампа памяти:

gdb программа дамп

Если вы хотите отладить выполняющийся в данный момент процесс, то вместо 
этого, вы можете указать вторым аргументом идентификатор этого процесса:

gdb программа 1234

присоединит GDB к процессу 1234 (если, конечно, у вас нет файла с именем 
`1234', GDB сначала проверяет наличие файла дампа памяти).

Преимущества, которые можно получить при использовании второго аргумента 
командной строки, требуют наличия достаточно совершенной операционной системы; 
если вы используете GDB как удаленный отладчик, присоединенный к компьютеру 
без операционной системы, там вообще может не быть понятия "процесса", и 
часто нет никакого способа получить дамп. GDB предупредит вас, если ему не 
удается присоединиться к процессу или считать файл дампа памяти.

Вы можете запустить gdb без вывода начального сообщения, описывающего 
отсутствие гарантии на него, указав -silent:

gdb -silent

Кроме того, вы можете контролировать процесс запуска GDB с помощью ключей 
командной строки. GDB может сам напомнить вам о доступных ключах.

Введите

gdb -help

чтобы вывести на экран все доступные опции с кратким описанием их 
использования (сокращенный эквивалент---`gdb -h').

Все заданные вами ключи и параметры командной строки обрабатываются 
последовательно. Порядок становится важным при использовании ключа `-x'.
Выбор файлов

При запуске, GDB считывает параметры, отличные от ключей, как указатели 
на исполняемую программу и файл дампа (или идентификатор процесса), точно 
так же, как если бы эти параметры задавались ключами `-se' и `-c' 
соответственно. (GDB считает первый параметр, не имеющий соответствующего 
флага ключа, эквивалентом ключа `-se', за которым следует этот параметр; 
а второй параметр, не имеющий соответствующего флага ключа, если он есть, 
эквивалентом ключа `-c', за которым следует этот параметр.)

Если GDB был сконфигурирован без включения поддержки файлов дампа, что имеет 
место для большинства встроенных целей, то он выразит недовольство вторым 
аргументом и проигнорирует его.

Многие ключи имеют как длинную, так и краткую формы; в следующем списке 
приводятся обе. GDB также распознает сокращения длинных форм, не являющиеся 
двусмысленными. (Вы можете, по желанию, обозначать ключи с помощью `--', а 
не `-', хотя мы показываем наиболее употребляемый формат.)

-symbols файл
-s файл
    Читать таблицу символов из файла файл. 
-exec файл
-e файл
    Использовать файл как исполняемый для выполнения и исследования данных 
вместе с дампом памяти, когда это необходимо. 
-se файл
    Читать таблицу символов из файла файл и использовать его как исполняемый 
файл. 
-core файл
-c файл
    Использовать файл как дамп памяти для исследования. 
-c номер
    Присоединиться к процессу с идентификатором номер, также, как по команде 
attach (при условии, что нет файла в формате дампа памяти с именем номер; 
в этом случае `-c' определяет этот файл как дамп для считывания). 
-command файл
-x файл
    Выполнить команды GDB из файла файл. See section Командные файлы. 
-directory каталог
-d каталог
    Добавить каталог к путям поиска файлов с исходными текстами. 
-m
-mapped
    Предупреждение: этот ключ зависит от возможностей операционной системы, 
которые реализованы не везде.
    Если отображаемые в память файлы поддерживаются в вашей системе через 
системный вызов mmap, вы можете использовать этот ключ, чтобы GDB записывал 
символы из вашей программы в файл в текущем каталоге, допускающий повторное 
использование. Если программа, которую вы отлаживаете, называется `/tmp/fred', 
то отображаемым символьным файлом будет `/tmp/fred.syms'. Последующие 
отладочные сеансы GDB замечают наличие этого файла и могут быстро отобразить 
в память символьную информацию из него, а не читать таблицу символов из 
выполняемого файла. Файл `.syms' специфичен для рабочей машины, на которой 
запускается GDB. Он содержит точный образ внутренней символьной таблицы GDB. 
Он не может быть разделен между несколькими рабочими платформами. 
-r
-readnow
    Читать символьную таблицу каждого файла, содержащего таблицу символов, 
сразу целиком, а не стандартным образом, при котором она считывается 
постепенно по мере необходимости. Эта команда замедляет запуск, но дальнейшие 
операции производятся быстрее. 

Ключи -mapped и -readnow обычно используются вместе, чтобы построить файл 
`.syms', который содержит полную информацию о символах. (See section Команды 
для задания файлов, для информации о файлах `.syms'.) Вот простой вызов GDB, 
не делающий ничего, кроме построения файла `.syms' для использования в будущем:

gdb -batch -nx -mapped -readnow имя-программы

Выбор режимов

Вы можете вызывать GDB в различных альтернативных режимах---например, в 
пакетном или в "тихом" режиме.

-nx
-n
    Не выполнять команды ни из каких файлов инициализации (обычно назваемых 
`.gdbinit', или `gdb.ini' на PC). В нормальном режиме, GDB выполняет команды 
из этих файлов после обработки всех командных ключей и параметров. 
See section Командные файлы. 
-quiet
-silent
-q
    "Тихий". Не печатать вводное сообщение и информацию об авторских правах. 
Эти сообщения также подавляются в пакетном режиме. 
-batch
    Выполняться в пакетном режиме. Выйти со значением 0 после обработки всех 
командных файлов, заданных ключем `-x' (и всех команд из инициализационных 
файлов, если это не запрещено ключем `-n'). Выйти с ненулевым значением, если 
во время выполнения команд GDB из командных файлов произойдет ошибка. Пакетный 
режим может быть полезен при вызове GDB как фильтра; например, чтобы загрузить 
программу и запустить ее на другом компьютере. Для того, чтобы сделать 
это более удобным, сообщение

    Program exited normally.

    (которое обычно выдается при завершении программы, выполняемой под 
управлением GDB), при выполнении в пакетном режиме не выдается. 
-nowindows
-nw
    "Без окон". Если GDB имеет встроенный графический интерфейс пользователя 
(GUI), то этот ключ велит GDB использовать только интерфейс командной строки. 
Если GUI недоступен, этот ключ не оказывает никакого действия. 
-windows
-w
    Если GDB включает GUI, этот ключ требует использовать его, если только 
возможно. 
-cd каталог
    Запустить GDB, используя в качестве рабочего каталога каталог, вместо 
текущего. 
-fullname
-f
    GNU Emacs устанавливает этот ключ, когда вызывает GDB как подпроцесс. 
Это велит GDB выводить полное имя файла и номер строки в стандартном, 
распознаваемом стиле всякий раз, когда отображается кадр стека (что включает 
каждую остановку вашей программы). Этот распознаваемый формат выглядит как 
два знака `\032', за которыми следует имя файла, номер строки и символьная 
позиция, разделенные двоеточиями, и знак новой строки. Программа интерфейса 
Emacs-GDB использует два знака `\032' как сигнал для отображения исходного 
текста для кадра. 
-epoch
    Интерфейс Emacs-GDB Epoch устанавливает этот ключ, когда вызывает GDB как 
подпроцесс. Это велит GDB изменить свои подпрограммы печати так, чтобы позволить 
Epoch отображать значения выражений в отдельном окне. 
-annotate уровень
    Этот ключ устанавливает уровень примечаний внутри GDB. Его эффект аналогичен 
использованию `set annotate уровень' (see section Примечания GDB). Уровень 
примечаний контролирует, какое количество информации GDB выводит вместе с 
приглашением, значениями выражений, строками исходного текста и другими 
типами вывода. Уровень 0 является обычным, уровень 1 используется, когда 
GDB выполняется как подпроцесс GNU Emacs, уровень 2 выводит максимальное 
количество примечаний и подходит для программ, которые управляют GDB. 
-async
    Использовать асинхронный цикл событий для интерфейса командной строки. 
GDB обрабатывает все события, такие как ввод пользователя с клавиатуры, 
через специальный цикл событий. Это позволяет GDB принимать и обрабатывать 
команды пользователя параллельно с выполнением отлаживаемого процесса(4), 
так что вы не должны ждать возвращения управления GDB, прежде чем ввести 
следующую команду. (Замечание: в версии 5.0, асинхронное выполнение на 
целевой системе еще не поддерживается, так что режим `-async' еще реализован 
не полностью.) Когда стандартный ввод соединен с терминальным устройством, 
GDB по умолчанию использует асинхронный цикл событий, если это не отключено 
ключем `-noasync'. 
-noasync
    Отключить асинхронный цикл событий для интерфейса командной строки. 
-baud бод-в-сек
-b бод-в-сек
    Устанавливает скорость линии (скорость в бодах, или в битах в секунду) 
любого последовательного интерфейса, используемого GDB для удаленной отладки. 
-tty устройство
-t устройство
    Запуститься, используя устройство для стандартного ввода и вывода вашей 
программы. 
-interpreter интерп
    Использовать интерпретатор интерп к качестве интерфейса с управляющей 
программой или устройством. Подразумевается, что этот ключ должет 
устанавливаться программами, которые взаимодействуют с GDB, используя его 
как выходной буфер. Например, `--interpreter=mi' велит GDB использовать 
интерфейс gdbmi (see section Интерфейс GDB/MI). 
-write
    Открыть выполняемый файл и файл дампа памяти как для чтения, так и для 
записи. Это эквивалентно команде GDB `set write on' (see section 
Внесение изменений в программу). 
-statistics
    Этот ключ велит GDB печатать статистику о времени и использовании 
памяти после завершения каждой команды и возврата к приглашению. 
-version
    Этот ключ велит GDB напечатать номер своей версии и объявление об 
отсутствии гарантий, и затем завершиться. 

Выход из GDB

quit [выражение]
q
    Чтобы выйти из GDB, используйте команду quit (сокращенно q), или введите 
знак конца файла (обычно C-d). Если вы не укажете выражение, GDB закончит работу 
нормально; в противном случае, он использует результат выражения как код ошибки. 

Прерывание (часто C-c) не приводит к выходу из GDB, а завершает любую 
выполняющуюся команду и возвращает вас на командный уровень. Вы можете безопасно 
пользоваться прерыванием в любое время, потому что GDB не позволяет ему вступить 
в силу до того, как это станет безопасным.

Если вы использовали GDB для управления присоединенным процессом или 
устройством, вы можете освободить его командой detach (see section Отладка 
запущенного ранее процесса).
Команды оболочки

Если вам случайно потребовалось выполнить команды оболочки в течение сеанса 
отладки, нет смысла приостанавливать или покидать GDB; вам достаточно 
воспользоваться командой shell.

shell командная строка
    Вызвать стандартную оболочку для выполнения командной строки. Переменная 
окружения SHELL, если она существует, определяет, какую оболочку запустить. 
В противном случае, GDB использует оболочку по умолчанию (`/bin/sh' в системах 
Unix, `COMMAND.COM' в MS-DOS, и так далее). 

В средах разработки часто бывает необходимо воспользоваться утилитой make. 
Для этой цели вам не обязательно пользоваться командой shell в GDB:

make make-арг
    Выполнить программу make с указанными аргументами. Это эквивалентно 
`shell make make-арг'. 

--------------------------------------------------------------------------------

From: Илья Аввакумов <http://fpc.by.ru>;
Newsgroups: http://fpc.by.ru
Date: Mon, 9 Dec 2003 14:31:37 +0000 (UTC)
Subject: Пример использования отладчика GNU GDB

Оригинал: http://fpc.by.ru/gdb.shtml
Автор: Илья Аввакумов.

Отладчик GNU GDB

Введение
--------

   Откровенно говоря, программа GNU GDB довольно многофункциональная.
   Пошаговая отладка -- лишь одна из ее возможностей. В этой статье я
   попытался описать те лишь команды GDB, которые позволяют проводить
   удобную пошаговую отладку программ, написанных на Free Pascal.

   Чтобы программу можно было отлаживать, она должна быть откомпилирована
   с ключом -g.

   Поскольку GDB ориентирован не на Pascal, а на C и C++, то
   использование GDB для отладки Pascal программ иногда сопряжено с
   неудобствами.

   Приведу список подводных камней, обнаруженных мною и разработчиками
   Free Pascal (перечисленных в user's manual).

    1. Отладочная информация в Free Pascal генерируется в верхнем
       регистре. Поэтому имена всех переменных, процедур, функций при
       использовании GDB должны указываться БОЛЬШИМИ БУКВАМИ.

    2. GDB не воспринимает тип extended (ведь в C такого типа нет).
       Обойти эту неприятность можно, если, например, включить в код
       такие строки
...
type
{$IFDEF DEBUG}
  dbl = double;
{$ELSE}
  dbl = extended;
{$ENDIF}
...
var x : dbl;
...

    3. К элементам многомерных массивов нужно обращаться в C-шной манере,
       а именно, команда
	    (gdb) print A[1,1]

       выдаст первую строку массива A. Для просмотра требуемого элемента
       следует писать
	    (gdb) print A[1][1]

    4. GDB не воспринимает множества.

    5. Есть трудности с поддержкой объектов (см. user's manual за
       подробностями).

    6. Есть трудности с глобально переопределенными функциями. (за
       подробностями см. user's manual).

    7. При отладке процедур, функций, расположенных в разных файлах,
       часто возникает несоответствие -- смещение строк. Та строка,
       которую GDB показывает текущей, таковой не является, а текущая
       расположена строк эдак на двадцать выше. Это приводит к большим
       неудобствам при пошаговой отладке. Я для себя сделал из этого
       такую мораль -- хоть GDB и позволяет отлаживать процедуры,
       описанные в разных файлах, но лучше этой возможностью не
       пользоваться, а на время отладки все вызываемые процедуры, работа
       которых вас заинтересует, помещать в одном файле.

   Все примеры отлаживались с использованием GNU GDB 5.0.


Запуск отладчика GDB
--------------------

   gdb [опции] [имя_файла | ID процесса]

   После запуска видим "nice GDB logo" (если это почему-то раздражает, то
   опция -q позволяет не выводить это введение с информацией об авторских
   правах и прочая). В следующей строке приглашение
   (gdb)
   ждет ввода команды.

   Ниже приводится краткий перечень команд GDB.

   Краткую справку о любой команде можно получить, введя
   (gdb) help [имя_команды, можно краткое]

   Если при запуске GDB имя исполняемого файла не было указано (что
   следовало бы делать), то указать его можно командой file.

Команда file

   (gdb) file <имя исполняемого файла, который подлежит отладке>

   Для того, чтобы пролистать содержимое исходника, используйте команду
   list (сокращенно l; большая часть наиболее полезных команд имеют
   сокращения). При этом подразумевается, что исходник расположен в том
   же каталоге, что и исполняемый файл. Как правило, так оно и есть.

Команда list (сокращенно l)

   Пролистывает 10 строк вниз, начиная с текущей. Для пролистывания вверх
   следует набрать

   (gdb) list -

Команда run (сокращенно r)

   Запускает отлаживаемую программу под GDB. Если требуется, то после
   команды можно указать список аргументов программы. Также допускается
   перенаправление потоков ввода и вывода в другие файлы, например

	(gdb) run > outfile

   Если никаких точек останова не определено, то программа выполняется
   тихо, при этом нам сообщается:

	(gdb) run
	Starting program: test
	Program exited normally.
	(gdb)

   Если же отладчик встречает точку останова, он выдает ее номер, адрес и
   дополнительную информацию -- текущую строку, имя процедуры, и т.п.

	(gdb) r
	Breakpoint 1, main () at test.pp:3
	Current language: auto; currently pascal
	3 x := x + 1;
	(gdb)

   И ожидает ввода команды.


Остановка отладки программы
---------------------------

   Команда kill (k). Следует запрос
	
        (gdb) kill
	Kill the program being debugged? (y or n) y
	(gdb)

   Здесь введено y (то есть "да"), и отладка программы прекращается.
   Командой run ее можно начать заново, при этом все точки останова
   (breakpoints), точки просмотра (watchpoints) и точки отлова
   (catchpoints) сохраняются.


Выход из отладчика
------------------

   Команда quit (q).
	(gdb) q
	[avva@localhost home]$


Точки останова
--------------

   Информацию о командах этого раздела можно получить, введя
   (gdb) help breakpoints

   Точки останова -- такие, когда GDB приостанавливает выполнение
   программы. Как уже упоминалось, имеется 3 типа точек останова:

    1. Breakpoints -- точка останова как таковая. Остановка происходит,
       когда выполнение доходит до определенной строки, адреса или
       процедуры/функции.

    2. Watchpoints -- точка просмотра. Выполнение программы
       приостанавливается, если программа обратилась к определенной
       переменной -- либо считала ее значение, либо изменила его.

    3. Catchpoints -- точка отлова. Приостановка происходит при
       определенном событии (например, получение сигнала). Я не буду
       касаться точек останова этого типа.

Определение точек останова

Breakpoint

   Команда break
       (gdb) break [аргумент]
   или, сокращенно
       (gdb) b [аргумент]

   определяет точку останова. В качестве аргумента может выступать

     * номер строки. Остановка произойдет при достижении строки программы
       с этим номером. То, что написано в самой строке, выполняться не
       будет. Например

	    (gdb) b 394 Breakpoint 1 at 0x805a650: file maeq.pas, line 394.

     * имя процедуры (функции). Отладчик зайдет в эту процедуру и
       остановит выполнение программы. NB!! Имя процедуры (функции)
       должно быть указано БОЛЬШИМИ БУКВАМИ. Приведу пример:

	    (gdb) b CALC Breakpoint 2 at 0x7657c7a: file maeq.pas, line 26.

     * если вызвать команду break без аргументов, то точка останова
       поставится на текущей строке.

     * также можно явно указывать адрес точки останова (перед адресом
       надо поставить знак *). Приведу лишь пример для полноты описания:

	    (gdb) b *0x805a650 Breakpoint 3 at 0x805a650: file maeq.pas, line 394.

   Допускается использование нескольких точек останова на одной строке
   (функции, адресе).

Watchpoint

   Существуют различные виды точек просмотра, и задаются они различными
   командами:

     * команда watch (сокращенно wa)
	    (gdb) wa <переменная>

       Выполнение программы приостанавливается всякий раз, когда значение
       указанной переменной изменяется.
       NB!! Имя переменной должно быть указано БОЛЬШИМИ БУКВАМИ.

     * команда rwatch (сокращенно rw)
	    (gdb) rw <переменная>

       Выполнение приостанавливается всякий раз, когда программа
       считывает значение указанной переменной.
       NB!! Имя переменной должно быть указано БОЛЬШИМИ БУКВАМИ.

     * команда awatch (сокращенно aw)
	    (gdb) aw <переменная>

       Выполнение приостанавливается всякий раз, когда программа
       обращается к указанной переменной, как для считывания, так и для
       записи.
       NB!! Имя переменной должно быть указано БОЛЬШИМИ БУКВАМИ.

   Замечу от себя, что команды rwatch и awatch у меня почему-то
   капризничают -- часто не устанавливают точки просмотра на переменную.
   Зато команда watch работала всегда.


Управление точками останова

   Информацию о всех установленных точках останова можно вывести командой
   info.

   Команда info имеет много возможностей, но в данном случае
   воспользуемся лишь следующим ее форматом:
       (gdb) info breakpoints
   или, кратко
       (gdb) i b

   Выводится подробная информация о всех точках останова (как
   breakpoints, так и watchpoints), включающая - номер - breakpoint или
   watchpoint - активность - сколько раз программа натыкалась на эту
   точку - иные характеристики, значение которых мне не совсем понятно

   Если какая-то точка останова не нужна, то ее можно сделать неактивной
   с помощью команды disable:

	(gdb) disable breakpoint <номер этой точки>

   Обратно, деактивированная точка останова активируется командой enable:

	(gdb) enable breakpoint <номер этой точки>

   Статус точки останова -- активна она или нет, легко обозреть той же
   командой info.

   Если же точка останова не требуется вообще, то она может быть удалена
   насовсем.

	(gdb) delete breakpoint [номер точки]

   а короче

	(gdb) d b [номер точки]

   Ввод этой команды без аргумента удалит ВСЕ точки останова.

Возобновление выполнения, пошаговая отладка
-------------------------------------------

   Информацию о командах этого раздела можно получить, введя
	
       (gdb) help running

Команда continue (c)

	(gdb) с [аргумент]

   Продолжает выполнение остановленной программы. Выполнение будет
   происходить, пока снова не встретится точка останова. В качестве
   аргумента может использоваться целое число N. Это укажет отладчику
   проигнорировать (N-1) точку останова (выполнение остановится на N-ой).

Команда step (s)

	(gdb) s [аргумент]

   Аналог действия клавиши F7 (Trace into) в IDE. Происходит выполнение
   программы до тех пор, пока не будет достигнута следующая строка ее
   кода. При указании аргумента -- целого числа N, отладчик выполняет
   команду step N раз (если не останавливает выполнение из-за точек
   останова или по иным причинам).

Команда next (n)

	(gdb) n [аргумент]

   Аналог действия клавиши F8 (Step over) в IDE. В отличие от step вызов
   процедуры считается единой инструкцией (не заходит в вызываемые
   процедуры, функции). Аргумент N работает так же, как и для step.

Команда finish (fin)

	(gdb) fin

   Выполняет программу до момента выхода из текущей процедуры (функции).
   Если функция возвращает значение, то это значение выводится тоже.

Команда until (u)

   Производит выполнение программы до тех пор, пока не будет достигнута
   строка с номером, большим текущего. Команду until удобно применять при
   отладке циклов. Остановка произойдет также, если программа при
   выполнении цикла выйдет из текущей процедуры, функции.

Команда stepi (si)

	(gdb) si [аргумент]

   Действие подобно step, но выполняется не строка, а ровно одна
   инструкция в этой строке программы. Аргумент N нужен, если требуется
   выполнить N инструкций.

Команда nexti (ni)

	(gdb) ni [аргумент]

   Аналогична stepi, но вызовы процедур трактуются как одна инструкция.


Управление состоянием (просмотр, изменение) переменных при отладке

   Информацию о командах этого раздела можно получить, введя
(gdb) help data

Команда print (p)

	(gdb) print <выражение>

   Вывод текущего значения переменной (выражения). При использовании
   команды print имя переменной можно писать в смешанном регистре, то
   есть в этом случае использование больших букв обязательным не
   является.

   Часто требуется отслеживать значения нескольких переменных. Чтобы не
   утруждать себя многократным вводом команды print, используйте команду
   display.

Команда display

	(gdb) display [аргумент]

   В качестве аргумента обычно указывают переменную или выражение. При
   этом указанная переменная (выражение) занесется в дисплей, то есть
   станет выводиться при каждой остановке программы (при попадании на
   точку останова, при пошаговом выполнении командами step и next, etc).
   Если вызвать display без аргументов, то GDB выдаст значения всех
   переменных (выражений), занесенных в дисплей.

   Управление списком этих переменных осуществляется аналогично точ- кам
   останова. А именно, команда info display

	(gdb) info display

   выдаст все переменные, занесенные в дисплей. Любая переменная в списке
   дисплея может быть дезактивирована

	(gdb) disable display <номер переменной в списке дисплея>

   или активирована заново

	(gdb) enable display <номер переменной в списке дисплея>

   Удаление переменной из списка дисплея производится командой delete или
   командой undisplay. Так, команда

	(gdb) delete display [номер переменной в списке дисплея]

   делает то же, что и

	(gdb) undisplay [номер переменной в списке дисплея]

   Опять-таки, если не указать номер переменной, то очистится весь список
   отображаемых переменных.

Изменение значения переменной

   И последнее. Изменение значения переменной на другое можно, например,
   произвести с помощью команд set или print.

	(gdb) set <оператор присваивания>
	(gdb) print <оператор присваивания>

   Например,

	(gdb) whatis x
	TYPE = WORD
	(gdb) p x
	$1 = 1
	(gdb) set x:=2
	(gdb)

   При использовании set присваивание происходит "тихо". То же самое
   можно сделать, но с помощью команда print.

   Например,

	(gdb) p x
	$2 = 2
	(gdb) p x:=x-2
	$3 = 0
	(gdb)

   При этом, как видно, выводится новое значение переменной.

   Вот и все.

   Удачной отладки!
   © Илья Аввакумов aka AvvA, 2003

   Опубликовано: FPC by RUssian © Иван Шихалев, 2001 - 2003 http://fpc.by.ru/
